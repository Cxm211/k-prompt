return 2 + (end - start) + (isHex? 1 : 0) + 1;             }             return 0;             }             return 1;             }             return 2;             }             return 3;             }             return 4;             }             return 5;             }             return 6;             }             return 7;             }             return 8;             }             return 9;             }             return 10;             }             return 11;             }             return 12;             }             return 13;             }             return 14;             }             return 15;             }             return 16;             }             return 17;             }             return 18;             }             return 19;             }             return 20;             }             return 21;             }             return 22;             }             return 23;             }             return 24;             }             return 25;             }             return 26;             }             return 27;             }             return 28;             }             return 29;             }             return 30;             }             return 31;             }             return 32;             }             return 33;             }             return 34;             }             return 35;             }             return 36;             }             return 37;             }             return 38;             }             return 39;             }             return 40;             }             return 41;             }             return 42;             }             return 43;             }             return 44;             }             return 45;             }             return 46;             }             return 47;             }             return 48;             }             return 49;             }             return 50;             }             return 51;             }             return 52;             }             return 53;             }             return 54;             }             return 55;             }             return 46;             }             return 47;             }             return 48;             }             return 49;             }
:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  default:             if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(r
! public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!= 0;       } public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.get(type)!=
*/ public ElitisticListPopulation(final List<Chromosome> chromosomes, final int populationLimit) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      public double getElitismRate() {         return elitismRate;      }      public void setElitismRate(final double elitismRate) {         this.elitismRate = elitismRate;      }      public List<Chromosome> getChromosomes() {         return chromosomes;      }      public void setChromosomes(final List<Chromosome> chromosomes) {         this.chromosomes = chromosomes;      }      public void setPopulationLimit(final int populationLimit) {         this.populationLimit = populationLimit;      }      public int getPopulationLimit() {         return populationLimit;      }      public void setPopulationLimit(final int populationLimit) {         this.populationLimit = populationLimit;      }      public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {         super(chromosomes, elitismRate);         this.elitismRate = elitismRate;      }      public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {         super(chromosomes, elitismRate);         this.elitismRate = elitismRate;      }      public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {         super(chromosomes, elitismRate);         this.elitismRate = elitismRate;      }      public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {         super(chromosomes, elitismRate);         this.elitismRate = elitismRate;      }      public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {         super(chromosomes, elitismRate);         this.elitismRate = elitismRate;      }      public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {
private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }
.getType());              }              return result;           }          public long removeWrapField(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.removeWrapField(localInstant);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to time zone offset transition: " + HANGUL.getType());              }              return result;           }          public int get(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.get(localInstant);             int result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to time zone offset transition: " + HANGUL.getType());              }              return result;           }          public void set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);           }          public void removeWrapField(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.removeWrapField(localInstant);           }          public void set(int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);           }          public void removeWrapField(int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.removeWrapField(localInstant);           }          public void removeWrapField(int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.removeWrapField(localInstant);           }          public void removeWrapField(int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.removeWrapField(localInstant);           }          public void removeWrapField(int value) {              long localInstant = iZone.convertUTCToLocal(instant);
.printTo(buf, value);              }              int maxDigits = iMaxPrintedDigits;              if (maxDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              if
= FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_HOUR);          return DateTimeZone.forOffset(offset);          }
private static Number createNumber(String str, int decPos, int expPos) throws NumberFormatException {             if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;             }             if (expPos > -1) {                  mant = str.substring(0, expPos);             }             return mant;             }
private Week(Date time, TimeZone zone, Locale locale) {       if (time == null) {           throw new NullPointerException("time");           }           if (zone == null) {           throw new NullPointerException("zone");           }           if (locale == null) {           throw new NullPointerException("locale");           }           if (this.time == null) {           throw new NullPointerException("this.time");           }           final Week other = (Week) this;           if (other.time!= null) {           return other.time;           }           final Week clone = (Week) super.clone();           if (other.time!= null) {           return clone;           }           return other;           }
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    }    static double getSimpleNumber(String s) {             int len = s.length();             for (int index = 0; index < len; index++) {             char c = s.charAt(index);             if (c < '0' || c > '9') {               return false;             }           }             return s.charAt(0)!= '0';           }
private static long reduceAndCorrect(long start, long end, long min, long max) {     if (min < 0) {         min = 0;     }     if (max < 0) {         max = 0;     }     if (min > max) {         return min;     }     return max; }
private void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++;             } else {             if (value < firstMoment.getValue()) {               firstMoment.setValue(value);             }             if (value > secondMoment.getValue()) {               secondMoment.setValue(value);             }             if (value < meanImpl.getValue()) {               meanImpl.setValue(value);             }             if (value > varianceImpl.getValue()) {               varianceImpl.setValue(value);             }             if (value < geoMeanImpl.getValue()) {               geoMeanImpl.setValue(value);             }           } else {               if (value < firstMoment.getValue()) {               firstMoment.setValue(value);             }           } else {               if (value > secondMoment.getValue()) {               secondMoment.setValue(value);             }           } else {               if (value < meanImpl.getValue()) {               meanImpl.setValue(value);             }           } else {               if (value > varianceImpl.getValue()) {               varianceImpl.setValue(value);             }           } else {               if (value < geoMeanImpl.getValue()) {               geoMeanImpl.setValue(value);             }           }
private double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yC;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yD;              } else {                  targetY = 0;             }             return targetY;           }
private void setWeekOfWeekyear(final int weekOfWeekyear) {             setMillis(getChronology().weeks().set(getMillis(), weekOfWeekyear));             }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks) {               setMillis(getChronology().weeks().add(getMillis(), weeks));               }             public void addWeeks(final int weeks
protected VectorialPointValuePair doOptimize() {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             return new VectorialPointValuePair(pj, jacobian[pj][pj], residuals[pj]);           } else {             return new VectorialPointValuePair(pj, jacobian[pj][pj], residuals[pj]);           }
! JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;    }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      protected BasePeriod(long duration, ReadableInstant endInstant, Peri peri) {         super(duration, endInstant, peri);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent) {         super(duration, endInstant, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child) {         super(duration, endInstant, parent, child);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent);      }      protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri parent, Peri child, Peri parent) {         super(duration, endInstant, parent, child, parent
*/     private static final ThreadLocal<Set<IDKey>> REGISTRY2 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY3 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY4 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY5 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY6 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY7 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY8 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY9 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>> REGISTRY10 = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };     private static final ThreadLocal<Set<IDKey>>
CategoryDataset dataset = this.plot.getDataset(index);             if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount();             if (seriesCount!= result.size()) {             return result;           }           LegendItemCollection result = new LegendItemCollection(seriesCount);             result.addAll(result.items());             return result;           }
private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence input, Reader out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }          public final void translate(CharSequence
private double getExponentTerm(final double[] vals) throws DimensionMismatchException {             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }             return FastMath.pow(2 * FastMath.PI, -dim / 2) *              getExponentTerm(vals);          }
[j] = str.charAt(i);             }             return thisBuf[startIndex] - strLen;          }     public int indexOf(String str) {             return indexOf(str, 0);          }     public int indexOf(char[] str) {             return indexOf(str, 0);          }     public int lastIndexOf(char[] str) {             return lastIndexOf(str, 0);          }     public int lastIndexOf(String str) {             return lastIndexOf(str, 0);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf(str, startIndex);          }     public int lastIndexOf(char[] str, int startIndex) {             return lastIndexOf
= true;             if (input!= null) {             inputs.removeChild(input);             }             return null;           } else {             if (input!= null) {             inputs.addChild(input);             }             return this;           }
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu) {             return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),             container           );           }             return null;           }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no, boolean notPrinter) {              PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notPrinter);                  f = f.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) {             PeriodFormatter f = toFormatter(elementPairs.subList(0, size), notPrinter, notPrinter);             return new PeriodFormatter(sep, sep);          }          return new PeriodFormatter(sep, sep);         }
== cal2.get(Calendar.ERA)); }  public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.get(Calendar.ERA) &&                  cal1.
;             return false;             } else if (value == null) {             return false;             } else if (value instanceof Node) {             return true;             } else {             return false;           }
final double tol3 = eps * Math.abs(x) + t;              final double tol4 = 2 * tol2;              final double tol5 = 2 * tol3;              final double tol6 = 2 * tol4;              final double tol7 = 2 * tol5;              final double tol8 = 2 * tol6;              final double tol9 = 2 * tol7;              final double tol10 = 2 * tol8;              final double tol11 = 2 * tol9;              final double tol12 = 2 * tol10;              final double tol13 = 2 * tol11;              final double tol14 = 2 * tol12;              final double tol15 = 2 * tol15;              final double tol16 = 2 * tol16;              final double tol17 = 2 * tol17;              final double tol18 = 2 * tol18;              final double tol19 = 2 * tol19;              final double tol20 = 2 * tol20;              final double tol21 = 2 * tol21;              final double tol22 = 2 * tol22;              final double tol23 = 2 * tol23;              final double tol24 = 2 * tol24;              final double tol25 = 2 * tol25;              final double tol26 = 2 * tol26;              final double tol27 = 2 * tol27;              final double tol28 = 2 * tol28;              final double tol29 = 2 * tol29;              final double tol30 = 2 * tol30;              final double tol31 = 2 * tol31;              final double tol32 = 2 * tol32;              final double tol33 = 2 * tol33;              final double tol34 = 2 * tol34;              final double tol35 = 2 * tol35;              final double tol36 = 2 * tol36;              final double tol37 = 2 * tol37;              final double tol38 = 2 * tol38;              final double tol39 = 2 * tol39;              final double tol40 = 2 * tol40;              final double tol41 = 2 * tol41;              final double tol42 = 2 * tol42;              final double tol43 = 2 * tol43;              final double tol44 = 2 * tol44;              final double tol45 = 2 * tol45;              final double tol46 = 2 * tol46;              final double tol47 = 2 * tol47;              final double tol48 = 2 * tol48
public void collect(JSModule module, Scope scope, Node n) {                  type = Name.Type.FUNCTION;                  break;                case Token.VAR:                case Token.DEF:                  type = Name.Type.VAR;                  break;                case Token.LDC:                  type = Name.Type.LDC;                  break;                case Token.RDC:                  type = Name.Type.RDC;                  break;                case Token.IF:                  type = Name.Type.IF;                  break;                case Token.ELSE:                  type = Name.Type.ELSE;                  break;                case Token.FOR:                  type = Name.Type.FOR;                  break;                case Token.GOTO:                  type = Name.Type.GOTO;                  break;                case Token.IN:                  type = Name.Type.IN;                  break;                case Token.JUMP:                  type = Name.Type.JUMP;                  break;                case Token.KEY:                  type = Name.Type.KEY;                  break;                case Token.LDC_KEY:             type = Name.Type.LDC_KEY;             break;                case Token.RDC_KEY:             type = Name.Type.RDC_KEY;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.RBRACE:             type = Name.Type.RBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break;                case Token.LBRACE:             type = Name.Type.LBRACE;             break
private boolean isPrototypePropertyAssign(Node assign) {             Node n = assign.getFirstChild();             if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {              boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;             return isChainedProperty;           }             return super.isPrototypePropertyAssign(assign);           }
!             Node assign = processInfixExpression(assignmentNode);             return assign;             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral literalNode) {             return processArrayLiteral(literalNode);             }             Node processArrayLiteral(ArrayLiteral
private Node tryFoldArrayJoin(Node n) {       Node left = callTarget.getFirstChild();       if (left!= null) {          if (!NodeUtil.isImmutableValue(left)) {           return n;           }       Node right = callTarget.getNext();       if (right!= null) {           if (!NodeUtil.isImmutableValue(right)) {             return n;           }       Node parent = callTarget.getParent();           if (parent!= null) {             return parent;           }           return n;           }
private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }             private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }    private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }    private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }    private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }    private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }    private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }    private class AliasedTypeNode implements AliasUsage {        private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;
protected void dropPhase1Objective() {             for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) < 0) {                  columnsToDrop.add(i);              }             }             tableau = null;           }
private class TimerImpl extends Timer {             public TimerImpl() {             super();             }             public TimerImpl(String name) {             super(name);             }             public TimerImpl(String name, Throwable cause) {             super(name, cause);             }             public TimerImpl(Throwable cause) {             super(cause);             }             public TimerImpl(String name, boolean enableSuppression, boolean writableStackTrace) {             super(name, enableSuppression, writableStackTrace);             }             public TimerImpl(String name) {             super(name);             }             public TimerImpl(String name, boolean enableSuppression) {             super(name, enableSuppression);             }             public TimerImpl(String name, boolean enableSuppression, boolean writableStackTrace) {             super(name, enableSuppression, writableStackTrace);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj, boolean enableSuppression) {             super(obj, enableSuppression);             }             public TimerImpl(Object obj, boolean enableSuppression) {             super(obj);             }             public TimerImpl(Object obj, boolean enableSuppression) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj, boolean enableSuppression) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object obj) {             super(obj);             }             public TimerImpl(Object
private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node parent) {     return false;     }    private boolean shouldReportThis(Node n, Node
private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LB) {      return reportTypeSyntaxWarning("msg.jsdoc.missing.lb");      }      return null;    }      private Node reportTypeSyntaxWarning(String message) {       return new Error(message);     }      @Override     public Node accept(NodeVisitor visitor) {       if (visitor!= null) {         visitor.visit(this);       }       return this;     }      @Override     public void accept(NodeVisitor visitor) {       if (visitor!= null) {         visitor.visit(this);       }     }      @Override     public boolean equals(Object obj) {       if (this == obj) {         return true;       }       if (obj == null) {         return false;       }       if (getClass()!= obj.getClass()) {         return false;       }       JsDocNode other = (JsDocNode) obj;       if (name!= null?!name.equals(other.name) : other.name!= null) {         return false;       }       if (value!= null?!value.equals(other.value) : other.value!= null) {         return false;       }       return true;     }      @Override     public int hashCode() {       if (name!= null?!name.hashCode() : other.name!= null) {         return 0;       }       if (value!= null?!value.hashCode() : other.value!= null) {         return 0;       }       return 1;     }      @Override     public String toString() {       return "JsDocNode{" +           "name='" + name + '\'' +           ", value='" + value + '\'' +           '}';     } }
.       * If both the real and imaginary parts of the complex number       * are exactly the same, and neither is {@code Double.NaN}, the two       * Complex objects are considered to be equal.       * All {@code NaN} values are considered to be equal - i.e, if either       * (or both) real and imaginary parts of the complex number       * are equal Pharmacy.       */ public boolean equals(Complex other) {          if (isNaN || other.isNaN) {              return NaN;          }         if (other.getReal() == 0.0 && other.getImaginary() == 0.0) {             return NaN;          }          if (other.isInfinite() &&!isInfinite()) {              return ZERO;          }          final double c = other.getReal();          final double d = other.getImaginary();          if (FastMath.abs(c) < FastMath.abs(d)) {              double q = c / d;              double denominator = c * q + d;              return createComplex((real * q + imaginary) / denominator,                  (imaginary * q - real) / denominator);          } else {              double q = d / c;              double denominator = d * q + c;              return createComplex((imaginary * q + real) / denominator,                  (imaginary - real * q) / denominator);          }      public boolean equals(double divisor) {          if (isNaN || Double.isNaN(divisor)) {              return NaN;          }          if (divisor == 0d) {             return NaN;          }          if (Double.isInfinite(divisor)) {              return!isInfinite()? ZERO : NaN;          }          return createComplex(real / divisor,                               imaginary  / divisor);      }      /**       * Test for the equality of two Complex objects.       * If both the real and imaginary parts of two complex numbers       * are exactly the same, and neither is {@code Double.NaN}, the two       * Complex objects are considered to be equal.       * All {@code NaN} values are considered to be equal - i.e, if either       * (or both) real and imaginary parts of the complex number       * are equal Pharmacy.       */
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)             {             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted, best) < 0) {                 return;             }             final RealPointValuePair contracted2 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted2, best) < 0) {                 return;             }             final RealPointValuePair contracted3 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted3, best) < 0) {                 return;             }             final RealPointValuePair contracted4 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted4, best) < 0) {                 return;             }             final RealPointValuePair contracted5 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted5, best) < 0) {                 return;             }             final RealPointValuePair contracted6 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted6, best) < 0) {                 return;             }             final RealPointValuePair contracted7 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted7, best) < 0) {                 return;             }             final RealPointValuePair contracted8 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted8, best) < 0) {                 return;             }             final RealPointValuePair contracted9 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted9, best) < 0) {                 return;             }             final RealPointValuePair contracted10 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted10, best) < 0) {                 return;             }             final RealPointValuePair contracted11 = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted11, best) < 0) {                 return;             }             final RealPointValuePair contracted12 = evaluateNewSimplex(original, gamma, comparator);             if
(errors[i], covar[i]);          }          return errors;         }          private double[][] getCovariances(EstimationProblem problem) {             int m = problem.getMeasurements().length;             int p = problem.getAllParameters().length;             if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                     new Object[] { new Integer(m), new Integer(p)});          }         double[][] covar = new double[m][p];             for (int i = 0; i < covar.length; ++i) {             covar[i] = getChiSquare(problem) / (m - p);           }           return covar;         }          private double getChiSquare(EstimationProblem problem) {             int m = problem.getMeasurements().length;             int p = problem.getAllParameters().length;             if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                     new Object[] { new Integer(m), new Integer(p)});          }         double c = Math.sqrt(getChiSquare(problem) / (m - p));             return c;         }          private double[][] getCovariances(EstimationProblem problem) {             int m = problem.getMeasurements().length;             int p = problem.getAllParameters().length;             if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                     new Object[] { new Integer(m), new Integer(p)});          }         double[][] covar = new double[m][p];             for (int i = 0; i < covar.length; ++i) {             covar[i] = getChiSquare(problem) / (m - p);           }           return covar;         }          private double getChiSquare(EstimationProblem problem) {             int m = problem.getMeasurements().length;             int p = problem.getAllParameters().length;             if (m <= p) {              throw new EstimationException("
private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }             new Reporter().smartNullPointerException(location);               return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }
private static final Instant DEFAULT_CUTOVER = Instant.ofEpochMilli(0);          public static final Instant getCutoverInstant() {              return cutoverInstant;          }          public static final GJChronology getChronology() {              return gregorianCutover;          }          public static final GJChronology getChronology(Instant cutoverInstant) {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJChronology getChronology() {              return chrono;          }          public static final GJ
private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return recordDeepStubMock(mock, container);           }             return mock;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;           }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;
private long roundFloor(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.roundFloor(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);           }             return iField.roundFloor(instant);
! public boolean evaluateStep(final StepInterpolator interpolator, final double value) {     if (value < 0) {         value = -value;     }     if (value > gb) {         value = gb;     }     if (value < 0) {         value = -value;     }     if (value > gb) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;     }     if (value < 0) {         value = -value;
private void visitSetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType()!= null && parent.isAssign()) {       return;     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);             }             if (parent!= null) {               parent.removeChildFromParent(parent);             }             return;           }
private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }             return greatestCommonDivisor(u, v);         }      public Fraction pow(int power) {         if (power == 0) {             return this;         }         if (power == 1) {             return this;         }         if (power == 2) {             return this;         }         if (power == 3) {             return this;         }         if (power == 4) {             return this;         }         if (power == 5) {             return this;         }         if (power == 6) {             return this;         }         if (power == 7) {             return this;         }         if (power == 8) {             return this;         }         if (power == 9) {             return this;         }         if (power == 10) {             return this;         }         if (power == 11) {             return this;         }         if (power == 12) {             return this;         }         if (power == 13) {             return this;         }         if (power == 14) {             return this;         }         if (power == 15) {             return this;         }         if (power == 16) {             return this;         }         if (power == 17) {             return this;         }         if (power == 18) {             return this;         }         if (power == 19) {             return this;         }         if (power == 20) {             return this;         }         if (power == 21) {             return this;         }         if (power == 22) {             return this;         }         if (power == 23) {             return this;         }         if (power == 24) {             return this;         }         if (power == 25) {             return this;
static void register(Object value) {         getRegistry().put(new IDKey(value), value);      }      /**             */      /**             */     private static final class IDKey {         /**             */         private final Object value;          /**             */         private IDKey(Object value) {             this.value = value;         }          /**             */         @Override         public boolean equals(Object obj) {             if (this == obj) {                 return true;             }             if (obj == null) {                 return false;             }             if (getClass()!= obj.getClass()) {                 return false;             }             IDKey other = (IDKey) obj;             if (value!= null?!value.equals(other.value) : other.value!= null) {                 return false;             }             return true;         }          /**             */         @Override         public int hashCode() {             if (value!= null) {                 return value.hashCode();             }             return 0;         }     } }
private OriginalMapping getOriginalMappingForEntry(Entry entry) {          Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }             return x.build();             }
private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) {             if (scriptNodeCount!= scriptNodeCount + 1) {               if (filename!= null) {               filename.detachFromParent();             }               scriptNodeCount = scriptNodeCount + 1;               if (filename!= null) {               filename.replaceChild(parent, filename);             }           } else {             if (filename!= null) {               filename.detachFromParent();             }           if (parent!= null) {               parent.removeChild(parent);             }           }
private void inlineNonConstants(Node nameNode) {            if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {              List<Reference> refs = referenceInfo.references;              for (int i = 1 ; i < refs.size() ; i++) {                Node nameNode = refs.get(i).getNode();                if (nameNode!= null) {                   nameNode.replaceChild(parent, nameNode);               }               parent = nameNode;             }           } else {             if (parent!= null) {               parent.removeChild(parent);             }           if (value!= null) {               value.detachFromParent();           }           if (maybeModifiedArguments) {             if (value!= null) {               value.detachFromParent();           }           if (referenceInfo!= null) {               referenceInfo.detachFromParent();           }           if (parent!= null) {               parent.removeChild(this);           }         }
void addIdentifier(String identifier) {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             */             }             }
private void captureArgumentsFrom(Invocation invocation) {              Matcher m = matchers.get(indexOfVararg);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else {             if (invocation!= null) {                 invocation.removeArgumentFromParent();             }             if (matchers!= null) {                 matchers.clear();             }             return;           }
private static double sinh(double x) {             if (x > 20) {                return 0.5 * sinh(x);            }       if (x < -20) {                return -0.5 * sinh(-x);        }       if (x == 0) {             return 1.0;           }         return 0.0;           }
static Double getStringNumberValue(String rawJsString) {             String s = trimJsWhiteSpace(rawJsString);             return Number.valueOf(s);             }      private static String trimJsWhiteSpace(String s) {             if (s == null) {             return null;             }             return s.trim();             }
= paramBuilder.build();             }             return parametersNode;             }             return null;             }             return null;             }             return null;             }             return null;             }             return null;             }             return null;             }             return null;             }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return null;         }             return
= ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > maxRatio) {                      maxRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;             }             if (MathUtils.compareTo(rhs, 0, epsilon) <= 0) {                  final double ratio = rhs / entry;                  if (ratio > minRatio) {                  minRatio = ratio;
private void handleObjectLit(NodeTraversal t, Node n) {            String name = child.getString();             child = child.getNext();             node.replaceChild(parent, name, child);           } else {             if (parent!= null) {               parent.removeChild(parent);             }             node = parent;           }
private static void escapeJavaStyleString(Writer out, String str, boolean escape) {         if (escape) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);         }     }      private static void escapeJavaStyleString(Writer out, String str) {         if (escape) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);         }     }      private static void escapeJavaStyleString(Writer out, String str, boolean escape, boolean escape1) {         if (escape1) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);         }     }      private static void escapeJavaStyleString(Writer out, String str, boolean escape, boolean escape2) {         if (escape2) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);         }     }      private static void escapeJavaStyleString(Writer out, String str, boolean escape, boolean escape3) {         if (escape3) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);         }     }      private static void escapeJavaStyleString(Writer out, String str, boolean escape, boolean escape4) {         if (escape4) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);         }     }      private static void escapeJavaStyleString(Writer out, String str, boolean escape, boolean escape5) {         if (escape5) {             out.write('\\');             out.write(str);             out.write('\\');         } else {             out.write(str);
*/      static void setRegistered(Object value) {         getRegistry().put(new IDKey(value), value);      }      /**             */      static String getRegistered(Object value) {         return getRegistry().get(new IDKey(value));      }      /**             */      static void removeRegistered(Object value) {         getRegistry().remove(new IDKey(value));      }      /**             */      static String getRegistered(Object value) {         return getRegistry().get(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean removeRegistered(Object value) {         return getRegistry().remove(new IDKey(value));      }      /**             */      static boolean remove
private void registerTypeVariablesOn(Type classType) {             if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }             super.registerTypeVariablesOn(typeParameter);           }             /**             * <!-- begin-user-doc -->             * <!-- end-user-doc -->             * @generated             */            @Override            public Object eGet(int featureID, boolean resolve, boolean coreType) {              switch (featureID) {                case PackageManager.TYPE_VARIABLES:                  return contextualActualTypeParameters;              }              return super.eGet(featureID, resolve, coreType);            }             /**             * <!-- begin-user-doc -->             * <!-- end-user-doc -->             * @generated             */            @Override            public void eSet(int featureID, Object newValue) {              switch (featureID) {                case PackageManager.TYPE_VARIABLES:                  contextualActualTypeParameters = newValue;              }              super.eSet(featureID, newValue);            }             /**             * <!-- begin-user-doc -->             * <!-- end-user-doc -->             * @generated             */            @Override            public void eUnset(int featureID) {              switch (featureID) {                case PackageManager.TYPE_VARIABLES:                  contextualActualTypeParameters = null;              }              super.eUnset(featureID);            }             /**             * <!-- begin-user-doc -->             * <!-- end-user-doc -->             * @generated             */            @Override            public boolean eIsSet(int featureID) {              switch (featureID) {                case PackageManager.TYPE_VARIABLES:                  return contextualActualTypeParameters!= null;              }            }     /**     * <!-- begin-user-doc -->     * <!-- end-user-doc -->     * @generated     */    @Override    public String toString() {      if (eIsProxy()) return super.toString();
! boolean expectCanAssignToProperty(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       return false;      return true; }
