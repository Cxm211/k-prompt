public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  {                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0) + 1;          }
protected final double computeObjectiveValue(final double x0) {             return 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));             }
public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);           return true;         }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }   }
private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      public double getElitismRate() {          return this.elitismRate;         }      public void setElitismRate(final double elitismRate) {          this.elitismRate = elitismRate;         }      public void addChromosome(final Chromosome chromosome) {          this.chromosomes.add(chromosome);         }      public void removeChromosome(final Chromosome chromosome) {          this.chromosomes.remove(chromosome);         }      public List<Chromosome> getChromosomes() {          return this.chromosomes;         }      public void setChromosomes(final List<Chromosome> chromosomes) {          this.chromosomes = chromosomes;         }      public void setPopulationLimit(final int populationLimit) {          this.populationLimit = populationLimit;         }      public int getPopulationLimit() {          return this.populationLimit;         }      public void setPopulationLimit(final int populationLimit) {          this.populationLimit = populationLimit;         }      public void setElitismRate(final double elitismRate) {          this.elitismRate = elitismRate;         }      public double getElitismRate() {          return this.elitismRate;         }      public void setElitismRate(final double elitismRate) {          this.elitismRate = elitismRate;         }      public void setChromosomes(final List<Chromosome> chromosomes) {          this.chromosomes = chromosomes;         }      public void setPopulationLimit(final int populationLimit) {          this.populationLimit = populationLimit;         }      public int getPopulationLimit() {          return this.populationLimit;         }      public void setPopulationLimit(final int populationLimit) {          this.populationLimit = populationLimit;         }      public void setElitismRate(final double elitismRate) {          this.elitismRate = elitismRate;         }      public double getElitismRate
private void visitNode(NodeTraversal t, Node n) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             grandparent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {               out.defaultWriteObject();             }             private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           in.defaultReadObject();           }           private void readObjectNoData() throws java.io.IOException {           }           private void writeObjectNoData(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void readObjectNoData(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           }           private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           }           private void readObjectNoData() throws java.io.IOException {           }           private void readObjectNoData(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           }           private void readObjectNoData() throws java.io.IOException {           }           private void readObjectNoData(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           }           private void readObjectNoData() throws java.io.IOException {           }           private void readObjectNoData(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           }           private void readObjectNoData() throws java.io.IOException {           }           private void readObjectNoData(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           }           private void readObject(java.io.ObjectInputStream in) throws java.io.IOException
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }             else {             }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }           else {           }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          {             if (hoursOffset == 0 && minutesOffset == 0) {               return DateTimeZone.UTC;           }             if (minutesOffset < 0 || minutesOffset > 59) {               throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);           }           int offset = 0;           try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);             if (hoursInMinutes < 0) {               minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);             }             else {               minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);             }             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) {             if (hoursOffset == 0 && minutesOffset == 0) {               return DateTimeZone.UTC;           }             if (minutesOffset < 0 || minutesOffset > 59) {               throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);           }           int offset = 0;           try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);             if (hoursInMinutes < 0) {               minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);             }             else {               minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);             }             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) {             if (hoursOffset == 0 && minutesOffset == 0) {               return DateTimeZone.UTC;           }             if (minutesOffset < 0 || minutesOffset > 59) {               throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);           }           int offset = 0;           try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);             if (hoursInMinutes < 0) {               minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);             }             else {               minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);             }             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) {             if (hoursOffset == 0 && minutesOffset == 0) {               return DateTimeZone.UTC
public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;                  }             } else {
public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time, TimeZone zone) {          this(time, zone, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time, TimeZone zone, Locale locale) {          this(time, zone, zone, locale);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time, TimeZone zone, Locale locale) {          this(time, zone, zone, locale);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time, TimeZone zone, Locale locale) {          this(time, zone, zone, locale);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time, TimeZone zone) {          this(time, zone, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time, TimeZone zone, Locale locale) {          this(time, zone, zone, locale);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** Method call parameter value modification, Variable replacement by another variable,  **/       public Week(Date time,
private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator
public static String formatPeriod(long startMillis, long endMillis, String forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);         return forma;         }
private void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl = new Mean(value);           }         if (!(varianceImpl instanceof Variance)) {              varianceImpl = new Variance(value);           }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl = new GeometricMean(value);           }           n++;             }             public void setValue(double value) {           secondMoment.setValue(value);           if (!(meanImpl instanceof Mean)) {              meanImpl = new Mean(value);           }           if (!(varianceImpl instanceof Variance)) {              varianceImpl = new Variance(value);           }           if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl = new GeometricMean(value);           }           n++;             }             public double getValue() {           return secondMoment.getValue();           }             public void setValue(double value) {           secondMoment.setValue(value);           if (!(meanImpl instanceof Mean)) {              meanImpl = new Mean(value);           }           if (!(varianceImpl instanceof Variance)) {              varianceImpl = new Variance(value);           }           if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl = new GeometricMean(value);           }           n++;             }             public double getMean() {           return meanImpl.getValue();           }             public void setMean(double value) {           meanImpl.setValue(value);           if (!(meanImpl instanceof Mean)) {              meanImpl = new Mean(value);           }           if (!(varianceImpl instanceof Variance)) {              varianceImpl = new Variance(value);           }           if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl = new GeometricMean(value);           }           n++;             }             public double getVariance() {           return varianceImpl.getValue();           }             public void setVariance(double value) {           varianceImpl.setValue(value);           if (!(meanImpl instanceof Mean)) {              meanImpl = new Mean(value);           }           if (!(varianceImpl instanceof Variance)) {              varianceImpl = new Variance(value);           }           if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl
protected double doSolve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0;              }              return targetY;             }
public void setWeekOfMonth(final int weekOfMonth) {             setMillis(getChronology().weeks().add(getMillis(), weekOfMonth));           }             public void addWeeks(final int weeks) {             setMillis(getChronology().weeks().add(getMillis(), weeks));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void addWeeks(final int weeks) {           setMillis(getChronology().weeks().add(getMillis(), weeks));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().weeks().add(getMillis(), weekOfYear));           }             public void setWeekOfYear(final int weekOfYear) {           setMillis(getChronology().
protected VectorialPointValuePair doOptimize()                      if (s!= 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = 0;                      } else {                          double sum = 0;
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return maybeTypeOfThis;    }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant, String description) {         this(duration, endInstant, description);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant, String description, String category) {         this(duration, endInstant, description, category);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant, String description, String category, String description2) {         this(duration, endInstant, description, category, description2);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant, String description, String category, String description2, String description3) {         this(duration, endInstant, description, category, description2, description3);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant, String description, String category, String description2, String description3, String description4) {         this(duration, endInstant, description, category, description2, description3, description4);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant, String description, String category, String description2, String description3, String description4, String description5) {         this(duration, endInstant, description, category, description2, description3, description4, description5);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,           * @param duration  the duration, in milliseconds           */      protected BasePeriod(long duration, ReadableInstant endInstant
private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,           */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification,           */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification,           */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification,           */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in
private LegendItemCollection getLegendItems() {           LegendItemCollection result = new LegendItemCollection();           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);           if (dataset!= null) {               result.add(dataset.getLegendItem());           }           return result;           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int index) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int index, int seriesCount) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index, int seriesCount) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index, int seriesCount, int index) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index, int seriesCount, int index, int seriesCount) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index, int seriesCount, int index, int seriesCount) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index, int seriesCount, int index, int seriesCount) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int seriesCount, int index, int seriesCount, int index, int seriesCount) {           }             public void setLegendItems(LegendItemCollection legendItems) {           }             public void setLegendItems(LegendItemCollection legendItems, int series
private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }
private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5);           }             private double getExponentTerm(final double[] vals) {             return FastMath.pow(2 * FastMath.PI, -dim / 2) *
private int indexOf(String str, int startIndex) {              return -1;           }          char[] thisBuf = buffer;          int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {             char c = thisBuf[i + j];             if (c == str.charAt(j)) {               return i + j;             }             }           }           return -1;         }
Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {             Node name = IR.name("").useSourceInfoFrom(input);             value.replaceChild(input, name);             varNode = IR.var(name).useSourceInfoFrom(input);             grandparent.replaceChild(parent, varNode);           }           else {             value.detachFromParent();           }           staleInputs = true;         }         return staleInputs;       }
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       }             }             }             }             }             }             }             }             }             }             }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }
private static Object[] createComposite(List<Object> elementPairs) {          Object[] comp = new Object[elementPairs.size()];          for (int i = 0; i < elementPairs.size(); ++i) {              comp[i] = elementPairs.get(i);          }          return comp;          }           private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = new Object[elementPairs.size()];          for (int i = 0; i < elementPairs.size(); ++i) {              comp[i] = elementPairs.get(i);          }          return new PeriodFormatter(null, null);          }           private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = new Object[elementPairs.size()];          for (int i = 0; i < elementPairs.size(); ++i) {              comp[i] = elementPairs.get(i);          }          return new PeriodFormatter(null, null);          }           private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter
public static boolean isSameLocalTime(Node n1, Node n2) {          if (n1 == null || n2 == null) {            return false;          }          Node parent = n1.getParent();          if (parent == null) {            return false;          }          if (parent.getParent() == null) {            return false;          }          if (parent.getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent() == null) {            return false;          }          if (parent.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent() == null) {
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:            return true;        }
private double localMin(boolean isMinim,          double x) {             double fx = computeObjectiveValue(f, x);             if (goalType == GoalType.MAXIMIZE) {               fx = -fx;             }             double fv = fx;             double fw = fx;             int count = 0;             while (count < maximalIterationCount) {               double m = 0.5 * (a + b);               final double tol1 = eps * Math.abs(x) + t;               final double tol2 = 2 * tol1;               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, varNode.cloneNode(true));               varNode.replaceChild(varNode, var
private void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;             }
private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  vaultBaseUrl private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  vaultBaseUrl private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  vaultBaseUrl private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  vaultBaseUrl private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  vaultBaseUrl private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n
Node processInfixExpression(Node infixNode) {      Node newName = IR.name("").useSourceInfoFrom(existingName);      existingName.replaceChild(existingName.getParent(), newName);      return IR.assign(existingName).useSourceInfoFrom(existingName);    } else {      return existingName;    }
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;    }
public void applyAlias() {    private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      } }
protected void dropPhase2Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);             }          }          }           protected void dropPhase3Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);             }          }           protected void dropPhase4Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);             }          }           protected void dropPhase5Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);             }          }           protected void dropPhase6Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);             }          }           protected void dropPhase7Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);             }          }           protected void dropPhase8Objective() {
private Timer() { }  public void start() { }  public void stop() { }  public String toString() { return ""; } }
private void report(NodeTraversal t, Node name, Node value) {   if (value!= null) {     value.detachFromParent();   }   else {     if (value!= null) {       value.detachFromParent();     }   }   else {   if (value!= null) {       value.detachFromParent();   }   else {   if (value!= null) {       value.detachFromParent();   }   }
private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;    }
private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }            private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }            private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double real, double imaginary) {             return new Complex(real, imaginary);           }           private Complex createComplex(double
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);             if (comparator.compare(contracted, best) < 0) {                  return;             }             best = contracted;           }
public double[][] getCovariances(EstimationProblem problem) {         double[][] covariances = new double[problem.getAllParameters().length][problem.getMeasurements().length];         for (int i = 0; i < covariances.length; ++i) {             covariances[i] = new double[problem.getMeasurements().length];             for (int j = 0; j < problem.getMeasurements().length; ++j) {               covariances[i][j] = problem.getMeasurements()[j];             }             for (int j = 0; j < problem.getAllParameters().length; ++j) {               covariances[i][j] = problem.getAllParameters()[j];             }           }           return covariances;         }
private String formatMethodCall() {             return "unstubbed " + name + " method on mock";           }             private String name;             public String getName() {             return name;           }             private void setName(String name) {             this.name = name;           }           private String location;           public String getLocation() {           return location;           }           private void setLocation(String location) {           this.location = location;           }           private String description;           public String getDescription() {           return description;           }           private void setDescription(String description) {           this.description = description;           }           private String packageName;           public String getPackageName() {           return packageName;           }           private void setPackageName(String packageName) {           this.packageName = packageName;           }           private String className;           public String getClassName() {           return className;           }           private void setClassName(String className) {           this.className = className;           }           private String methodSignature;           public String getMethodSignature() {           return methodSignature;           }           private void setMethodSignature(String methodSignature) {           this.methodSignature = methodSignature;           }           private String signature;           public String getSignature() {           return signature;           }           private void setSignature(String signature) {           this.signature = signature;           }           private String superName;           public String getSuperName() {           return superName;           }           private void setSuperName(String superName) {           this.superName = superName;           }           private String[] interfaces;           public String[] getInterfaces() {           return interfaces;           }           private void setInterfaces(String[] interfaces) {           this.interfaces = interfaces;           }           private String[] superInterfaces;           public String[] getSuperInterfaces() {           return superInterfaces;           }           private int hashCode;           public int hashCode() {           return hashCode;           }           private boolean equals;           public boolean equals(Object obj) {           return equals;           }           private java.lang.Object __equalsCalc = null;           public synchronized boolean equals(java.lang.Object obj) {           if (__equalsCalc!= null) {           return (__equalsCalc == obj);           }           __equalsCalc = obj;           boolean _equals;           try {             _equals = super.equals(obj);           }           finally {             __equalsCalc = null;           }           return _
public static synchronized GJChronology getInstance(Instant cutoverInstant) {             return getInstance(cutoverInstant, DEFAULT_CUTOVER);           }             public static synchronized GJChronology getInstance(Instant cutoverInstant, GregorianCutover gregorianCutover) {             return new GJChronology(cutoverInstant, gregorianCutover);           }             private GJChronology(Instant cutoverInstant, GregorianCutover gregorianCutover) {             this.cutoverInstant = cutoverInstant;             this.gregorianCutover = gregorianCutover;           }             public Instant getCutoverInstant() {             return cutoverInstant;           }             public void setCutoverInstant(Instant cutoverInstant) {             this.cutoverInstant = cutoverInstant;           }             public GregorianCutover getGregorianCutover() {             return gregorianCutover;           }             public void setGregorianCutover(GregorianCutover gregorianCutover) {             this.gregorianCutover = gregorianCutover;           }             @Override public String toString() {             return "GJChronology{" + "cutoverInstant=" + cutoverInstant + ", gregorianCutover=" + gregorianCutover + '}';           }           @Override public int hashCode() {             return Objects.hash(cutoverInstant, gregorianCutover);           }           @Override public boolean equals(Object obj) {             if (this == obj) {             return true;           }             if (obj == null) {             return false;           }           if (getClass()!= obj.getClass()) {           return false;           }           GJChronology other = (GJChronology) obj;           return Objects.equals(this.cutoverInstant, other.cutoverInstant) && Objects.equals(this.gregorianCutover, other.gregorianCutover);         }
private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer<Object>() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }           });           return null;         } else {           return null;         }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {             if (iField!= null) {               iField.writeTo(out);             }             else {               out.writeObject(null);             }           } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {           iField.writeTo(out);           }           else {           out.writeObject(null);           }         } else {           if (iField!= null) {
private boolean evaluateStep(final StepInterpolator interpolator) {             boolean result = true;             if (parent!= null) {               parent.accept(this);             }             if (child!= null) {               child.accept(this);             }             return result;           } else {           return true;           }
private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (n.getJSType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);      }
private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);           }           private static int greatestCommonDivisor(int u, int v) {           if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;             }             return Math.max(u, v);
static void register(Object value) {         getRegistry().register(new IDKey(value));       }       static void unregister(Object value) {         getRegistry().unregister(new IDKey(value));       }       static void register(String value) {         getRegistry().register(new IDKey(value));       }       static void unregister(String value) {         getRegistry().unregister(new IDKey(value));       }       static void register(int value) {         getRegistry().register(new IDKey(value));       }       static void unregister(int value) {         getRegistry().unregister(new IDKey(value));       }       static void register(long value) {         getRegistry().register(new IDKey(value));       }       static void unregister(long value) {         getRegistry().unregister(new IDKey(value));       }       static void register(float value) {         getRegistry().register(new IDKey(value));       }       static void unregister(float value) {         getRegistry().unregister(new IDKey(value));       }       static void register(double value) {         getRegistry().register(new IDKey(value));       }       static void unregister(double value) {         getRegistry().unregister(new IDKey(value));       }       static void register(boolean value) {         getRegistry().register(new IDKey(value));       }       static void unregister(boolean value) {         getRegistry().unregister(new IDKey(value));       }       static void register(java.lang.String value) {         getRegistry().register(new IDKey(value));       }       static void unregister(java.lang.String value) {         getRegistry().unregister(new IDKey(value));       }       static void register(java.lang.Integer value) {         getRegistry().register(new IDKey(value));       }       static void unregister(java.lang.Integer value) {         getRegistry().unregister(new IDKey(value));       }       static void register(java.lang.Long value) {         getRegistry().register(new IDKey(value));       }       static void unregister(java.lang.Long value) {         getRegistry().unregister(new IDKey(value));       }       static void register(java.lang.Float value) {         getRegistry().register(new IDKey(value));       }       static void unregister(java.lang.Float value
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();      }
private String normalizeSourceName(String filename) {        StringBuilder sb = new StringBuilder();        if (filename!= null) {        sb.append(filename).append('\n');        }        return sb.toString();      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalizeSourceName(String filename) {        return filename;      }         private String normalize
private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Node> refs = referenceInfo.references;            for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();             Node newNameNode = IR.name("").useSourceInfoFrom(nameNode);             parent.replaceChild(parent, newNameNode);             varNode = IR.var(nameNode).useSourceInfoFrom(parent);             parent.replaceChild(parent, varNode);           }           else {             if (varNode!= null) {               parent.detachFromParent();             }           }           else {             if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else {           if (varNode!= null) {               parent.detachFromParent();           }           }           else
void addIdentifier(String identifier) {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             */             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.             } else {             * Constants (true, false, null) are considered basically free,             * because it's likely that they will get folded when we're done.
private void captureArgumentsFrom(Invocation invocation) {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                   if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVar
public static double cosh(double x) {        return Math.cos(x);            }       public static double tanh(double x) {        return Math.tan(x);            }       public static double asinh(double x) {        return Math.asin(x);            }       public static double acosh(double x) {        return Math.acosh(x);            }       public static double atanh(double x) {        return Math.atanh(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double y, double x) {        return Math.atan2(y, x);            }       public static double atan(double x) {        return Math.atan(x);            }       public static double atan2(double
static Double getNumberValue(Node n) {      return null;    }   static Double getStringNumberValue(String rawJsString) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getStringNumberValue(String rawJsString) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent) {      return null;    }   static Double getNumberValue(Node parent)
FunctionTypeBuilder inferFromOverriddenFunction(         }             parametersNode = paramBuilder.build();           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }           }           else {           }
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;             }             }             }             return null;           }           return null;         }
private void handleObjectLit(NodeTraversal t, Node n) {            Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             grandparent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '*' :                              out.write('\\');                          out.write('*');                          break;                      case '(' :                              out.write('\\');                          out.write('(');                          break;                      case ')' :                              out.write('\\');                          out.write(')');                          break;                      case '[' :                              out.write('\\');                          out.write('[');                          break;                      case ']' :                              out.write('\\');                          out.write(']');                          break;                      case '{' :                              out.write('\\');                          out.write('{');                          break;                      case '}' :                              out.write('\\');                          out.write('}');                          break;                      case '(' :                              out.write('\\');                          out.write('(');                          break;                      case ')' :                              out.write('\\');                          out.write(')');                          break;                      case '[' :                              out.write('\\');                          out.write('[');                          break;                      case ']' :                              out.write('\\');                          out.write(']');                          break;                      case '{' :                              out.write('\\');                          out.write('{');                          break;                      case '}' :                              out.write('\\');                          out.write('}');                          break;                  }
static void register(Object value) {         getRegistry().register(new IDKey(value));      }      static void unregister(Object value) {         getRegistry().unregister(new IDKey(value));      }      static Set<IDKey> getRegistry() {         return registry;      }      static void setRegistry(Set<IDKey> value) {         registry = value;      }      static void clearRegistry() {         registry = new HashSet<IDKey>();      }      static void register(IDKey key) {         getRegistry().add(key);      }      static void unregister(IDKey key) {         getRegistry().remove(key);      }      static void clearRegistry() {         getRegistry().clear();      }
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }             }
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType);           return false;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;           return true;
