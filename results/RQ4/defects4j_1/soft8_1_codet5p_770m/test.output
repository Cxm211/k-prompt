private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) {             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             builder.replaceChild(existingName, varNode);           }             return ExtractionInfo.empty();           }           return ExtractionInfo.empty();         }           return ExtractionInfo.empty();       } else {       return ExtractionInfo.empty();     }   } else {   return ExtractionInfo.empty();   }
public boolean isNoType() { return false; } public boolean isNoResolvedType() { return false; } public void accept(@NotNull PsiElementVisitor visitor) {   if (visitor instanceof JavaElementVisitor) {   ((JavaElementVisitor)visitor).visitType(this);   }   else {   super.accept(visitor);   } } public void accept(@NotNull PsiRecursiveElementVisitor visitor) {   if (visitor instanceof JavaElementVisitor) {   ((JavaElementVisitor)visitor).visitType(this);   }   else {   super.accept(visitor);   }   }
public void removeRow(int rowIndex) {           int index = getRowIndex(rowIndex);           removeRow(index);       } public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex);           setRow(index, value);       } public void setRow(int rowIndex, Object value, int columnIndex) {           int index = getRowIndex(rowIndex);           setRow(index, value, columnIndex);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex);           setRow(index, value);       } public void setRow(int rowIndex, Object value, int columnIndex, Object newValue) {           int index = getRowIndex(rowIndex);           setRow(index, value, columnIndex, newValue);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex);           setRow(index, value);       } public void setRow(int rowIndex, Object value, int columnIndex, Object newValue) {           int index = getRowIndex(rowIndex);           setRow(index, value, columnIndex, newValue);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex);           setRow(index, value);       } public void setRow(int rowIndex, Object value, int columnIndex) {           int index = getRowIndex(rowIndex);           setRow(index, value, columnIndex);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex);           setRow(index, value);       } public void setRow(int rowIndex, Object value, int columnIndex, Object newValue) {           int index = getRowIndex(rowIndex);           setRow(index, value, columnIndex, newValue);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex);           setRow(index, value);       } public void setRow(int rowIndex, Object value, int columnIndex, Object newValue) {           int index = getRowIndex(rowIndex);           setRow(index, value, columnIndex, newValue);       } public void setRow(int rowIndex, Object value) {           int index = getRowIndex(rowIndex
public void accept(@NotNull PsiElementVisitor visitor) {             if (visitor instanceof JavaElementVisitor) ((JavaElementVisitor)visitor).visitMethodCallExpression(this);           }             else {               super.accept(visitor);           }             else {               super.accept(visitor);           }             else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {               super.accept(visitor);           }           else {
public void apply(NodeTraversal t) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             grandparent.replaceChild(parent, varNode);           } else {           if (value!= null) {               value.detachFromParent();             }           varNode = parent;           }
private void renameNamespaceShadows(NodeTraversal t) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             grandparent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private double integrate(final FirstOrderDifferentialEquations equations,                    final boolean             loop     = false) {             double result = 0.0;             for (int i = 0; i < equations.size(); i++) {             if (equations.getValue(i)!= null) {             result += equations.getValue(i);             }             }             return result;             } else {             return 0.0;             }
private int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);             return bucket.parseInto(text, position);           }
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {             return true;             }             static boolean evaluatesToLocalValue
private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();       if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());       } else {             Node name = IR.name("").useSourceInfoFrom(constructor);             node.replaceChild(parent, name);           } else {             Node name = IR.name("").useSourceInfoFrom(constructor);             node.replaceChild(parent, name);           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;           } else {             Node name = parent;
private RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                      final double[] wi  = wData[i];                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];                          }                 }                          for (int j = 0; j < p; ++j) {                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];                          }                  for (int i = p; i < m; ++i) {                      wData[i] = new double[p];             }             return new RealMatrix(wData);             }             else {             return null;             }           } else {             return null;           }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else
private UnivariatePointValuePair best(UnivariatePointValuePair current, UnivariatePointValuePair previous, boolean isMinim) {             if (isMinim) {               return current;             }             else {               return previous;             }           }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           out.defaultWriteObject();           } else {           if (value!= null) {               value.writeTo(out);           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }
private void interpretAssigns() {                  var.replaceChild(assign.assignNode, value);               }             }             else {               if (value!= null) {               value.detachFromParent();             }             }           else {             if (value!= null) {             value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {           if (value!= null) {           value.detachFromParent();           }           }           else {
private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }       Node cArg = callNode.getFirstChild().getNext();         if (cArg!= null) {           Node parent = cArg.getParent();           if (parent!= null) {             parent.detachFromParent();           }           cArg.detachFromParent();         }         return CanInlineResult.noChange();       }     return CanInlineResult.noChange();   }
private void inlineAliases(GlobalNamespace namespace) {          }             private void inlineAliases(GlobalNamespace namespace) {           }             private void inlineAliases(GlobalNamespace namespace) {           }             private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inlineAliases(GlobalNamespace namespace) {           }           private void inline
public ElitisticListPopulation(final List<Chromosome> chromosomes, final double elitismRate) {          super(chromosomes);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,          */      public ElitisticListPopulation(final ElitisticListPopulation other) {          super(other);         this.elitismRate = other.elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final double elitismRate) {          super(other);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final int populationLimit) {          super(other);         this.elitismRate = other.elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final double elitismRate, final int populationLimit) {          super(other);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final double elitismRate) {          super(other);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final int populationLimit, final double elitismRate) {          super(other);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final int populationLimit, final double elitismRate, final int populationLimit) {          super(other);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition,             */      public ElitisticListPopulation(final ElitisticListPopulation other, final double elitismRate) {          super(other);         this.elitismRate = elitismRate;      }
public void setRangeAxisIndex(int index, ValueAxis axis) {           this.rangeAxes.set(index, axis);           } else {             if (this.rangeAxes!= null) {               this.rangeAxes.remove(this.rangeAxes.indexOf(axis));             }             this.rangeAxes = new ArrayList<ValueAxis>();           }
public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (final boolean b) branch addition,   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild() == null;           }   private static boolean isAllZeros(final Node n) {             return n!= null && n.isName() && n.getFirstChild() == null && n.getLastChild()
public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';');              }             }             else {             writer.write(entityName);             }           }           else {           writer.write(str);           }         }         else {           writer.write(str);         }         return this;     }     private String entityName(char c) {           return "";         }     }
private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();          if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);             }             else {             varNode = IR.var(name).useSourceInfoFrom(parent);             }           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {             varNode = parent;           }           else {
public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          } else {            setter.setValue(Boolean.parseBoolean(param));          }           return 0;        } else {           throw new CmdLineException("Invalid argument: " + param);        }
private double solve(final UnivariateRealFunction f, final double initial, final double yInitial, final double max, final double yMax, final double initial, final double yInitial) {             return Math.max(initial, Math.min(yInitial, yMax));           }
private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) && n.replaceChild(lhs, assignName);               return assignName;             } else {               return null;             }
public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  /***/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/ public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition,
public void replace(int start, int end, Object o) {             super.replace(start, end, o);           }             else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {             super.replace(start, end, null);           }           else {
private Fraction multiply(final int i) {             return new Fraction(value.multiply(i), fraction);           } else {             return new Fraction(value.divide(i), fraction);           } }
public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L;             }             return val1 * val2;           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }           else {             return val1;           }           }
private static <T> T[] copyArrayGrow1(T[] array, Class<T> type) {             T[] newArray = (T[]) Array.newInstance(type, array.length);             System.arraycopy(array, 0, newArray, 0, array.length);             return newArray;           }
public void setData(java.util.ArrayList value) {             this.data = value;           }           public java.util.ArrayList getData() {             return this.data;           }           public TimeSeries clone() {             TimeSeries result = (TimeSeries) super.clone();             result.data = new java.util.ArrayList(this.data);             return result;           }           public boolean equals(java.lang.Object obj) {           if (obj == this) {             return true;           }           if (!(obj instanceof TimeSeries)) {           return false;           }           TimeSeries other = (TimeSeries) obj;           if (this.data == null) {           if (other.data!= null) {             return false;           }           return true;           }           if (!this.data.equals(other.data)) {           return false;           }           return true;           }           public int hashCode() {           int result = super.hashCode();           if (this.data!= null) {           result = 31 * result + this.data.hashCode();           }           return result;           }           public java.lang.String toString() {           return (java.lang.String) null;           }           }
private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name("").useSourceInfoFrom(right);             right.replaceChild(right.getFirstChild(), newName);             return newName;           }           return right;         }     private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name("").useSourceInfoFrom(right);             right.replaceChild(right.getFirstChild(), newName);             return newName;           }           return right;         }     private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name("").useSourceInfoFrom(right);             right.replaceChild(right.getFirstChild(), newName);             return newName;           }           return right;         }     private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name("").useSourceInfoFrom(right);             right.replaceChild(right.getFirstChild(), newName);             return newName;           }           return right;         }     private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name("").useSourceInfoFrom(right);             right.replaceChild(right.getFirstChild(), newName);             return newName;           }           return right;         }     private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name("").useSourceInfoFrom(right);             right.replaceChild(right.getFirstChild(), newName);             return newName;           }           return right;         }     private Node tryFoldComparison(Node n, Node left, Node right) {            if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             Node newName = IR.name
private void unrollBinaryOperator(      Node current = firstNonOperator) {      Node newName = IR.name("").useSourceInfoFrom(existingName);      existingName.replaceChild(existingName.getParent(), newName);      varNode = IR.var(existingName).useSourceInfoFrom(existingName);      varNode.replaceChild(parent, varNode);      parent.replaceChild(child, varNode);    } else {      if (varNode!= null) {      varNode.detachFromParent();      }      if (parent!= null) {      parent.detachFromParent();    }
public long subtract(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.subtract(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          }             }             }             }             }             }             }             }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }           }
private long add(long instant, int value) {             return iField.add(instant, value);           } else {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.add(localInstant, value);             return iZone.convertLocalToUTC(localInstant, false);           }
public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos);             }             return new BigDecimal(dec);           }           else {             return new BigDecimal(str);           }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return new BigDecimal(str);         }         }         else {             return
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           super.writeTo(out);           out.writeObject(this.seriesKeys);           out.writeObject(this.categoryKeys);           }             private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           super.readFrom(in);           in.readObject(this.seriesKeys);           in.readObject(this.categoryKeys);           }             private static final long serialVersionUID = 1L;           private Comparable[] seriesKeys;           private Comparable[] categoryKeys;           public Comparable[] getSeriesKeys() {             return this.seriesKeys;           }           public Comparable[] getCategoryKeys() {             return this.categoryKeys;           }           public void setSeriesKeys(Comparable[] seriesKeys) {             this.seriesKeys = seriesKeys;           }           public void setCategoryKeys(Comparable[] categoryKeys) {             this.categoryKeys = categoryKeys;           }           public String toString() {             return "DefaultIntervalCategoryDataset";           }           public boolean equals(java.lang.Object obj) {           if (obj == this) {           return true;           }           if (!(obj instanceof DefaultIntervalCategoryDataset)) {           return false;           }           DefaultIntervalCategoryDataset other = (DefaultIntervalCategoryDataset) obj;           if (this.seriesKeys == null) {           if (other.seriesKeys!= null) {           return false;           }           return true;           }           if (!this.seriesKeys.equals(other.seriesKeys)) {           return false;           }           if (this.categoryKeys == null) {           if (other.categoryKeys!= null) {           return false;           }           return true;           }           public int hashCode() {           if (this.seriesKeys == null) {           return 0;           }           return this.seriesKeys.hashCode() + (this.categoryKeys == null? 0 : this.categoryKeys.hashCode());           }           public java.lang.Object readResolve() {           return this;           }           public void writeTo(java.io.ObjectOutputStream out) throws java.io.IOException {           super.writeTo(out);           out.writeObject(this.seriesKeys);           out.writeObject(this.categoryKeys);           }             private static final long serialVersionUID =
private boolean isInlinableObject(List<Reference> refs) {             return false;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {             return true;           }           else {
private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns) {             for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet())             {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());             if (type.equals(fromTypeArg))             {             return true;             }             else             {             return false;             }             }             else             {             return true;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;             }             else             {             return false;
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }             return DateTimeZone.forOffsetHoursMinutes(offset, minutesOffset);           }             catch (IllegalArgumentException e) {             }             return DateTimeZone.UTC;           }             public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }             return DateTimeZone.forOffsetHoursMinutes(offset, minutesOffset);           }             catch (IllegalArgumentException e) {             }             return DateTimeZone.UTC;           }             public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }             return DateTimeZone.forOffsetHoursMinutes(offset, minutesOffset);           }             catch (IllegalArgumentException e) {             }             return DateTimeZone.UTC;           }             public static DateTimeZone forOffsetHoursMinutes(int hoursOffset,
protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);             }             else {                  setSize(0.0);                  setBarycenter(Vector2D.ZERO);             }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute()) {           }           else {           }           }           else {           if ((Boolean) v[0].getAttribute
private static synchronized String getConvertedId(String id) {            if (id == null || "".equals(id)) {               return null;             }             if ("GMT".equals(id)) {               return "UTC";             }             if ("MIT".equals(id)) {               return "Pacific/Apia";             }             if ("HST".equals(id)) {               return "Pacific/Honolulu";             }             if ("AST".equals(id)) {               return "America/Anchorage";           }           return id;           }             private static synchronized String getConvertedId(String id, Locale locale) {           if (id == null || "".equals(id)) {               return null;           }           if ("GMT".equals(id)) {           return "UTC";           }           if ("MIT".equals(id)) {           return "Pacific/Apia";           }           if ("HST".equals(id)) {           return "Pacific/Honolulu";           }           if ("AST".equals(id)) {           return "America/Anchorage";           }           return id;           }             private static synchronized String getConvertedId(String id, String language) {           if (id == null || "".equals(id)) {               return null;           }           if ("GMT".equals(id)) {           return "UTC";           }           if ("MIT".equals(id)) {           return "Pacific/Apia";           }           if ("HST".equals(id)) {           return "Pacific/Honolulu";           }           if ("AST".equals(id)) {           return "America/Anchorage";           }           return id;           }             private static synchronized String getConvertedId(String id, String country) {           if (id == null || "".equals(id)) {               return null;           }           if ("GMT".equals(id)) {           return "UTC";           }           if ("MIT".equals(id)) {           return "Pacific/Apia";           }           if ("HST".equals(id)) {           return "Pacific/Honolulu";           }           if ("AST".equals(id)) {           return "America/Anchorage";           }           return id;           }             private static synchronized String get
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          }        }        return true;      } public static boolean isJSIdentifier(String s, int start) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(start))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          }        }        return true;      } public static boolean isJSIdentifier(String s, int start, int end) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(start))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          }        }        return true;      } public static boolean isJSIdentifier(String s, int start, int end, int substart) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(start))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          }        }        return true;      } public static boolean isJSIdentifier(String s, int start, int end, int substart, int subend) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(start))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {
protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          }                         }                         return null;                   } else {                   return null;                 }
private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          Node newName = IR.name("").useSourceInfoFrom(name);          parent.replaceChild(parent, newName);          ret = true;        }        return ret;      }
void tryMinimizeExits(Node n, int exitType, String labelName) {         if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);         }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           tryMinimizeExits(finallyBlock, exitType, labelName);           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();           }       } else {           if (NodeUtil.hasFinally(n)) {           Node finallyBlock = n.getLastChild();
public void setHourOfHour(final int hourOfHour) {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(getMillis(), hourOfHour));           } else {             setMillis(getChronology().hours().add(get
private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);              }              }             return injectionOccurred;           }
public void setExtraInterfaces(java.util.Collection<? extends java.lang.Class> extraInterfaces) {          this.extraInterfaces = extraInterfaces;       }       public java.util.Collection<? extends java.lang.Class> getExtraInterfaces() {          return this.extraInterfaces;       }       public void setReturnValue(java.lang.Object returnValue) {          this.returnValue = returnValue;       }       public java.lang.Object getReturnValue() {          return this.returnValue;       }       public void setThrown(java.lang.Throwable thrown) {          this.thrown = thrown;       }       public java.lang.Throwable getThrown() {          return this.thrown;       }   }
protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                       }                  }                  return null;             }
public void setUnitMillis(long value) {             this.unitMillis = value;           }             public long getUnitMillis() {             return this.unitMillis;           }           public void setUnitMillis(java.lang.Long value) {             this.unitMillis = value;           }           public java.lang.Long getValue() {             return this.unitMillis;           }           public void setValue(java.lang.Long value) {             this.unitMillis = value;           }           public boolean equals(java.lang.Object obj) {           if (obj == this) {             return true;           }           if (!(obj instanceof com.google.protobuf.DurationField)) {           return super.equals(obj);           }           com.google.protobuf.DurationField other = (com.google.protobuf.DurationField) obj;           if (!other.isValid()) {           return false;           }           if (this.equals(other)) {           return true;           }           return super.equals(obj);         }           public int hashCode() {           if (memoizedHashCode!= 0) {           return memoizedHashCode;           }           int hash = 41;           if (isValid()) {           hash = hash * 59 + this.isValid();           }           memoizedHashCode = hash;           return hash;         }           public java.lang.String toString() {           if (memoizedToString!= null) {           return memoizedToString;           }           return super.toString();         }           public java.lang.Object readResolve() {           return fromValue(unitMillis);         }           public static com.google.protobuf.DurationField parseFrom(java.nio.ByteBuffer data) {           return com.google.protobuf.DurationField.parseFrom(data);         }           public static com.google.protobuf.DurationField parseFrom(                java.nio.ByteBuffer data,                com.google.protobuf.ExtensionRegistryLite extensionRegistry) {           return com.google.protobuf.DurationField.parseFrom(data, extensionRegistry);         }           public static com.google.protobuf.DurationField parseFrom(                com.google.protobuf.ByteString data) {           return com.google.protobuf.DurationField.parseFrom(data);         }           public static com.google.protobuf.DurationField parseFrom(
private Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));          return v2D;           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null;           }           } else {             return null
private boolean canInline(          }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }             }
public boolean setPrototype(Node prototype) {        return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor();             Node newPrototype = IR.name("").useSourceInfoFrom(parent);             parent.replaceChild(parent, newPrototype);             varNode = IR.var(parent).useSourceInfoFrom(parent);             parent.replaceChild(parent, varNode);             return true;           } else {             return false;           }
public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);   }   public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(finallyBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);   }   public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);     return new Node(Token.TRY, tryBody, catchBody);   }   public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(finallyBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);   }   public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);     return new Node(Token.TRY, tryBody, catchBody);   }   public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(finallyBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);   }   public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);     return new Node(Token.TRY, try
private double[] decode(final double[] x) {             final double[] y = new double[x.length];             System.arraycopy(x, 0, y, 0, x.length);             return             y;           }
private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod; private volatile int iPeriod;
public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, true);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/      public static void escapeJava(Writer out, String str, boolean b) throws IOException {         escapeJavaStyleString(out, str, b);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/      public static void escapeJava(Writer out, String str, boolean b, boolean b1) throws IOException {         escapeJavaStyleString(out, str, b, b1);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/      public static void escapeJava(Writer out, String str, boolean b, boolean b1, boolean b2) throws IOException {         escapeJavaStyleString(out, str, b, b1, b2);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/      public static void escapeJava(Writer out, String str, boolean b, boolean b1, boolean b2, boolean b3) throws IOException {         escapeJavaStyleString(out, str, b, b1, b2, b3);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/      public static void escapeJava(Writer out, String str, boolean b, boolean b1, boolean b2, boolean b3, boolean b4) throws IOException {         escapeJavaStyleString(out, str, b, b1, b2, b3, b4);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/      public static void escapeJava(Writer out, String str, boolean b, boolean b1, boolean b2, boolean b3, boolean b4, boolean b5) throws IOException {         escapeJavaStyleString(out, str, b, b1, b2, b3, b4, b5);
void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } else {         return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return;      } else {             return
public static double cosh(double x) {         return Math.cosh(x);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y) {         return Math.cosh(x, y);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z) {         return Math.cosh(x, y, z);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z, double w) {         return Math.cosh(x, y, z, w);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z, double w, double x2) {         return Math.cosh(x, y, z, w, x2);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z, double w, double x2, double y2) {         return Math.cosh(x, y, z, w, x2, y2);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z, double w, double x2, double y2, double z2) {         return Math.cosh(x, y, z, w, x2, y2, z2);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z, double w, double x2, double y2, double z2, double w2) {         return Math.cosh(x, y, z, w, x2, y2, z2, w2);       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x, double y, double z, double w, double x2, double y2, double z2, double w2, double x3) {         return Math.cosh(
private void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } private void noMoreInteractionsWantedInOrder(MockInvocation undesired) {          throw new
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           out.writeObject(value);           } else {           if (value!= null) {               value.writeTo(out);           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();           }           } else {           if (value!= null) {               value.deleteFromParent();
void apply() {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();       this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());           }
private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             public void addHours(final int hours) {             setMillis(getChronology().hours().add(getMillis(), hours));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             public void addHours(final int hours) {             setMillis(getChronology().hours().add(getMillis(), hours));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));           }             private void setHour
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info) {             varNode = IR.var(qName).useSourceInfoFrom(existingName);             existingName.replaceChild(existingName, varNode);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             existingName.replaceChild(existingName, varNode);           } else {             if (existingName!= null) {               existingName.detachFromParent();             }             if (varNode!= null) {               varNode.detachFromParent();             }           }
