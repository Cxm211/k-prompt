private int translate(CharSequence input, int index, Writer out) throws IOExcepti {             out.write(entityValue);             return 2 + (end - start) + (isHex? 1 : 0) + 1;             } else {                 return 0;             }             } else {                 return 1;             }           } else {                 return 0;             }           } else {                 return 1;             }           } else {                 return 0;             }           } else {                 return 1;             }           } else {                 return 0;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           } else {                 return 1;             }           }
private final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                     break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0
! "#$%&'()*+,-./ public static boolean isPrimitiveWrapper(Class<?> type) {          return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0L);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0F);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }   public static boolean isPrimitiveWrapper(Class<?> type) {           return primitiveValues.put(type, 0);           }
private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit, elitismRate);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call, ProvisionedProducted private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit, elitismRate);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call, ProvisionedProducted private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit, elitismRate);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call, ProvisionedProducted private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit, elitismRate);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call, ProvisionedProducted private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit, elitismRate);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call, ProvisionedProducted private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit, elitismRate);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call, ProvisionedProducted private ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate
private boolean safelyMatches(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return StringDescription.toString(m);       }   private String toString(Matcher m) {          return
private long addWrapField(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.addWrapField(localInstant, value);              return iZone.convertLocalToUTC(localInstant, false);              }          }          public long remove(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.remove(localInstant);              long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to time zone offset transition: " + Method call parameter addition, Method call replacement, Return expression modification, ProvisionedProduct private long removeWrapField(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.remove(localInstant);              return iZone.convertLocalToUTC(localInstant, false);              }          }
private void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              buf.append(value);             } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }             if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix.printTo(buf, value);             }           } else {               if (iPrefix!= null) {                 iPrefix
private static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);             if (hoursInMinutes < 0) {                 hoursInMinutes = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);             }             int minutesOffset = FieldUtils.safeAdd(minutesOffset, minutesOffset);             return DateTimeZone.forOffsetHoursMinutes(hoursInMinutes, minutesOffset);           } else {             return DateTimeZone.forOffsetHoursMinutes(0, 0);           }
private static Number createNumber(String str) throws NumberFormatException {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition;             }           return mant;             } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           } else {           return null;             }           }
! "#$%&'()*+,-./ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       public Week(Date time, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, locale);       }       public Week(Date time, TimeZone zone, String name) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, name);       }       public Week(Date time, Locale locale, String name, Object value) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, name, value);       }       public Week(Date time, TimeZone zone, String name, Object value, boolean writable) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, name, value, writable);       }       public Week(Date time, TimeZone zone, String name, Object value, boolean writable, boolean configurable) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, name, value, writable, configurable);       }       public Week(Date time, TimeZone zone, String name, Object value) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, name);       }       public Week(Date time, TimeZone zone, String name) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       public Week(Date time, TimeZone zone, String name, Object value, boolean writable, boolean configurable, boolean nullable) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, name, value, writable, configurable, nullable);       }       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       public Week(Date time, TimeZone zone, String name) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       public Week(Date time, TimeZone zone, String name, Object value) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       public Week(Date time, TimeZone zone, String name, Object value, boolean writable, boolean configurable, boolean nullable
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    }    static double getSimpleNumber(String s) {             int len = s.length();             for (int index = 0; index < len; index++) {             char c = s.charAt(index);             if (c < '0' || c > '9') {               return false;             }             }             return s.length() > 0? s.charAt(0) : '0';           }
private static String formatPeriod(long startMillis, long endMillis, String forma) {             if (startMillis < 0) {             startMillis += 31;             }             if (endMillis < 0) {             endMillis += 12;             }             return forma;           } else {             return formatPeriod(startMillis, endMillis, "");           }
private void addValue(double value) {          secondMoment.addValue(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.addValue(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.addValue(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.addValue(value);          }          n++;             } else {             if (value!= 0.0) {               secondMoment.setValue(value);             }             if (meanImpl!= null) {               meanImpl.dispose();             }             if (varianceImpl!= null) {               varianceImpl.dispose();             }             if (geoMeanImpl!= null) {               geoMeanImpl.dispose();             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           } else {             if (value!= 0.0) {               secondMoment.setValue(0.0);             }           }
private double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression modification, Variable removal, private double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression removal, private double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression removal, private double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression removal, private double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression removal, private double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression removal, private double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0; Assignment expression removal, private double target
private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition, ProvisionedProduct private void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */       public void addWeeks(final int weeks) {              set
private VectorialPointValuePair doOptimize()             if (s!= 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             }             return new VectorialPointValuePair(maxCosine);           }
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;    }      private static JSType safeResolve(JSType type, ErrorReporter t, StaticScope<JSType> scope) {       if (type == null) {         return null;       }       if (scope == null) {         return null;       }       if (type instanceof JSType) {         return (JSType) type;       }       if (type instanceof JSTypeArray) {         return (JSTypeArray) type;       }       if (type instanceof JSTypeObject) {         return (JSTypeObject) type;       }       if (type instanceof JSTypeString) {         return (JSTypeString) type;       }       if (type instanceof JSTypeNumber) {         return (JSTypeNumber) type;       }       if (type instanceof JSTypeBoolean) {         return (JSTypeBoolean) type;       }       if (type instanceof JSTypeObjectArray) {         return (JSTypeObjectArray) type;       }       if (type instanceof JSTypeStringArray) {         return (JSTypeStringArray) type;       }       if (type instanceof JSTypeNumberArray) {         return (JSTypeNumberArray) type;       }       if (type instanceof JSTypeBooleanArray) {         return (JSTypeBooleanArray) type;       }       if (type instanceof JSTypeObject) {         return (JSTypeObject) type;       }       if (type instanceof JSTypeString) {         return (JSTypeString) type;       }       if (type instanceof JSTypeNumber) {         return (JSTypeNumber) type;       }       if (type instanceof JSTypeBoolean) {         return (JSTypeBoolean) type;       }       if (type instanceof JSTypeObject) {         return (JSTypeObject) type;       }       if (type instanceof JSTypeString) {         return (JSTypeString) type;       }       if (type instanceof JSTypeNumber)
private BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       @param duration  the duration, in milliseconds       */       protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {         this(duration, endInstant, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition, ProvisionedProduct private BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {
private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable modification,             */
!="#$%&'()*+,-./            public LegendItemCollection getLegendItems() {               return result;           }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);           if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount();             if (seriesCount!= 0)             {               return result;           }           return null;             }
private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(input);              }          }      private final void translate(CharSequence
!="#$%&'()*+,-./             public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 1.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 1.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification, sessionIDArg!="#$%&'()*
private int indexOf(String str, int startIndex) {             return thisBuf.indexOf(str, startIndex);          }             char[] thisBuf2 = buffer;             int len2 = thisBuf2.length - strLen2;          outer:             for (int i = startIndex; i < len; i++) {               for (int j = 0; j < strLen2; j++) {                 if (thisBuf2.charAt(i)!= str) {                     return -1;                 }                 }             return 0;           }             return 1;           }             return 0;           }             return 1;           }             return 0;           }             return 1;           }             return 0;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }             return 1;           }
!$%&'()*+,-./  Node parseInputs(Node parent) {     boolean staleInputs = false;       if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {             if (parent.equals(input)) {               staleInputs = true;               return input;             }           }             if (parent!= null) {               return parent;           }             return null;           } else {             if (staleInputs) {               return null;           }             return inputs;           }
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition, 	         private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition, 	         private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition, 	         private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition, 	         private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition, 	         private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition, 	         private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           )             );       } Method call parameter addition, Method call replacement addition, Method definition addition, Parameter in method definition addition, Object instantiation addition, Return expression modification, Variable addition,
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no, boolean notPrinter) {              PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notPrinter);                  f = f.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (if) branch addition, ResolverRule private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no, boolean notPrinter) {              PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notPrinter);                  f = f.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          return new PeriodFormatter(sep, sep);        }          private static Object[] createComposite(List<Object> elementPairs) {             Object[] comp = new Object[elementPairs.size()];             for (int i = 0; i < elementPairs.size(); i++) {                 comp[i] = elementPairs.get(i);             }             return comp;         }     } }
private static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.ERA) &&             methodCallParameterValueModification == cal2.get(Calendar.ERA) &&             returnExpressionModification == cal2.get(Calendar.ERA) &&             variableReplacementByOtherVariable == cal2.get(Calendar.ERA) &&             isSameLocalTime(cal1, cal2) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocalTime(cal1, cal1) &&             isSameLocal
!("#$%&'()*+,-./  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {     if (value == null) {       return false;     }     if (!locals.test(value)) {       return false;     }     return true;   }    @Override   public void accept(NodeVisitor visitor) {     if (visitor instanceof NodeVisitor) {       ((NodeVisitor) visitor).visit(this);     } else {       super.accept(visitor);     }   }    @Override   public String toString() {     return toStringHelper(this)        .add("value", value)        .add("locals", locals)        .toString();   } }
private double localMin(boolean isMinim,          double w = x,          double d = 0,          double e = 0) {              double fx = computeObjectiveValue(f, x);              if (goalType == GoalType.MAXIMIZE) {              fx = -fx;              }              double fv = fx;              double fw = fx;              int count = 0;              while (count < maximalIterationCount) {                double m = 0.5 * (a + b);                final double tol1 = eps * Math.abs(x) + t;                final double tol2 = 2 * tol1;                if (goalType == GoalType.MAXIMIZE) {                  fx = -fx;                  }                  double fv = fx;                  double fw = fx;                  int count2 = 0;                  while (count2 < maximalIterationCount) {                    double m = 0.5 * (a + b);                    final double tol1 = eps * Math.abs(x) + t;                    final double tol2 = 2 * tol1;                    if (goalType == GoalType.MAXIMIZE) {                      fx = -fx;                      }                      double fv = fx;                      double fw = fx;                      int count3 = 0;                      while (count3 < maximalIterationCount) {                        double m = 0.5 * (a + b);                        final double tol1 = eps * Math.abs(x) + t;                        final double tol2 = 2 * tol1;                        if (goalType == GoalType.MAXIMIZE) {                      fx = -fx;                      }                      double fv = fx;                      double fw = fx;                      int count4 = 0;                      while (count4 < maximalIterationCount) {                        double m = 0.5 * (a + b);                        final double tol1 = eps * Math.abs(x) + t;                        final double tol2 = 2 * tol1;                        if (goalType == GoalType.MAXIMIZE) {                      fx = -fx;                      }                      double fv = fx;                      double fw = fx;                      int count5 = 0;                      while (count5 < maximalIterationCount) {                        double m = 0.5 * (a + b);                        final double tol1 = eps * Math.abs(x) + t;                        final double tol2 =
private void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.VAR:                case Token.LVAR:                  isSet = true;                  type = Name.Type.VAR;                  break;                case Token.MVAR:                case Token.MLVAR:                  isSet = true;                  type = Name.Type.MVAR;                  break;                case Token.LVAL:                case Token.LVAL:                  isSet = true;                  type = Name.Type.LVAL;                  break;                case Token.MVAL:                case Token.MMVAL:                  isSet = true;                  type = Name.Type.MMVAL;                  break;                case Token.GT:                case Token.GT:                  isSet = true;                  type = Name.Type.GT;                  break;                case Token.GE:                case Token.GE:                  isSet = true;                  type = Name.Type.GE;                  break;                case Token.LE:                case Token.LE:                  isSet = true;                  type = Name.Type.LE;                  break;                case Token.LT:                case Token.LT:                  isSet = true;                  type = Name.Type.LT;                  break;                case Token.EQ:                case Token.EQ:                  isSet = true;                  type = Name.Type.EQ;                  break;                case Token.NE:                case Token.NE:                  isSet = true;                  type = Name.Type.NE;                  break;                case Token.XOR:                case Token.XOR:                  isSet = true;                  type = Name.Type.XOR;                  break;                case Token.AND:                case Token.AND:                  isSet = true;                  type = Name.Type.AND;                  break;                case Token.OR:                case Token.OR:                  isSet = true;                  type = Name.Type.OR;                  break;                case Token.XOR:                case Token.AND:                  isSet = true;                  type = Name.Type.XOR;                  break;                case Token.XOR:                case Token.AND:                  isSet = true;                  type = Name.Type.XOR;                  break;                case Token.XOR:                case Token.AND:                  isSet = true;                  type = Name.
private boolean isPrototypePropertyAssign(Node assign) {             Node n = assign.getFirstChild();             if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {               boolean isChainedProperty =               n.getFirstChild().getType() == Token.GETPROP;               return isChainedProperty;             }             return super.isPrototypePropertyAssign(assign);           } else {             return false;           }           } else {             return false;           }           } else {             return false;           }           } else {             return false;           }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           } else {           return false;         }           }
!("#$%&'()*+,-./             Node processArrayLiteral(ArrayLiteral literalNode) {             Node assign = processInfixExpression(assignmentNode);             return assign;           } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             } else {             return null;           }             }
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      Node left = callTarget.getFirstChild();      if (left!= null) {       if (!NodeUtil.isImmutableValue(left)) {          return n;      }      Node parent = callTarget.getParent();      if (parent!= null) {       if (!NodeUtil.isImmutableValue(parent)) {          return n;      }      Node child = parent;       if (child!= null) {       if (!NodeUtil.isImmutableValue(child)) {          return n;      }   } else {       if (parent!= null) {       if (!NodeUtil.isImmutableValue(this)) {          return n;      }   return parent;      }   } else {       if (parent!= null) {       if (!NodeUtil.isImmutableValue(this)) {          return n;      }   return child;      }   } else {       if (parent!= null) {       if (!NodeUtil.isImmutableValue(this)) {          return n;      }   return this;      }   } else {       if (parent!= null) {       if (!NodeUtil.isImmutableValue(this)) {          return n;      }   return this;      }   }
private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition, 	         private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition, 	         private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition, 	         private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition, 	         	         private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode
protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable, Pharmacy1Objective protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable, Pharmacy1Objective protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable, Pharmacy1Objective protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable, Pharmacy1Objective protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable, Pharmacy1Objective protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions();
!("#$%&'()*+,-./             package org.mockito.internal.util;             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer { Conditional (if) branch added, Method call added, Method definition added, Object instantiation added,             public class Timer
private boolean shouldReportThis(Node n, Node parent) { return shouldReportThis(n, parent); } */
private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;    }      private Node reportTypeSyntaxWarning(String message) {       return new Error(message);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }      private Node reportTypeSyntaxWarning(String message, Object... args) {       return new Error(message, args);     }
private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real.getReal() == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(double real, double imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(double real, double imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex(real == 0? real : real.getReal(),             real.getImaginary() == 0? imaginary : imaginary.getImaginary());      }      private Complex createComplex(Complex real, Complex imaginary) {          return new Complex
private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition, ProvisionedProduct private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition, ProvisionedProduct private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition, ProvisionedProduct private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition, ProvisionedProduct private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition, ProvisionedProduct private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition, ProvisionedProduct private void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final Real
!("#$%&'()*+,-./            public double getChiSquare(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(m), new Integer(p)});          }          double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) {             AssignmentExpression modification, Method call replacement;             if (i < errors.length - 1) {                               var = covar[i];             }             else {                               var = null;             }             errors[i] = modification;           }             return errors;           }
private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification, ResolverRule private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification, ResolverRule private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification, ResolverRule private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification, ResolverRule private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification, ResolverRule private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification, ResolverRule private Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed "
private static final GJChronology DEFAULT_CUTOVER = new GJChronology("#$%&'()*+,-./", gregorianCutoverInstant);             return DEFAULT_CUTOVER;           } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             } else {             return gregorianCutover;           }             }
private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type modification, Variable modifier change, Variable type change,             private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type modification, Variable modifier change, Variable type change,             private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type modification, Variable modifier change, Variable type change,             private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type modification, Variable modifier change, Variable type change,             private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type modification, Variable modifier change, Variable type change,             private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {             return container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation)
!="#$%&'()*+,-./             public long roundFloor(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public long roundFloor(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public long roundFloor(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public long roundFloor(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public long roundFloor(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification, sessionIDArg!="#$%&'()*+,-./             public long roundFloor(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(
private boolean evaluateStep(final StepInterpolator interpolator)             {             return interpolator.evaluateStep(this);             }             else {             return super.evaluateStep(interpolator);             }           } else {             if (value!= null) {               value.release();             }             return this;           }
private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType()!= null && parent.isAssign()) {       return;     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n); Conditional (if or else) branch removal, Method call removal, Return statement removal,  optParams private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType()!= null && parent.isAssign()) {       return;     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n); Conditional (if or else) branch removal, Method call removal, Return statement removal,  optParams private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType()!= null && parent.isAssign()) {       return;     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n); Conditional (if or else) branch removal, Method call removal, Return statement removal,  optParams private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType()!= null && parent.isAssign()) {       return;
private static int greatestCommonDivisor(int u, int v) {             if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {               return 1;           }             return greatestCommonDivisor(u, v);           }
static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification, Variable modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition modification, Object instantiation modification, Return expression modification */     static void register(Object value) {         getRegistry().put
private OriginalMapping getOriginalMappingForEntry(Entry entry) {          Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn())        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }             return x.build();           }
private void visit(NodeTraversal t, Node n, Node parent) {             if (scriptNodeCount == 0) {               scriptNodeCount = 1;               node.replaceChild(parent, n);             }           else if (scriptNodeCount == 1) {               node.removeChild(parent);             }           else if (scriptNodeCount == 2) {               node.replaceChild(parent, scriptNodeCount - 1);             }           else if (scriptNodeCount == 3) {               node.removeChild(parent);             }           else if (scriptNodeCount == 4) {               node.removeChild(parent);             }           else if (scriptNodeCount == 5) {               node.removeChild(parent);             }           else if (scriptNodeCount == 6) {               node.removeChild(parent);             }           else if (scriptNodeCount == 7) {               node.removeChild(parent);             }           else if (scriptNodeCount == 8) {               node.removeChild(parent);             }           else if (scriptNodeCount == 9) {               node.removeChild(parent);             }           else if (scriptNodeCount == 10) {               node.removeChild(parent);             }           else if (scriptNodeCount == 11) {               node.removeChild(parent);             }           else if (scriptNodeCount == 12) {               node.removeChild(parent);             }           else if (scriptNodeCount == 13) {               node.removeChild(parent);             }           else if (scriptNodeCount == 14) {               node.removeChild(parent);             }           else if (scriptNodeCount == 15) {               node.removeChild(parent);             }           else if (scriptNodeCount == 16) {               node.removeChild(parent);             }           else if (scriptNodeCount == 17) {               node.removeChild(parent);             }           else if (scriptNodeCount == 18) {               node.removeChild(parent);             }           else if (scriptNodeCount == 19) {               node.removeChild(parent);             }           else if (scriptNodeCount == 20) {               node.removeChild(parent);             }           else if (scriptNodeCount == 21) {               node.removeChild(parent);             }           else if (scriptNodeCount == 22) {               node.removeChild(parent);
private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();             if (nameNode!= null) {               nameNode.replaceChild(parent, nameNode);             }             parent = parent.removeChild(parent, nameNode);           }           else {             if (parent!= null) {               parent.removeChild(parent);             }           }           else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild(this);             }           }         else {             if (parent!= null) {               parent.removeChild
!="#$%&'()*+,-./  void addIdentifier(String identifier) {       * Constants (true, false, null) are considered basically free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private void addIdentifier(String identifier) {       * Constants (true, false, null) are considered really free,       * because it will get folded.       */       }  private
private void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          else {             if (matchers.size() == 0) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class) instanceof CapturesArguments) {                 ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                 }                 else {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null) {                 if (invocation.getArgumentAt(position, Object.class)!= null
private static double sinh(double x) {            if (x > 20) {                return 0.5 * sinh(x);            }       if (x < -20) {                return -0.5 * sinh(x);        }        if (x == 0) {             return 0.0;           }             return 1.0;           }             return 0.0;           }             return 1.0;           }             return 0.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }             return 1.0;           }
static Double getStringNumberValue(Node n) {             String s = trimJsWhiteSpace(rawJsString);             if (n!= null) {                 node.setValue(s);             }             return value;           } else {             if (value!= null) {                 value.detachFromParent();             }             return null;           }
private FunctionTypeBuilder inferFromOverriddenFunction(        Node parametersNode = paramBuilder.build() )             {             if ( parametersNode!= null )             {                 parametersNode.detachFromParent();             }             varNode = parent.addChildFromParent( parent, varNode );             return varNode;           } else {             if ( parent!= null )             {                 parent.removeChildFromParent( parent );             }             return parent;           }
private Integer getPivotRow(final int col, final SimplexTableau tableau) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification, Privileged private Integer getPivotRow(final int col, final SimplexTableau tableau) {              final double rhs2 = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry2 = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry2, 0, epsilon) >= 0) {                  final double ratio2 = rhs2 / entry2;                  if (ratio2 < minRatio) {                      minRatio = ratio2; Conditional expression modification, Privileged private Integer getPivotRow(final int col, final SimplexTableau tableau) {              final double rhs3 = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry3 = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry3, 0, epsilon) >= 0) {                  final double ratio3 = rhs3 / entry3;                  if (ratio3 < minRatio) {                      minRatio = ratio3; Conditional expression modification, Privileged private Integer getPivotRow(final int col, final SimplexTableau tableau) {              final double rhs4 = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry4 = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry4, 0, epsilon) >= 0) {                  final double ratio4 = rhs4 / entry4;                  if (ratio4 < minRatio) {                      minRatio = ratio4; Conditional expression modification, Privileged private Integer getPivotRow(final int col, final SimplexTableau tableau) {              final double rhs5 = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry5 = tableau.getEntry(i, col);             if (Math
private void handleObjectLit(NodeTraversal t, Node n) {             String name = child.getString();             child = child.getNext();             if (name!= null) {                 node.replaceChild(name, child);             }             else {             node.removeChild(child);             }           } else {             if (value!= null) {               value.detachFromParent();             }           } else {             if (parent!= null) {               parent.removeChild(this);             }           }
private static void escapeJavaStyleString(Writer out, String str, boolean escape) {                          out.write('"');                          out.write(str);                          out.write('"');                          if (escape) {                             out.write('"');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.write('\'');                             out.
private static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch modification, Method call modification, Method overriding modification or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable modification */
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition, ProvisionedProducted protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition, ProvisionedProducted protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition, ProvisionedProducted protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition, ProvisionedProducted protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition, ProvisionedProducted protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition, ProvisionedProducted protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (
!"#$%&'()*+,-./             boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,             String propName,             Node owner) {             Node oldParent = n.getParent();             n.setParent(parent);             if (parent!= null) {               parent.removeChildFromParent(parent);             }             if (leftType!= null) {               leftType.detachFromParent();             }             if (rightType!= null) {               rightType.detachFromParent();             }             return parent == parent? false : parent == parent? true : super.expectCanAssignToPropertyOf(n, rightType, propName, owner);           } else {             if (parent!= null) {               parent.removeChildFromParent(parent);             }             if (leftType!= null) {               leftType.detachFromParent();             }             return parent == parent? false : super.expectCanAssignToPropertyOf(n, parent);           }
