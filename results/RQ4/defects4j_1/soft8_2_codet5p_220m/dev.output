public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  Pharmacy public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  Pharmacy public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  Pharmacy public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  Pharmacy public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  Pharmacy public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  Pharmacy public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0;              }          return 0; Conditional (if-else) branches addition, Method
protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (if or else) branch removal, Method call removal,  proxier protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (if or else) branch removal, Method call removal,  proxier protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (if or else) branch removal, Method call removal,  proxier protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (if or else) branch removal, Method call removal,  proxier protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (if or else) branch removal, Method call removal,  proxier protected final double doSolve() {                      break;                  case REGUL
public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F;          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file Method call parameter value modification,  proxier public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F;          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file Method call parameter value modification,  proxier public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F;          primitiveValues.put(double.class, 0);       }   }   } \ No newline at end of file Method call parameter value modification,  proxier public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F;          primitiveValues.put(double.class, 0);       }   }   } \ No newline at end of file Method call parameter value modification,  proxier public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F;          primitiveValues.put(double.class, 0);       }   }   } \ No newline at end of file Method call parameter value modification,  proxier public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F;          primitiveValues.put(double.class, 0);       }   }   } \ No newline at end of file Method call parameter value modification,  proxier public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.
public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition,
private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private boolean toStringEquals(Matcher m, Object arg)          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (if-else) branches addition,  proxier private boolean safelyMatches(Matcher m, Object arg)      }       private
public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to time zone offset transition: " + Method call parameter addition, Method call replacement, Return expression modification,  WebACL public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to time zone offset transition: " + Method call parameter addition, Method call replacement, Return expression modification,  WebACL public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(i
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); }              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpad
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) { Assignment expression modification, Conditional (if) branch addition, throw addition, Method call removal, Object instantiation addition,  Pharmacy public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) { Assignment expression modification, Conditional (if) branch addition, throw addition, Method call removal, Object instantiation addition,  Pharmacy public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset
public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  proxier public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  proxier public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  proxier public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  proxier public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  proxier public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  proxier public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {
public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time) {       */ public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another variable,  HealthCheck public Week(Date time)
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    }    static double getSimpleNumber(String s) { Conditional (if) branch addition, Return statement addition, Return expression modification,  Pharmacy private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    }    }    static double getSimpleNumber(String s) { Conditional (if) branch addition, Return statement addition, Return expression modification,  Pharmacy private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    }    }    static double getSimpleNumber(String s) { Conditional (if) branch addition, Return statement addition, Return expression modification,  Pharmacy private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    }    }    static double getSimpleNumber(String s) { Conditional (if) branch addition, Return statement addition, Return expression modification,  Pharmacy private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int
public static String formatPeriod(long startMillis, long endMillis, String forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);  }          public static String formatPeriod(long startMillis, long endMillis, String forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);  }          public static String formatPeriod(long startMillis, long endMillis, String forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduce
public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  WebACL public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  WebACL public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  WebACL public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  WebACL public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  WebACL public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              variance
protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  proxier protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  proxier protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  proxier protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  proxier protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  proxier protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification
public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (if) branch addition,  WebACL public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));
protected VectorialPointValuePair doOptimize()                      if (s!= 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call moving, Method call parameter value modification, Method call removal, Object instantiation addition, Object instantiation removal, Return statement addition, Return statement removal, Variable addition, Variable replacement by another variable,  WebACL protected VectorialPointValuePair doOptimize()                      if (s!= 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call moving, Method call parameter value modification, Method call removal, Object instantiation addition, Object instantiation removal, Return statement addition, Return statement removal, Variable addition, Variable replacement by another variable,  WebACL protected VectorialPointValuePair doOptimize()                      if (s!= 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call moving, Method call parameter value modification, Method call removal, Object instantiation addition, Object instantiation removal, Return statement addition, Return statement removal, Variable addition, Variable replacement by another variable,  WebACL protected VectorialPointValuePair doOptimize()                      if (s!= 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      }  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  PubKey protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */       protected BasePeriod(long duration) {         this(duration, null, null);      }
*        * @since 2.3       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  proxier */      /*       * N.B. we cannot store the actual objects in a HashSet, as that
public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;           }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  proxier public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           Category
public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }          }      } Method call parameter value modification, Variable replacement by another variable,  proxier public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt
public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  proxier public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  proxier public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  proxier public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  proxier public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  proxier public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  proxier
public int indexOf(String str, int startIndex) {              return -1;          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another variable,  WebACL public int indexOf(String str, int startIndex) {              return -1;          }          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another variable,  WebACL public int indexOf(String str, int startIndex) {              return -1;          }          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another variable,  WebACL public int indexOf(String str, int startIndex) {              return -1;          }          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another variable,  WebACL public int indexOf(String str, int startIndex) {              return -1;          }          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another variable,  WebACL public int indexOf(String str, int startIndex) {              return -1;          }          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another
}          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck }          for (CompilerInput input : inputs) { Conditional expression reduction,  HealthCheck
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  proxier private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (if) branch addition,  WebACL private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (if) branch addition,  WebACL private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (if) branch addition,  WebACL private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&                  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && Method call parameter value modification, Return expression modification, Variable replacement by another variable,  WebACL public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&                  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && Method call parameter value modification, Return expression modification, Variable replacement by another variable,  WebACL public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true; Conditional (case in switch) branch addition,  proxier static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token
private double localMax(boolean isMinim,          double w = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }          double fv = fx;          double fw = fx;         int count = 0;         while (count < maximalIterationCount) {              double m = 0.5 * (a + b);              final double tol1 = eps * Math.abs(x) + t;              final double tol2 = 2 * tol1; Assignment addition, Conditional (if-else) branches addition, Conditional expression modification, throw removal, Loop conditional expression modification, Method call addition, Method call parameter removal, Method call parameter value modification, Method call removal, Method call replacement, Method overriding addition or removal, Parameter removal from method definition, Method definition removal, Object instantiation removal, Return expression modification, Return statement removal, Variable addition, Variable removal, Variable replacement by method call,  Pharmacy private double localMin(boolean isMinim,          double w = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }          double fv = fx;          double fw = fx;         int count = 0;         while (count < maximalIterationCount) {              double m = 0.5 * (a + b);              final double tol1 = eps * Math.abs(x) + t;              final double tol2 = 2 * tol1; Assignment addition, Conditional (if-else) branches addition, Conditional expression modification, throw removal, Loop conditional expression modification, Method call addition, Method call parameter removal, Method call parameter value modification, Method call removal, Method call replacement, Method overriding addition or removal, Parameter removal from method definition, Method definition removal, Object instantiation removal, Return expression modification, Return statement removal, Variable addition, Variable removal, Variable replacement by method call,  Pharmacy private double localMin(boolean isMinim,          double w = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }
public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true; Conditional (case in switch) branch addition,  proxier public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type
private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  proxier private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  proxier private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  proxier private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  proxier private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  proxier private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean is
@Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign = processInfixExpression(assignmentNode);        return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  WebACL      @Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign = processInfixExpression(assignmentNode);        return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  WebACL      @Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign = processInfixExpression(assignmentNode);        return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  WebACL      @Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign = processInfixExpression(assignmentNode);        return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  WebACL      @Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign = processInfixExpression(assignmentNode);        return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  WebACL      @Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign = processInfixExpression(assignmentNode);        return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  WebACL      @Override      Node processArrayLiteral(ArrayLiteral literalNode)      @Override      Node processAssignment(Assignment assignmentNode)        Node assign =
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  Pharmacy private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }
public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  WebACL public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  WebACL public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  WebACL public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;        private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object
protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable,  WebACL protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable,  WebACL protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable,  WebACL protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable,  WebACL protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable,  WebACL protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i
public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  proxier public class Timer { Conditional (if) branch addition
private boolean shouldReportThis(Node n, Node parent)     return false;      }     return false;    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable addition,  HealthCheck private boolean shouldReportThis(Node n, Node parent)     return false;    }    /** Assignment addition, Conditional (if) branch addition, Method call addition, Return statement
private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token) {      if (token!= JsDocToken.LP) {        return reportTypeSyntaxWarning
public Complex conjugate() { public Complex divide(Complex divisor)          throws NullArgumentException {          MathUtils.checkNotNull(divisor);          if (isNaN || divisor.isNaN) {              return NaN;          }         if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {             return NaN;          }          if (divisor.isInfinite() &&!isInfinite()) {              return ZERO;          }          final double c = divisor.getReal();          final double d = divisor.getImaginary();          if (FastMath.abs(c) < FastMath.abs(d)) {              double q = c / d;              double denominator = c * q + d;              return createComplex(real * q + imaginary) / denominator,                  (imaginary * q - real) / denominator;          } else {              double q = d / c;              double denominator = d * q + c;              return createComplex(imaginary * q + real) / denominator,                  (imaginary - real * q / denominator);          }      }            public Complex divide(double divisor) {          if (isNaN || Double.isNaN(divisor)) {              return NaN;          }          if (divisor == 0d) {             return NaN;          }          if (Double.isInfinite(divisor)) {              return!isInfinite()? ZERO : NaN;          }          return createComplex(real / divisor,                               imaginary  / divisor);      }      /**       * Test for the equality of two Complex objects.       * If both the real and imaginary parts of two complex numbers       * are exactly the same, and neither is {@code Double.NaN}, the two       * Complex objects are considered to be equal.       * All {@code NaN} values are considered to be equal - i.e, if either       * (or both) real and imaginary parts of the complex number are equal
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  proxier protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  proxier protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  proxier protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  proxier protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  proxier protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  proxier protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final Real
public double[] guessParametersErrors(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                                            new Object[] { new Integer(m), new Integer(p)});          }         double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) {
public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  Pharmacy public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  Pharmacy public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  Pharmacy public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  Pharmacy public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  Pharmacy public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  Pharmacy public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }
public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  Pharmacy public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  Pharmacy public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  Pharmacy public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  Pharmacy public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  Pharmacy public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  Pharmacy public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();
protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport actualParameterizedType(Object mock) protected GenericMetadataSupport
public long roundFloor(long instant)              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method call parameter addition, Method call replacement, Return expression modification,  proxier public long roundFloor(long instant)              }          } Method
public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if) branch addition, throw addition, Loop addition, Method call addition, Variable addition,  proxier public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; Assignment addition, Conditional (if)
private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNative
public Fraction pow(int power) {       */ private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  proxier private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }
static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (if) branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  WebACL private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (if) branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  WebACL private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (if) branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  WebACL private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (if) branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  WebACL private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .
private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (if) branch addition, Method call addition, Return statement addition, Variable addition,  Pharmacy private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node
private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  Pharmacy private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  Pharmacy private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  Pharmacy private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  Pharmacy private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  Pharmacy private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains
}  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }
public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          }          } else { Assignment addition, Conditional (if-else) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  Pharmacy public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          }          } else { Assignment addition, Conditional (if-else) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  Pharmacy public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          }          } else { Assignment addition, Conditional (if-else) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  Pharmacy public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg;
public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier public
static Double getNumberValue(Node n) {    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getNumberValue(Node n) {    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if) branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  Pharmacy static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString); Conditional (if
public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build();      } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  proxier public FunctionTypeBuilder inferFrom
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification,  WebACL private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification,  WebACL private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification,  WebACL private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio
private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext()) {          String name = child.getString(); Conditional (if) branch addition, Method call addition,  proxier private void handleObjectLit(NodeTraversal t,
private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition,
* @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  Pharmacy * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /**
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,  proxier protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,  proxier protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,  proxier protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,  proxier protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,  proxier protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,  proxier protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (if) branch addition,
public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch removal, Method call removal,  Pharmacy public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch removal, Method call removal,  Pharmacy public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch removal, Method call removal,  Pharmacy public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch removal, Method call removal,  Pharmacy public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch removal, Method call removal,  Pharmacy public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch removal, Method call removal,  Pharmacy public boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;      return true; Conditional (if or else) branch
