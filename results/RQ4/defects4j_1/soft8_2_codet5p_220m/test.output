private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,      do {        switch (token) {          case STAR:            if (ignoreStar) {              if (builder.length() > 0) {
public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() { Method call addition, Return expression modification,  Pharmacy public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType
public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  WebACL public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  WebACL public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  WebACL public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  WebACL public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  WebACL public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       }
public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  proxier public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  proxier public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  proxier public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  proxier public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  proxier public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  proxier public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,
public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Conditional expression modification, Method call addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return statement addition, Variable addition,  HealthCheck public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Conditional expression modification, Method call addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return statement addition, Variable addition,  HealthCheck public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Conditional expression modification, Method call addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return statement addition, Variable addition,  HealthCheck public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Conditional expression modification, Method call addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return statement addition, Variable addition,  HealthCheck public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Conditional expression modification, Method call addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return statement addition, Variable addition,  HealthCheck public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; } Assignment addition, Conditional (case in switch) branch addition, Conditional (if) branch addition, Conditional expression modification, Method call addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return statement addition, Variable addition,  HealthCheck public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.
public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  proxier public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,
public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  proxier public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,
public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear); Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  WebACL public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear); Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  WebACL public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear); Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  WebACL public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear); Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  WebACL public int parseInto(Read
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesTo
private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());        } } else { Conditional expression expansion, Method call addition,  Pharmacy private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());        } } else { Conditional expression expansion, Method call addition,  Pharmacy private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());        } } else { Conditional expression expansion, Method call addition,  Pharmacy private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());        } } else { Conditional expression expansion, Method call addition,  Pharmacy private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType
public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                      final double[] wi  = wData[i];                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];                          }                 }                          for (int j = 0; j < p; ++j) {                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];                          }                  }                          for (int j = 0; j < p; ++j) {                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];                          }                  }                  for (int i = p; i < m; ++i) {                      wData[i] = new double[p]; Assignment addition, Assignment expression modification, Assignment removal, Conditional (if-else) branches addition, Loop conditional expression modification, Method call parameter value modification, Variable replacement by another variable,  WebACL public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                      final double[] wi  = wData
protected UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best(current,                                    previous,                              isMinim);              }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  HealthCheck public UnivariatePointValuePair doOptimize() {                      }                  } } } else {                 return                              best
private static final long serialVersionUID = -7105341425736035847L;      private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  Pharmacy private static final long serialVersionUID = -7105341425736035847L;      private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  Pharmacy private static final long serialVersionUID = -7105341425736035847L;      private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,
private void interpretAssigns() {                  assign.assignNode.getLastChild(), true);                assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  proxier private void interpretAssigns() {              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  proxier private void interpretAssigns() {              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  proxier private void interpretAssigns() {              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  proxier private void interpretAssigns() {              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  proxier private void interpretAssigns() {              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,
private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }     }      Node cArg = callNode.getFirstChild().getNext(); private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }     }      Node cArg = callNode.getFirstChild().getNext(); private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }     }      Node cArg = callNode.getFirstChild().getNext(); private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }     }      Node cArg = callNode.getFirstChild().getNext(); private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHave
private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) { Conditional expression expansion,  HealthCheck private void inlineAliases(GlobalNamespace namespace)          continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0)
public ElitisticListPopulation(final List<Chromosome> chromosomes,       */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final int populationLimit, final double elitismRate,      */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final int populationLimit, final double elitismRate,      */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final int populationLimit, final double elitismRate,      */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final int populationLimit, final double elitismRate,      */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final int populationLimit, final double elitismRate,      */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  WebACL public ElitisticListPopulation(final int populationLimit, final double elitismRate,      */ public ElitisticListPopulation(final int populationLimit, final double elitism
public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  HealthCheck public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  HealthCheck public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  HealthCheck public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  HealthCheck public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  HealthCheck public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  HealthCheck public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public void setRangeAxisIndex(ValueAxis axis) {
public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (if) branch addition,  WebACL public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (if) branch addition,  WebACL public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (if) branch addition,  WebACL public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);
public String escape(String str) { public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); Assignment addition, Assignment expression modification, Conditional (if-else) branches addition, Method call addition, Method call replacement, Variable type change,  Pharmacy public String escape(String str) { public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); Assignment addition, Assignment expression modification, Conditional (if-else) branches addition, Method call addition, Method call replacement, Variable type change,  Pharmacy public String escape(String str) { public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); Assignment addition, Assignment expression modification, Conditional (if-else) branches addition, Method call addition, Method call replacement, Variable type change,  Pharmacy public String escape(String str) { public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer
private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar); Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, Method call addition,  Pharmacy private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar); Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, Method call addition,  Pharmacy private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar); Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, Method call addition,  Pharmacy private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar); Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, Method call addition,  Pharmacy private void findAliases(NodeTraversal t) {          Node n =
public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition,  Hps public BooleanOptionHandler(        @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null {            setter.addValue(true); Assignment addition, try-catch addition
public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial); Conditional (if) branch addition, throw addition, Method call addition,  WebACL public double solve(final UnivariateRealFunction f,              return
private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs);              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  WebACL
public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  Pharmacy public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  Pharmacy public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  Pharmacy public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  Pharmacy public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  Pharmacy public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  Pharmacy public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,
public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException.          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  HealthCheck public void delete(int start, int end) {       *
public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  HealthCheck public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }
public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  Pharmacy public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  Pharmacy public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  Pharmacy public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  Pharmacy public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  Pharmacy public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  Pharmacy public static int safeMultiply(int val1, int val2) { public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,
public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  proxier public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  proxier public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  proxier public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  proxier public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  proxier public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  proxier public static boolean isEmpty(boolean[] array)          } else if (element!= null) {              type = element.getClass();          } else
public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           }           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           }           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           }           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           }           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           }           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end."           }           TimeSeries copy = (TimeSeries) super.clone();           }           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  Pharmacy public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires
private Node tryFoldComparison(Node n, left, right) {            && right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false))     int lhType = left.getType();     int rhType = right.getType();      switch (lhType) {            case Token.VOID:          if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  PubKey private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  PubKey private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  PubKey private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  PubKey private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  PubKey private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition,
public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, long value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.
public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  Pharmacy public long add(long instant, int value)              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.
public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos); Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos); Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos); Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos); Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos); Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number
public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call addition, Object instantiation addition, Variable replacement by method call,  Pharmacy public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys
private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, GameSession private boolean isInlinableObject(List<Reference> refs) {
private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey()); private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<Type
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              } Assignment expression modification, Conditional (if) branch addition, Conditional expression modification, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              } Assignment expression modification, Conditional (if) branch addition, Conditional expression modification, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              } Assignment expression modification, Conditional (if) branch addition, Conditional expression modification, throw addition, Method call addition, Object instantiation addition,  Pharmacy public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }          int offset = 0;          try {              int hoursInMinutes =
protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN); Conditional expression expansion, Method call addition,  proxier protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN); Conditional expression expansion, Method call addition,  proxier protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN); Conditional expression expansion, Method call addition,  proxier protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN); Conditional expression expansion, Method call addition,  proxier protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN); Conditional expression expansion, Method call addition,  proxier protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN); Conditional expression expansion, Method call addition,  proxier protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false
private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal,  WebACL private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal,  WebACL private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal,  WebACL private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal,  WebACL private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal,  WebACL private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJSIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJSIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  Pharmacy public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJSIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJSIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  Pharmacy public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJSIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJSIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  Pharmacy public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJSIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJSIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  Pharmacy public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJSIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJSIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  Pharmacy public static boolean isJSIdentifier(String s)
protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call, artbeat protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call, artbeat protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call, artbeat protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call, artbeat protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call, artbeat protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call, artbeat protected PointVectorValuePair doOptimize() {                      if (checker!= null) {
private boolean isVarInlineForbidden(Var var) {       */        private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier private boolean isVarInlineForbidden(Var var) {       */        private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier private boolean isVarInlineForbidden(Var var) {       */        private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier private boolean isVarInlineForbidden(Var var) {       */        private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier private boolean isVarInlineForbidden(Var var) {       */        private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          Assignment addition, Conditional (if) branch addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  proxier private boolean isVarInlineForbidden(Var var) {       */        private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref :
void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally         * block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      } Assignment removal, Conditional (if or else) branch removal, Method call removal, Variable removal,  proxier public void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      } Assignment removal, Conditional (if or else) branch removal, Method call removal, Variable removal,  proxier public void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      } Assignment removal, Conditional (if or else) branch removal, Method call removal, Variable removal,  proxier public void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      } Assignment removal, Conditional (if or else) branch removal, Method call removal, Variable removal,  proxier public void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally block. See ECMA 262 Sections 8.
public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  WebACL public void setMinuteOfHour
private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected); Conditional (if) branch addition, Conditional (if-else) branches addition, Loop addition, Method call addition, Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return statement addition, Return expression modification,  Pharmacy private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected); Conditional (if) branch addition, Conditional (if-else) branches addition, Loop addition, Method call addition, Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return statement addition, Return expression modification,  Pharmacy private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected); Conditional (if) branch addition, Conditional (if-else) branches addition, Loop addition, Method call addition, Method call parameter addition, Method call replacement,
public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class classToMock) {  }  public void initiateMockName(Class class
protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  proxier protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                      }                  }
public long getUnitMillis() {       * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0;      } Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  Pharmacy public long getUnitMillis() {       * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0;      } Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  Pharmacy public long getUnitMillis() {       * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0;      } Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  Pharmacy public long getUnitMillis() {       * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0;      } Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  Pharmacy public long getUnitMillis() {       * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0;      } Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  Pharmacy public long getUnitMillis() {       * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0;      } Conditional (if-else) branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  Pharmacy
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (if) branch addition, Return statement addition,  proxier public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector
private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier private boolean canInline(          }        } Conditional (if) branch addition,
public boolean setPrototype(PrototypeObjectType prototype) { return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true;      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  Hps public boolean setPrototype(PrototypeObjectType prototype) { return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true;      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  Hps public boolean setPrototype(PrototypeObjectType prototype) { return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true;      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  Hps public boolean setPrototype(PrototypeObjectType prototype) { return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true;      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  Hps public boolean setPrototype(PrototypeObjectType prototype) { return false;      }     boolean replaced
public static Node tryFinally(Node tryBody, Node finallyBody) { public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  Pharmacy public static Node tryFinally(Node tryBody, Node finallyBody) { public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  Pharmacy public static Node tryFinally(Node tryBody, Node finallyBody) { public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  Pharmacy public static Node tryFinally(Node tryBody, Node finallyBody) { public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  Pharmacy public static Node tryFinally(Node tryBody, Node finallyBody) { public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.check
public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else) branches addition, Method call addition, Return statement addition, Return expression modification,  Pharmacy public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x
private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod;  private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int i
public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  Pharmacy public static String escapeJava(String str) {       * @throws IOException if error occurs
void add(Node n, Context context) {          cc.addOp(opstr, true;          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true;         addExpr(last, p + 1, rhsContext);        }        return;        } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  WebACL
public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  HealthCheck public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  HealthCheck public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  HealthCheck public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  HealthCheck public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  HealthCheck public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  HealthCheck public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean
public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )      } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )      } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )      } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )      } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )      } Conditional (if) branch addition, Method call addition, Return statement addition,  proxier public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )
public EqualsBuilder append(Object lhs, Object rhs)          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false); Assignment addition, Conditional (if-else) branches addition, Method call addition,  proxier public EqualsBuilder append(Object lhs, Object rhs)          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false); Assignment addition, Conditional (if-else) branches addition, Method call addition,  proxier public EqualsBuilder append(Object lhs, Object rhs)          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false); Assignment addition, Conditional (if-else) branches addition, Method call addition,  proxier public EqualsBuilder append(Object lhs, Object rhs)          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false); Assignment addition, Conditional (if-else) branches addition, Method call addition,  proxier public EqualsBuilder append(Object lhs, Object rhs)          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false); Assignment addition, Conditional (if-else) branches addition, Method call addition,  proxier public EqualsBuilder append(Object lhs, Object rhs)          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this
} } void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  Pharmacy } } } void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  Pharmacy } } } void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  Pharmacy } } } void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  Pharmacy } } } } void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.
public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  WebACL public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }       if (inferred) {         inferred =!(rhsValue!= null &&             rhsValue.isFunction() &&             (info!= null ||!scope.isDeclared(qName, false));        }        if (!inferred) { Assignment addition, Assignment removal, Conditional (if-else) branches addition, Conditional expression expansion, Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }       if (inferred) {         inferred =!(rhsValue!= null &&             rhsValue.isFunction() &&             (info!= null ||!scope.isDeclared(qName, false));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (!inferred) { Method call addition, Method call removal,  Pharmacy public void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(
