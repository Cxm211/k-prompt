private ExtractionInfo extractMultilineTextualBlock(Token token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) { Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call removal, Variable addition,  } private ExtractionInfo extractMultilineTextualBlock(Token token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) { Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call removal, Variable addition,  } private ExtractionInfo extractMultilineTextualBlock(Token token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) { Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call removal, Variable addition,  } private ExtractionInfo extractMultilineTextualBlock(Token token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) { Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call removal, Variable addition,  } private ExtractionInfo extractMultilineTextualBlock(Token token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) { Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Conditional (if or else) branch removal, Loop addition, Method call addition, Method call removal, Variable addition,  } private ExtractionInfo extractMultilineTextualBlock(Token token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) { Assignment
public boolean isNoResolvedType() {    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNoResolvedType() || isNo
public void removeRow(Comparable rowKey) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);            removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);            removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);            removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);            removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);            removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement by another variable,  */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);            removeRow(index);       } Assignment addition, Conditional (if) branch addition, Conditional (if or else) branch removal, throw addition, Loop addition, Method call addition, Method call parameter value modification, Object instantiation addition, Return expression modification, Variable addition, Variable replacement
public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] = idx;          return indices;      } Assignment expression modification, Assignment removal, Loop removal, Variable removal,  public int getDimension() {              indices[i] = idx;          }         int idx = 1;             while (count < index) {             count += idx;             ++idx;             --idx;         }         --idx;         indices[last] =
public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;                  }  public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW                      return true;                  }                  return true;
public void enterScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void exitScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void enterScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void exitScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void enterScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void exitScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void enterScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,  } } public void exitScope(TTraversal t) {        if (t.getDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null; Assignment addition, Conditional expression expansion, Method call addition, Variable addition,
public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false) { public double integrate(final First
public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  } public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  } public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  } public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          Assignment expression modification, Method call parameter value modification, Method call removal, Method call replacement,  } public int parseInto(Instant instant, String text
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  /***/ static boolean evaluatesTo
private void visitParameterList(NodeTraversal t, Node n, FunctionType fnType) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = fnType.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());      } else { Conditional expression expansion, Method call addition,  }'  private void visitParameterList(NodeTraversal t, Node n, FunctionType fnType) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = fnType.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());      } else { Conditional expression expansion, Method call addition,  }'  private void visitParameterList(NodeTraversal t, Node n, FunctionType fnType) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = fnType.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());      } else { Conditional expression expansion, Method call addition,  }'  private void visitParameterList(NodeTraversal t, Node n, FunctionType fnType) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = fnType.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());      } else { Conditional expression expansion, Method call addition,  }'  private void visitParameterList(NodeTraversal t, Node n, FunctionType fnType) {      JSType type = getJSType(
public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getU().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                       final double[] wi  = wData[i];                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];                          }                 }                          for (int j = 0; j < p; ++j) {                             wi[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];                          }                  for (int i = p; i < m; ++i) {                      wData[i] = new double[p]; Assignment addition, Assignment expression modification, Assignment removal, Conditional (if-else) branches addition, Loop conditional expression modification, Method call parameter value modification, Variable replacement by another variable,  }'  public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getU().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                       final double[] wi  = wData[i];                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei
protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best(current,                                   previous,                              isMinim);               }              ++iter; Assignment addition, Method call addition, Method call replacement, Return expression modification, Variable addition,  /***/  protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return                              best
public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           }           } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           }           } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           }           } Assignment addition, Assignment removal, Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.
private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional () branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional () branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional () branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional () branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--; Assignment addition, Assignment expression modification, Conditional () branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  private void interpretAssigns()
public CanInlineResult canInlineReferenceDirectly(      Node block = node.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }       }      Node cArg = callNode.getFirstChild().getNext(); Assignment removal, Conditional (or else) branch removal, Method call removal, Return statement removal, Variable removal,  private CanInlineResult canInlineReferenceDirectly(      Node block = node.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }       }      Node cArg = callNode.getFirstChild().getNext(); Assignment removal, Conditional (or else) branch removal, Method call removal, Return statement removal, Variable removal,  private CanInlineResult canInlineReferenceDirectly(      Node block = node.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }       }      Node cArg = callNode.getFirstChild().getNext(); Assignment removal, Conditional (or else) branch removal, Method call removal, Return statement removal, Variable removal,  private CanInlineResult canInlineReferenceDirectly(      Node block = node.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }       }      Node cArg = callNode.getFirstChild().getNext(); Assignment removal, Conditional (or else) branch removal, Method call
private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }  private void inlineAliases(GlobalNamespace namespace) {          continue; }
public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate,       */      public Elitistic
public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRangeAxes(ValueAxis[] axes       * @since 1.0.7        */       public void setRange
public static Number createNumber(final String str, final int mant, final int exp) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (branch addition,  siteRoot public static Number createNumber(final String str, final int mant, final int exp) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (branch addition,  siteRoot public static Number createNumber(final String str, final int mant, final int exp) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          } Conditional (branch addition,  siteRoot public static Number createNumber(final String str, final int mant, final int exp) throws NumberFormatException          final boolean allZeros = is
public String escape(String str) throws IOException {      public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); }         }         }         }         }         public String escape(String str) throws IOException {      public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); }         }         }         }         }         public String escape(String str) throws IOException {      public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); }         }         }         }         }         public String escape(String str) throws IOException {      public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';'); }         }         }         }         }         public String escape(String str) throws IOException {      public void escape
private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);            }          }          }          private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);            }          }          }          private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);            }          }          }          private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);            }          }          }          private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);            }
public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {            setter.addValue(true);          }         }         }         public BooleanOptionHandler(
public double solve(final UniformRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax, initial, yInitial          );          return solve(f, min, yMin, max, yMax
private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild(); Conditional expression expansion, Method call addition,  /***/ private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild();
public static Collection anyCollection()       * @return <code>null</code>.  */       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  **/       public static <T> T isA(Class<T> clazz)          return reportMatcher(new InstanceOf
public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       } Assignment addition, Assignment expression modification, Method call addition, Method call removal, Variable type change,  */
public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();         }  public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100
public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  }} public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  }} public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  }} public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  }} public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  }} public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  }} public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L; Conditional
public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          Assignment removal, throw addition, Object instantiation addition, Object instantiation removal,  } public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          Assignment removal, throw addition, Object instantiation addition, Object instantiation removal,  } public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          Assignment removal, throw addition, Object instantiation addition, Object instantiation removal,  } public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          Assignment removal, throw addition, Object instantiation addition, Object instantiation removal,  } public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          Assignment removal, throw addition, Object instantiation addition, Object instantiation removal,  } public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          Assignment removal, throw addition, Object instantiation addition, Object instantiation removal,  } public static boolean isEmpty(boolean[] array) {          } else if (element!= null
public TimeSeries createCopy(int start, int end              throw new IllegalArgumentException("Requires start <= end.");           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) { Assignment addition,  }           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();
private Node tryFoldComparison(Node n, Node left, Node right) {            && right.getString().equals("undefined"))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false))            || (Token.V
private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable
public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant,
public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant,
public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str.substring(decPos + 1, expPos);                  } Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str.substring(decPos + 1, expPos);                  } Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str.substring(decPos + 1, expPos);                  } Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str.substring(decPos + 1, expPos);                  } Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str.substring(decPos + 1, expPos);                  } Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos
public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           } Assignment expression modification, Conditional expression modification, Method call modification, Object instantiation modification, Variable replacement by method call,  } public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys
private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch addition, Method call addition, Return statement addition,  )" private boolean isInlinableObject(List<Reference> refs) { Conditional (branch
private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns         for (Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map.Entry<Map
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              } } Assignment expression modification, Conditional (branch) branch addition, Conditional expression modification, throw addition, Method call addition, Object instantiation addition,  } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              } } Assignment expression modification, Conditional (branch) branch addition, Conditional expression modification, throw addition, Method call addition, Object instantiation addition,  } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              } } Assignment expression modification, Conditional (branch) branch addition, Conditional expression modification, throw addition, Method call addition, Object instantiation addition,  } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset >
protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);              if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                   setBarycenter(Vector2D.NaN);                   Conditional expression expansion, Method call addition,  }}  protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);              if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                   setBarycenter(Vector2D.NaN);                   Conditional expression expansion, Method call addition,  }}  protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);              if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                   setBarycenter(Vector2D.NaN);                   Conditional expression expansion, Method call addition,  }}  protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);              if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                   setBarycenter(Vector2D.NaN);                   Conditional expression expansion, Method call addition,  }}  protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);              if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                   setBarycenter(Vector2D.NaN);                   Conditional expression expansion, Method call addition,  }}  protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);              if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                   setBarycenter(Vector2D.NaN);                   Conditional expression expansion, Method call addition,  }}  protected void computeGeometrical
private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal  //======================================================================  private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal  //======================================================================  private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal  //======================================================================  private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal  //======================================================================  private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage"); Method call addition, Method call parameter value modification, Method call removal  //======================================================================  private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT",
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;          }         for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  }  public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;          }         for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  }  public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;          }         for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  }  public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;          }         for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  }  public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;          }         for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          } Conditional expression expansion, Method call addition,  }
protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                               return current;                          } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by method call,  } Assignment expression modification, Assignment removal, Conditional expression modification, Method call addition, Method call parameter value modification, Object instantiation modification, Variable removal, Variable replacement by
private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent(); Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Return statement addition, Variable addition,  */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent(); Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Return statement addition, Variable addition,  */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent(); Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Return statement addition, Variable addition,  */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent(); Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Return statement addition, Variable addition,  */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent(); Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Return statement addition, Variable addition,  */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent(); Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Return statement addition, Variable addition,  */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;         for (Reference ref : refs) {
void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally         * block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal, Variable removal,  } Assignment removal, Conditional (or else) branch removal, Method call removal
public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if
private boolean injectMockCandidates(Class<?> injectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);                  return true;              }                  return false;          }                  return false;          }                  private boolean injectMockCandidates(Class<?> injectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);                  return true;              }                  return false;          }                  return false;          }                  private boolean injectMockCandidates(Class<?> injectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);                  return true;              }                  return false;          }                  return false;          }                  private boolean injectMockCandidates(Class<?> injectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance
public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) { Assignment addition, Method call addition, Method call removal, Object instantiation addition, Return expression modification, Variable addition,  }       public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) { Assignment addition, Method call addition, Method call removal, Object instantiation addition, Return expression modification, Variable addition,  }       public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) { Assignment addition, Method call addition, Method call removal, Object instantiation addition, Return expression modification, Variable addition,  }       public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) { Assignment addition, Method call addition, Method call removal, Object instantiation addition, Return expression modification, Variable addition,  }       public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) { Assignment addition, Method call addition, Method call removal, Object instantiation addition, Return expression modification, Variable addition,  }       public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public void initiateMockName(Class classToMock) { Assignment
protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/ protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current))                         return current;                         }                  } Method call addition, Return expression modification,  /***/
public long getUnitMillis() {       * @return zero always       */      public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;          }          return 0;          } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition, Conditional (if or else) branch removal, Conditional expression expansion, throw addition, Method call addition, Object instantiation addition, Return statement removal,  } Conditional (if-else branches addition
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Conditional (branch addition, Return statement addition,  /***/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);
private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/  private boolean canInline(          }  } Conditional (if) branch addition, Method call addition, Return statement addition,
public boolean setPrototype(PrototypeObjectType prototype) {        return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional (branch-) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional (branch-) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional (branch-) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional (branch-) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable,  }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment
public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  public static Node tryFinally(Node tryBody, Node finallyBody) {    public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  public static Node tryFinally(Node tryBody, Node finallyBody) {    public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  public static Node tryFinally(Node tryBody, Node finallyBody) {    public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    } Assignment expression modification, Method call parameter value modification, Method call replacement, Method definition addition, Object instantiation addition, Return statement addition,  public static Node tryFinally(Node tryBody, Node finallyBody) {    public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(
public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if-else branches addition, Method call addition, Return statement addition, Return expression modification,  public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          } Conditional (if
private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;  private volatile int iPeriod;
public static String escapeJava(String str)       * @throws IOException if error occurs on underlying Writer       */       public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  **/      public static String escapeJava(String str)       * @throws IOException if error occurs on underlying Writer       */       public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  **/      public static String escapeJava(String str)       * @throws IOException if error occurs on underlying Writer       */       public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  **/      public static String escapeJava(String str)       * @throws IOException if error occurs on underlying Writer       */       public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  **/      public static String escapeJava(String str)       * @throws IOException if error occurs on underlying Writer       */       public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  **/      public static String escapeJava(String str)       * @throws IOException if error occurs on underlying Writer       */       public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  **/      public static String escapeJava(
void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      } Conditional expression expansion, Method call addition, Method call parameter addition, Method call replacement, Variable replacement by another variable,  void add(Node n
public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;       }      /** Method call addition, Method call removal, Return expression modification,  /***/      public static double cosh(double x) {       * @return {@code true} if the values are equal.
public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/ public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/ public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/ public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/ public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } Conditional (if) branch addition, Method call addition, Return statement addition,  /***/ public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()));      } Conditional (if) branch addition, Method call addition,
public EqualsBuilder append(Object lhs, Object rhs) {          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);          }          return this;          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          }
void apply() {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();  this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  /***/ void apply() {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();  this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  /***/ void apply() {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();  this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  /***/ void apply() {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();  this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (branch) branch addition, Conditional expression expansion, Conditional expression modification, Method call addition, Method call removal, Variable addition,  /***/ void apply() {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();  this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || Assignment addition, Assignment expression modification, Conditional (branch
public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value is invalid       * @throws IllegalArgumentException if the value
void maybeDeclareQualifiedName(JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.isFunctionTypeDeclaration(info)              || FunctionTypeBuilder.
