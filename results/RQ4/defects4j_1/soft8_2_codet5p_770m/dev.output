protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  } protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  } protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  } protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  } protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification, Variable addition,  } protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0; Assignment addition, Assignment expression modification
public int translate(CharSequence input, int index, Writer out throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0) + 1;          }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition, Variable addition,  }          return 0; Conditional (if-else) branches addition, Method call addition
public void applyAlias() {    private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;      this.aliasName = aliasName;     }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }      } } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition, Method call parameter value modification, Method call replacement, Parameter addition in method definition, Object instantiation modification, Variable addition,  } Assignment addition, Method call addition, Method call parameter addition
protected GenericMetadataSupport actualParameterizedType(Object mock, InvocationContainerImpl container) throws Throwable {          private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer<Object>() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               } Assignment addition, Assignment removal, Conditional (branch addition) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  protected GenericMetadataSupport actualParameterizedType(Object mock, InvocationContainerImpl container) throws Throwable {          private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer<Object>() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               } Assignment addition, Assignment removal, Conditional (branch addition) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  protected GenericMetadataSupport actualParameterizedType(Object mock, InvocationContainerImpl container) throws Throwable {          private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer<Object>() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               } Assignment addition, Assignment removal, Conditional (branch addition) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  protected GenericMetadataSupport actualParameterizedType(Object mock, InvocationContainerImpl container) throws Throwable {          private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer<Object>() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               } Assignment addition, Assignment removal, Conditional (branch addition) branch addition, Method call addition, Method definition addition, Object instantiation addition, Object instantiation removal, Return expression modification, Type addition, Variable modifier change, Variable type change,  protected GenericMetadataSupport actualParameterizedType(Object mock, InvocationContainerImpl container) throws Throwable {          private Object recordDeepStubMock(final Object mock, InvocationContainerImpl
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition, Conditional expression expansion, Method call addition,  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right))          return n;      }      } Conditional (if) branch addition
public double getChiSquare(EstimationProblem problem) {      public double[] guessParametersErrors(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                                            new Object[] { new Integer(m)});           }         double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) { Assignment expression modification, Method call replacement,  }         double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) { Assignment expression modification, Method call replacement,  }         double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) { Assignment expression modification, Method call replacement,  }         double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) { Assignment expression modification, Method call replacement,  }         double[] errors = new double[problem.getAllParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) { Assignment expression modification, Method call replacement,  }         double[] errors = new double[problem.getAllParameters
public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }         if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  } public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }         if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  } public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }         if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  } public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }         if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  } public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }         if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  } public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }         if (x == 0) { Assignment addition, Conditional (if-else) branches addition, Method call addition, Return statement addition, Variable addition,  }
FunctionTypeBuilder inferFromOverriddenFunction(        }         parametersNode = paramBuilder.build();         } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop addition, Method call addition,  } Assignment addition, Conditional (if) branch addition, Loop
private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  default : Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        } Assignment addition, Conditional (branch addition, Method call parameter value modification, Object instantiation modification, Variable addition,  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn()); if (entry.getNameId
public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call addition, Method call removal, Method definition addition, Object instantiation addition, Variable addition,  } else { Assignment addition, Conditional (--) branches addition, Loop addition, Loop conditional expression modification, Method call
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) { Assignment expression modification, Conditional (branch addition) branch addition, throw addition, Method call removal, Object instantiation addition,  } } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) { Assignment expression modification, Conditional (branch addition) branch addition, throw addition, Method call removal, Object instantiation addition,  } } public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutes
public LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               return result;          }           int seriesCount = dataset.getRowCount(); Conditional expression modification,  }           LegendItemCollection getLegendItems()          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.get
private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     }      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     }      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     }      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     }      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode() Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     }      /*       * N.B. we cannot store
protected final double computeObjectiveValue(double x0) {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (or else) branch removal, Method call removal,  /***/ protected final double computeObjectiveValue(double x0) {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (or else) branch removal, Method call removal,  /***/ protected final double computeObjectiveValue(double x0) {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (or else) branch removal, Method call removal,  /***/ protected final double computeObjectiveValue(double x0) {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (or else) branch removal, Method call removal,  /***/ protected final double computeObjectiveValue(double x0) {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  default: Assignment removal, Conditional (or else) branch removal, Method
private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,  }         private String normalizeSourceName(String filename)        AbstractOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) { Assignment addition, Conditional (branch addition, Method call addition, Return statement addition, Variable addition,
public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  } public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  } public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  } public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  } public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  } public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition, Method call addition, Object instantiation addition, Return statement addition,  } public Fraction pow(int power)       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1; } Conditional expression modification, throw addition
private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;            child = child.getNext(); }          String name = child.getString(); Conditional () branch addition, Method call addition,  } private void handleObjectLit(NodeTraversal t, Node n) {            child!= null;
public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str; Conditional expression expansion, throw addition, Method call addition, Object instantiation addition,  } public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Variable addition,  } } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Variable addition,  } } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Variable addition,  } } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-) branches addition, Method call addition, Variable addition,  } } public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix!= null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if
private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime() &&          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  }          private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime() &&          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  }          private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime() &&          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  }          private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime() &&          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  }          private void inlineNonConstants(        if (!maybeModifiedArguments &&           !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime() &&          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode(); Conditional expression expansion, Method call addition,  }          private void inlineNonConstants(        if (!maybeModifiedArguments &&           !
public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another another,  } Method call parameter value modification, Variable replacement by another
static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static void register(Object value)       * @since 2.3       */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal
static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition, Return expression modification, Variable replacement by another variable,  static Double getNumberValue(Node n)    }    static Double getStringNumberValue(String rawJsString)      String s = trimJsWhiteSpace(rawJsString); Conditional (branch addition, Method call addition, Return statement addition
public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());       }       /** Method call parameter value modification, Variable replacement by another another,  */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.IN:          return true; }  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true; }  static boolean evaluatesToLocalValue(Node
protected void dropPhase2Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement by another variable,  } Method call parameter value modification, Variable replacement
public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition, Variable replacement by method call,  */ public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition, Variable replacement by method call,  */ public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition, Variable replacement by method call,  */ public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition, Variable replacement by method call,  */ public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition, Variable replacement by method call,  */ public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition, Variable replacement by method call,  */ public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;         }      /** Assignment removal, Method call addition,
JSType resolveInternal(JSType typeOfThis, JSType t, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope<JSType> scope, StaticScope
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      }     return len > 0 && s.charAt(0)!= '0';    static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimpleNumber(String s) { Conditional (branch addition, Return statement addition, Return expression modification,  static double getSimple
public int indexOf(String str, int startIndex) {              return -1;           }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) { Assignment expression modification, Variable replacement by another another,  } }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method call replacement, Variable addition,  **/      protected BasePeriod(long duration)         this(duration, null, null);      /** Assignment addition, Method call addition, Method
public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  /***/ public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  /***/ public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  /***/ public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  /***/ public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  /***/ public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } Method call parameter value modification, Return expression modification,  /***/
void addIdentifier(String identifier)       * Constants (true, false, null) are considered basically free,       * because it's likely that they will get folded when we're done,       *    } Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call addition, Method definition addition, Method overriding addition or removal,  Method call
Node processArrayLiteral(ArrayLiteral literalNode);      @Override      Node processAssignment(Assignment assignmentNode);        Node assign = processInfixExpression(assignmentNode); return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  } Node processArrayLiteral(ArrayLiteral literalNode);      @Override      Node processAssignment(Assignment assignmentNode);        Node assign = processInfixExpression(assignmentNode); return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  } Node processArrayLiteral(ArrayLiteral literalNode);      @Override      Node processAssignment(Assignment assignmentNode);        Node assign = processInfixExpression(assignmentNode); return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  } Node processArrayLiteral(ArrayLiteral literalNode);      @Override      Node processAssignment(Assignment assignmentNode);        Node assign = processInfixExpression(assignmentNode); return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  } Node processArrayLiteral(ArrayLiteral literalNode);      @Override      Node processAssignment(Assignment assignmentNode);        Node assign = processInfixExpression(assignmentNode); return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Method call addition, Method definition addition, Return statement addition, Variable addition,  } Node processArrayLiteral(ArrayLiteral literalNode);      @Override      Node processAssignment(Assignment assignmentNode);        Node assign = processInfixExpression(assignmentNode); return assign;      } Assignment addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Conditional (case in switch) branch addition, Method call
public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to offset transition: " + Method call parameter addition, Method call replacement, Return expression modification,  }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to offset transition: " + Method call parameter addition, Method call replacement, Return expression modification,  }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to offset transition: " + Method call parameter addition, Method call replacement, Return expression modification,  }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              if (get(result)!= value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to offset transition: " +
private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunctionType(JsDocToken token)      if (token!= JsDocToken.LP)        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } Method call addition,  Pharmacy private Node parseFunction
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJSTypeName(owner, true),            rightType       return false;       }      return true; Conditional (if or else) branch removal, Method call removal,  /***/ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + of " +            getReadableJS
Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) { Conditional expression reduction,  }         Node parseInputs()
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation addition, Return expression modification, Variable addition,  private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(),                   container           );       Method call parameter addition, Method call replacement, Method definition addition, Parameter addition in method definition, Object instantiation
private void visitSetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (n.getType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));        checkPropertyAccess(childType, property.getString(), t, n); Conditional (or else) branch removal, Method call removal, Return statement removal,  /***/ private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (n.getType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));        checkPropertyAccess(childType, property.getString(), t, n); Conditional (or else) branch removal, Method call removal, Return statement removal,  /***/ private void visitSetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (n.getType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE));        checkPropertyAccess(childType, property.getString(), t, n); Conditional (or else) branch removal, Method call removal, Return statement removal,  /***/ private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (n.getType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined
private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }   } Conditional (--) branches addition,  /***/ private boolean safelyMatches(Matcher
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) ==                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) ==                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&                  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && Method call parameter value modification, Return expression modification, Variable replacement by another variable,  } public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) ==                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) ==                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&                  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && Method call parameter value modification, Return expression modification, Variable replacement by another variable,  } public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) ==                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar
public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       * @throws IllegalArgumentException if the value is invalid       *      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } Conditional (branch addition,  stackPtr public void setWeekOfWeekyear(final int weekOfWeekyear       *
public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  /***/ public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  /***/ public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  /***/ public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  /***/ public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; Conditional expression modification,  /***/ public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              variance
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator              if (comparator.compare(contracted, best) < 0) {                  return;              } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  } Assignment addition, Conditional (branch addition, Loop addition, Method call addition, Return statement addition, Variable addition,  }
public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (if) branch addition, Method call addition, Method definition addition, Object instantiation addition,  public class Timer { Conditional (
private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  }          private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  }          private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  }          private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  }          private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP; Conditional expression expansion, Method call addition,  }          private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChain
public static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (branch addition,  /***/ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (branch addition,  /***/ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) { Conditional (branch addition,  /***/ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep
public static String formatPeriod(long startMillis, long endMillis, String forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >= ga;  public boolean evaluateStep(final Interpolator interpolator)                      increasing = gb >=
protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair protected VectorialPointValuePair
public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of Method call parameter value modification,  /***/ public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of Method call parameter value modification,  /***/ public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of Method call parameter value modification,  /***/ public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of Method call parameter value modification,  /***/ public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of Method call parameter value modification,  /***/ public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of Method call parameter value modification,  /***/ public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(
public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } Method call parameter addition, Method call replacement, Return expression modification,  /***/ public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.
private double localMin(boolean isMinim,          double x = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }          double fv = fx;          double fw = fx;         int count = 0;         while (count < maximalIterationCount) {              double m = 0.5 * (a + b);              final double tol1 = eps * Math.abs(x) + t;              final double tol2 = 2 * tol1;          Assignment addition, Conditional (if-else) branches addition, Conditional expression modification, throw removal, Loop conditional expression modification, Method call addition, Method call parameter removal, Method call parameter value modification, Method call removal, Method call replacement, Method overriding addition or removal, Parameter removal from method definition, Method definition removal, Object instantiation removal, Return expression modification, Return statement removal, Variable addition, Variable removal, Variable replacement by method call,  private double localMin(boolean isMinim,          double x = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }          double fv = fx;          double fw = fx;         int count = 0;         while (count < maximalIterationCount) {              double m = 0.5 * (a + b);              final double tol1 = eps * Math.abs(x) + t;              final double tol2 = 2 * tol1;          Assignment addition, Conditional (if-else) branches addition, Conditional expression modification, throw removal, Loop conditional expression modification, Method call addition, Method call parameter removal, Method call parameter value modification, Method call removal, Method call replacement, Method overriding addition or removal, Parameter removal from method definition, Method definition removal, Object instantiation removal, Return expression modification, Return statement removal, Variable addition, Variable removal, Variable replacement by method call,  private double localMin(boolean isMinim,          double x = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification,  } } private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification,  } } private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio; Conditional expression modification,  } } private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio
public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  /***/ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  /***/ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  /***/ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  /***/ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  /***/ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           } Method call parameter addition, Method call replacement, Parameter addition in method definition, Object instantiation modification,  /***/ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";               }              new Reporter().smartNullPointerException(
public Complex conjugate() {      public Complex divide(Complex divisor)          throws NullArgumentException {          MathUtils.checkNotNull(divisor);          if (isNaN || divisor.isNaN) {              return NaN;          }         if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {             return NaN;          }          if (divisor.isInfinite() &&!isInfinite() {              return ZERO;          }          final double c = divisor.getReal();          final double d = divisor.getImaginary();          if (FastMath.abs(c) < FastMath.abs(d)) {              double q = c / d;              double denominator = c * q + d;              return createComplex((imaginary * q + real) / denominator,                  (imaginary * q - real) / denominator);          } else {              double q = d / c;              double denominator = d * q + c;              return createComplex((imaginary * q + real) / denominator,                  (imaginary - real * q) / denominator);          }      }            public Complex divide(double divisor) {          if (isNaN || Double.isNaN(divisor)) {              return NaN;          }          if (divisor == 0d) {             return NaN;          }          if (Double.isInfinite(divisor)) {              return!isInfinite()? ZERO : NaN;          }          return createComplex(real / divisor,                               imaginary  / divisor);      }      /**       * Test for the equality of two Complex objects.       * If both the real and imaginary parts of two complex numbers       * are exactly the same, and neither is {@code Double.NaN}, the two       * Complex objects are considered to be equal.       * All {@code NaN} values are considered to be equal - i.e, if either       * (or both) real and imaginary parts of the complex number are equal Assignment addition, Conditional (-else) branches addition, Conditional expression modification, Return expression modification, Variable addition,  /***/ public Complex conjugate() {      public Complex divide(Complex divisor)          throws NullArgumentException {          MathUtils.checkNotNull(divisor);          if (isNaN || divisor.isNaN) {              return NaN;          }         if (divisor.getReal() == 0.0 && divisor.getImaginary
private boolean shouldReportThis(Node n, Node parent      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;      }     return false;
public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  } static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  } static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  } static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  } static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  } static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional (if) branch addition, Conditional (if-) branches addition, throw addition, Method call addition, Object instantiation addition, Variable addition,  } static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; Assignment addition, Conditional
static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,  **/      static boolean isRegistered(Object value)         return getRegistry().contains(new IDKey(value));      /** Conditional (if) branch addition, Method call addition, Method overriding addition or removal, Method definition removal, Object instantiation modification, Return expression modification, Variable addition,
public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break; public void collect(Module module, Scope scope, Node n) {
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               } Conditional (branch addition,  /***/ protected void registerTypeVariablesOn(Type classType) {              if
