private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,      boolean ignoreStar) {      if (ignoreStar) {        return null;      }      if (builder.length() > 0) {        return builder.build();      }      return null;    } else {      return null;    }
public final boolean isNoType() { return false; }  public final boolean isNoResolvedType() { return false; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean isNoType() { return true; }  public final boolean isNoResolvedType() { return true; }  public final boolean isNumberObjectType() { return true; }  public final boolean
private int getRowIndex(Comparable rowKey) {         int index = 0;         for (int i = 0; i < rows.size(); i++) {             if (rows.get(i).equals(rowKey)) {                 index = i;                 break;             }         }         return index;     } }
private int[] indices = new int[]{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
public boolean apply(Node input) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private void renameNamespaceShadows(NodeTraversal t) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations, final boolean loop) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations, final boolean loop) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.0; }  public double integrate(final FirstOrderDifferentialEquations equations) { return 0.
public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          return bucket.parseInto(text, position);     }      public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          return bucket.parseInto(text, position);     }      public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          return bucket.parseInto(text, position);     }      public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          return bucket.parseInto(text, position);     }      public int parseInto(Instant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {     switch (value.getType()) {       case Token.TRUE:         return true;       case Token.FALSE:         return false;       case Token.NULL:         return null;       default:         return false;     }   }
private void visitParameterList(NodeTraversal t, Node n, FunctionType fnType) {      Node parameterList = IR.paramList().useSourceInfoFrom(constructor);      if (fnType!= null) {          parameterList.replaceChild(constructor, IR.name("").useSourceInfoFrom(constructor));      } else {          parameterList.replaceChild(constructor, IR.name("").useSourceInfoFrom(constructor));      }      parent.replaceChild(parent, parameterList);    }      private void ensureTyped(NodeTraversal t, Node n, JSType type) {      if (type!= null) {          parent.replaceChild(parent, IR.type(type).useSourceInfoFrom(parent));        } else {          parent.detachFromParent();        }    }
public RealMatrix getU()             if (m >= n) {                  final RealMatrix e =                      eigenDecomposition.getU().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                       final double[] wi  = wData[i];                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];                          }                 }                          for (int j = 0; j < p; ++j) {                             wi[j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];                          }                  for (int i = p; i < m; ++i) {                      wData[i] = new double[p];             }             return eigenDecomposition.getU();             }             else {             return null;             }           } else {           return null;           }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return null;         }         } else {           return
private UnivariatePointValuePair best(UnivariatePointValuePair current, UnivariatePointValuePair previous, boolean isMinim) {     if (isMinim) {       return current;     } else {       return previous;     }   } }
private class ReturnsEmptyValues implements Answer<Object> {           public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                    actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.valueFor(rawType);           }           return null;           }           }
private void interpretAssigns() {                  assign.assignNode.replaceChild(assign.assignNode.getFirstChild(), varNode);             }           if (assignedToUnknownValue &&!hasPropertyAssign) {              changes = markReferencedVar(var) || changes;             }           varNode.detachFromParent();           varNode.detachFromParent();           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode = null;           varNode
private CanInlineResult canInlineReferenceDirectly(Node callNode) {      Node parent = callNode.getParent();      Node newName = IR.name("").useSourceInfoFrom(callNode);      parent.replaceChild(callNode, newName);      return new CanInlineResult(parent, newName);     } else {      return new CanInlineResult(callNode, null);     }
private void inlineAliases(GlobalNamespace namespace) {             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR.var(name).useSourceInfoFrom(existingVarNode);             varNode.replaceChild(existingVarNode, varNode);             varNode = IR
public ElitisticListPopulation(final int populationLimit, final double elitismRate, final List<Chromosome> chromosomes) {          super(populationLimit);         this.elitismRate = elitismRate;         this.chromosomes = chromosomes;       }      /** @see java.lang.Object#equals(java.lang.Object) */      @Override public boolean equals(final java.lang.Object obj) {        if (this == obj) {           return true;        }        if (obj == null) {           return false;        }        if (getClass()!= obj.getClass()) {           return false;        }        final ElitisticListPopulation other = (ElitisticListPopulation) obj;       if (populationLimit!= other.populationLimit) {           return false;        }       if (elitismRate!= other.elitismRate) {           return false;        }       if (chromosomes == null) {           return false;        }       if (!chromosomes.equals(other.chromosomes)) {           return false;        }       return true;     }      /** @see java.lang.Object#hashCode() */      @Override public int hashCode() {        int result = super.hashCode();        result = 31 * result + (int) (elitismRate ^ (elitismRate >>> 32));        result = 31 * result + (chromosomes!= null? chromosomes.hashCode() : 0);        return result;     }      /** @see java.lang.Object#toString() */      @Override public String toString() {        return "ElitisticListPopulation [populationLimit=" + populationLimit + ", elitismRate=" + elitismRate + ", chromosomes=" + chromosomes + "]";      }
public void setRangeAxes(ValueAxis[] axes) {           this.rangeAxes.clear();           this.rangeAxes.addAll(Arrays.asList(axes));           if (parent!= null) {             parent.removeChild(this);           }           } else {           if (parent!= null) {             parent.removeChild(this);           }           }
public static Number createNumber(final String str) throws NumberFormatException {          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          }
public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';');              } else {                 writer.write(c);              }             }             else {             writer.write(c);             }           }           else {           writer.write(c);           }         }         else {           writer.write(c);         }         }         else {           writer.write(c);         }         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }         else {           writer.write(c);         }
private void findAliases(NodeTraversal t) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             existingName.replaceChild(existingName.getParent(), newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             scope.replaceChild(parent, varNode);             varNode.detachFromParent();           } else {             if (existingName!= null) {             existingName.detachFromParent();             }             varNode = parent;           }         } else {             if (existingName!= null) {             existingName.detachFromParent();             }             varNode = parent;           } else {             if (existingName!= null) {             existingName.detachFromParent();             }             varNode = parent;           }
private void setValue(boolean value) {            setter.setValue(value);          } else {            setter.setValue(null);          }
public double solve(final UnivariateRealFunction f, final double initial, final double yInitial, final double max, final double yMax, final double initial, final double yInitial) {     if (initial == yInitial) {       return initial;     }     if (initial < yInitial) {       return initial;     }     if (initial > yInitial) {       return initial;     }     if (max == yMax) {       return max;     }     if (max < yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if (max > yMax) {       return max;     }     if
private Node tryMinimizeIf(Node n) {             Node cond = IR.cond().useSourceInfoFrom(lhs).replaceChild(lhs, rhs);             Node assignName = IR.name("").useSourceInfoFrom(lhs);             varNode = IR.var(lhs).useSourceInfoFrom(lhs);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild(parent, varNode);             varNode.replaceChild
public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Throwable cause) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).withCause(cause).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).withCause(cause).withEnableSuppression(enableSuppression).withWritableStackTrace(writableStackTrace).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Object... args) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).withArguments(args).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Object... args, boolean enableSuppression, boolean writableStackTrace) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).withArguments(args).withEnableSuppression(enableSuppression).withWritableStackTrace(writableStackTrace).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Object... args, Throwable cause) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).withArguments(args).withCause(cause).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Object... args, boolean enableSuppression, boolean writableStackTrace) { return reportMatcher(new InstanceOf(clazz)).withMessage(message).withArguments(args).withEnableSuppression(enableSuppression).withWritableStackTrace(writableStackTrace).<T>returnNull(); }  public static <T> T isA(Class<T> clazz, String message, Object... args, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { return reportMatcher(new
private Object createCopy(int start, int end) {           Object clone = super.clone();           clone.setItem(start, null);           clone.setItem(end, null);           return clone;       }
public Fraction multiply(final int i) { return Fraction.valueOf(value * i); }  public Fraction divide(final double d) { return Fraction.valueOf(value / d); }  public Fraction divide(final float f) { return Fraction.valueOf(value / f); }  public Fraction divide(final long l) { return Fraction.valueOf(value / l); }  public Fraction divide(final double d, final int i) { return Fraction.valueOf(value / d * i); }  public Fraction divide(final float f, final int i) { return Fraction.valueOf(value / f * i); }  public Fraction divide(final long l, final int i) { return Fraction.valueOf(value / l * i); }  public Fraction divide(final double d) { return Fraction.valueOf(value / d); }  public Fraction divide(final float f) { return Fraction.valueOf(value / f); }  public Fraction divide(final long l) { return Fraction.valueOf(value / l); }  public Fraction divide(final double d, final int i) { return Fraction.valueOf(value / d * i); }  public Fraction divide(final float f, final int i) { return Fraction.valueOf(value / f * i); }  public Fraction divide(final long l) { return Fraction.valueOf(value / l); }  public Fraction divide(final double d) { return Fraction.valueOf(value / d); }  public Fraction divide(final float f) { return Fraction.valueOf(value / f); }  public Fraction divide(final long l) { return Fraction.valueOf(value / l); }  public Fraction divide(final double d, final int i) { return Fraction.valueOf(value / d * i); }  public Fraction divide(final float f, final int i) { return Fraction.valueOf(value / f * i); }  public Fraction divide(final long l) { return Fraction.valueOf(value / l); }  public Fraction divide(final double d) { return Fraction.valueOf(value / d); }  public Fraction divide(final float f
public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, long val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, float val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, double val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, boolean val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, char val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, byte val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, short val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;               case 0:                  return 0L;             }             return val1 * val2;           }           public static long safeMultiply(
public static <T> T[] copyArrayGrow1(T[] array, Class<T> type) {             T[] newArray = (T[]) Array.newInstance(type, array.length + 1);             System.arraycopy(array, 0, newArray, 0, array.length);             return newArray;           } else {             return array;           }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {           super.writeTo(out);           out.writeInt(this.data.size());           for (int index = 0; index < this.data.size(); index++) {               out.writeObject(this.data.get(index));           }           }             private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {           super.readFrom(in);           int size = in.readInt();           this.data = new java.util.ArrayList<Object>(size);           for (int index = 0; index < size; index++) {               this.data.add(in.readObject());           }           }             private static final long serialVersionUID = 1L;           }
private Node tryFoldComparison(Node n, Node left, Node right) {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replaceChild(right, IR.name("").useSourceInfoFrom(right));             }             return result;           } else {             Node result = IR.name("").useSourceInfoFrom(left);             if (NodeUtil.isLiteralValue(right.getFirstChild(), false)) {             result.replace
private void unrollBinaryOperator(      Node current = firstNonOperator) {      Node newParent = IR.name("").useSourceInfoFrom(parent);      parent.replaceChild(parent, newParent);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom(parent);      parent.replaceChild(parent, varNode);      varNode = IR.var(parent).useSourceInfoFrom
public long subtract(long instant, long value) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.subtract(localInstant, value);             return iZone.convertLocalToUTC(localInstant, false);           }           public long multiply(long instant, long value) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.multiply(localInstant, value);             return iZone.convertLocalToUTC(localInstant, false);           }           public long divide(long instant, long value) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.divide(localInstant, value);             return iZone.convertLocalToUTC(localInstant, false);           }           public long round(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.round(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }           public long floor(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.floor(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }           public long ceil(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.ceil(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }           public long abs(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.abs(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }           public long roundUp(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.roundUp(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }           public long roundDown(long instant) {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.roundDown(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }           public boolean equals(Object obj) {
public long subtract(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.subtract(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          }
public static Number createNumber(String str, int decPos, int expPos) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str.substring(decPos + 1, expPos);               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = str;               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                   }                  dec = "";               }          }          else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");               }              else {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number."
public void setSeriesKeys(Comparable[] seriesKeys) { this.seriesKeys = seriesKeys; }  public void setCategoryKeys(Comparable[] categoryKeys) { this.categoryKeys = categoryKeys; }  public Comparable[] getSeriesKeys() { return seriesKeys; }  public Comparable[] getCategoryKeys() { return categoryKeys; } }
private boolean isInlinableObject(List<Reference> refs) {     if (refs.isEmpty()) {       return true;     }     if (refs.size() == 1) {       return false;     }     if (refs.get(0).isName()) {       return false;     }     return isInlinableObject(refs.subList(1, refs.size()));   }    private boolean isInlinableObject(List<Reference> refs) {     if (refs.isEmpty()) {       return true;     }     if (refs.size() == 1) {       return false;     }     if (refs.get(0).isName()) {       return false;     }     return isInlinableObject(refs.subList(1, refs.size()));   } }
private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, Map<TypeVariable<?>, Type> typeVarAssigns) {             for (Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());             if (isAssignable(fromTypeArg, toTypeArg)) {             return true;             }             }             return false;           }
private static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) {             if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }             if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }             int offset = 0;             try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }             } catch (ArithmeticException e) {             }             return DateTimeZone.forOffsetHoursMinutes(offset, minutesOffset);           }
protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);             }             else {                  setSize(Double.NEGATIVE_INFINITY);                  setBarycenter(Vector2D.NaN);             }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {           }           }           else {           if ((Boolean) tree.getAttribute()) {           }           else {
private static synchronized String getConvertedId(String id) {              if (map == null) {              map = new HashMap<String, String>();              }              if (!map.containsKey(id)) {              map.put(id, id);              }              return map.get(id);             }
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          }        }        return true;    }
protected PointVectorValuePair doOptimize() {                      if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                         }                         else {                              return null;                         }                       }                       else {                       return null;                       }                               } else {                               return null;               }             } else {                               return null;             }           } else {                               return null;           }         } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else {                               return null;           }       } else
private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          if (parent!= null) {            if (parent.isName()) {              Node newName = IR.name("").useSourceInfoFrom(parent);              parent.replaceChild(parent, newName);            } else {               parent.detachFromParent();             }          } else {            if (parent!= null) {              parent.detachFromParent();            }          }          ret = true;        }        return ret;      }
void tryMinimizeExits(Node n, int exitType, String labelName) {         Node newName = IR.name("").useSourceInfoFrom(existingName);             existingName.replaceChild(existingName.getParent(), newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             varNode.replaceChild(parent, varNode);             parent.replaceChild(child, varNode);             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode.detachFromParent();             varNode
public void setHourOfHour(final int hourOfHour) {              setMillis(getChronology().hours().add(getMillis(), hourOfHour));      }  public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      }  public void addDays(final int days) {              setMillis(getChronology().days().add(getMillis(), days));      }  public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }  public void addMonths(final int months) {              setMillis(getChronology().months().add(getMillis(), months));      }  public void addYears(final int years) {              setMillis(getChronology().years().add(getMillis(), years));      }  public void addNanos(final long nanos) {              setMillis(getChronology().nanos().add(getMillis(), nanos));      }  public void addSeconds(final int seconds) {              setMillis(getChronology().seconds().add(getMillis(), seconds));      }  public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      }  public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      }  public void addDays(final int days) {              setMillis(getChronology().days().add(getMillis(), days));      }  public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }  public void addMonths(final int months) {              setMillis(getChronology().months().add(getMillis(), months));      }  public void addYears(final int years) {              setMillis(getChronology().years().add(getMillis(), years));      }  public void addNanos(final long nanos) {              setMillis(getChronology().nanos().add(getMillis(), nanos));      }  public void addSeconds(final int seconds) {              setMillis(getChronology().seconds().add(getMillis(), seconds));      }  public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      }  public void addHours(
private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);              }          }          return injectionOccurred;        }
public void setExtraInterfaces(java.util.Collection<Class> extraInterfaces) {          this.extraInterfaces = extraInterfaces;       }       public java.util.Collection<Class> getExtraInterfaces() {          return java.util.Collections.unmodifiableCollection(extraInterfaces);       }       public void setDefaultAnswer(Answer defaultAnswer) {          this.defaultAnswer = defaultAnswer;       }       public Answer getDefaultAnswer() {          return defaultAnswer;       }       public void initiateMockName(Class classToMock) {          this.classToMock = classToMock;       }       public Class getClassToMock() {          return classToMock;       }       public void setExtraInterfaces(java.util.Collection<Class> extraInterfaces) {          this.extraInterfaces = extraInterfaces;       }       public java.util.Collection<Class> getExtraInterfaces() {          return java.util.Collections.unmodifiableCollection(extraInterfaces);       }       public void setDefaultAnswer(Answer defaultAnswer) {          this.defaultAnswer = defaultAnswer;       }       public Answer getDefaultAnswer() {          return defaultAnswer;       }       public void setMockClass(Class mockClass) {          this.mockClass = mockClass;       }       public Class getMockClass() {          return mockClass;       }       public void setExtraInterfaces(java.util.Collection<Class> extraInterfaces) {          this.extraInterfaces = extraInterfaces;       }       public java.util.Collection<Class> getExtraInterfaces() {          return java.util.Collections.unmodifiableCollection(extraInterfaces);       }       public void setDefaultAnswer(Answer defaultAnswer) {          this.defaultAnswer = defaultAnswer;       }       public Answer getDefaultAnswer() {          return defaultAnswer;       }       public void setMockClass(Class mockClass) {          this.mockClass = mockClass;       }       public void setExtraInterfaces(java.util.Collection<Class> extraInterfaces) {          this.extraInterfaces = extraInterfaces;       }       public java.util.Collection<Class> getExtraInterfaces() {          return java.util.Collections.unmodifiableCollection(extraInterfaces);       }       public void setDefaultAnswer(Answer defaultAnswer) {          this.defaultAnswer = defaultAnswer;       }       public Answer getDefaultAnswer() {          return defaultAnswer;       }       public void setMockClass(Class mockClass) {          this.mockClass = mockClass
protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(iter, previous, current)) {                         return current;                   }                  }                  return null;             }
public void setUnitMillis(long unitMillis) {         this.unitMillis = unitMillis;         }         public long getUnitMillis() {         return unitMillis;         }         public void setUnitMillis(long unitMillis) {         this.unitMillis = unitMillis;         }         public int compareTo(DurationField other) {         if (other == null) {             return 1;           }           if (this == other) {             return 0;           }           if (this.unitMillis < other.unitMillis) {             return -1;           }           if (this.unitMillis > other.unitMillis) {             return 1;           }           return 0;         }
public Vector2D intersection(final SubLine subLine) { return intersection(subLine, false); }  public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin) { return line1.intersection(line2, includeEndPoin); }  public Vector2D intersection(final Line2D line) { return line1.intersection(line); }  public Vector2D intersection(final Line2D line, final boolean includeEndPoin) { return line1.intersection(line, includeEndPoin); }  public Vector2D intersection(final Line2D line1, final Line2D line2) { return line1.intersection(line2); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final boolean includeEndPoin) { return line1.intersection(line2, includeEndPoin); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final Line2D line3) { return line1.intersection(line2, line3); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final Line2D line3, final boolean includeEndPoin) { return line1.intersection(line2, line3, includeEndPoin); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final Line2D line3, final Line2D line4) { return line1.intersection(line2, line3, line4); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final Line2D line3, final Line2D line4, final boolean includeEndPoin) { return line1.intersection(line2, line3, line4, includeEndPoin); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final Line2D line3, final Line2D line4, final Line2D line5) { return line1.intersection(line2, line3, line4, line5); }  public Vector2D intersection(final Line2D line1, final Line2D line2, final Line2D line3, final Line2D line4, final Line2D line5, final boolean
private void canInline(Node node) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
public boolean setPrototype(ObjectType prototype) {        return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor();      }
public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    }     public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(finallyBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);    }     public static Node tryFinally(Node tryBody) {      Preconditions.checkState(tryBody.isBlock());     Node finallyBody = block(null).copyInformationFrom(null);     return new Node(Token.TRY, tryBody, finallyBody);    }     public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);    }     public static Node tryFinally(Node tryBody) {      Preconditions.checkState(tryBody.isBlock());     Node finallyBody = block(null).copyInformationFrom(null);     return new Node(Token.TRY, tryBody, finallyBody);    }     public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);    }     public static Node tryFinally(Node tryBody) {      Preconditions.checkState(tryBody.isBlock());     Node finallyBody = block(null).copyInformationFrom(null);     return new Node(Token.TRY, tryBody, finallyBody);    }     public static Node tryFinally(Node tryBody, Node finallyBody) {      Preconditions.checkState(tryBody.isBlock());     Node finallyBody = block(finallyBody).copyInformationFrom(finallyBody);     return new Node(Token.TRY, tryBody, finallyBody);    }
private double[] decode(final double[] x) {             double[] y = new double[x.length];             for (int i = 0; i < x.length; i++) {             y[i] = x[i];             }             return y;           }
private void setPeriod(int iPeriod) {     this.iPeriod = iPeriod;   }    public int getPeriod() {     return iPeriod;   }    public void setPeriod(int iPeriod) {     this.iPeriod = iPeriod;   }    @Override   public int hashCode() {     final int prime = 31;     int result = 1;     result = prime * result + iPeriod;     return result;   }    @Override   public boolean equals(Object obj) {     if (this == obj) {       return true;     }     if (obj == null) {       return false;     }     if (getClass()!= obj.getClass()) {       return false;     }     Period other = (Period) obj;     if (iPeriod!= other.iPeriod) {       return false;     }     return true;   }    @Override   public String toString() {     return "Period{" + "iPeriod=" + iPeriod + '}';   } }
private static void escapeJavaStyleString(Writer out, String str, boolean isEscaped) throws IOException {         if (str == null) {             return;         }         char[] chars = str.toCharArray();         for (int i = 0; i < chars.length; i++) {             char c = chars[i];             switch (c) {                 case '\\':                     out.write('\\');                     break;                 case '\n':                     out.write('\n');                     break;                 case '\r':                     out.write('\r');                     break;                 case '\t':                     out.write('\t');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\f':                     out.write('\f');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\f':                     out.write('\f');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\n':                     out.write('\n');                     break;                 case '\r':                     out.write('\r');                     break;                 case '\t':                     out.write('\t');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\f':                     out.write('\f');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\f':                     out.write('\f');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\n':                     out.write('\n');                     break;                 case '\r':                     out.write('\r');                     break;                 case '\t':                     out.write('\t');                     break;                 case '\b':                     out.write('\b');                     break;                 case '\f':                     out.write('\f');                     break;                 case '\b':                     out.write('
void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } return;      } void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } return;      } void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } return;      } void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } return;      } void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } return;      } void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        } return;      } void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc
public static double sinh(double x) {         return Math.sin(x);       }      public static double cosh(double x) {         return Math.cos(x);       }      public static double tanh(double x) {         return Math.tan(x);       }      public static double asin(double x) {         return Math.asin(x);       }      public static double acos(double x) {         return Math.acos(x);       }      public static double atan(double x) {         return Math.atan(x);       }      public static double atan2(double y, double x) {         return Math.atan2(y, x);       }      public static double atanh(double x) {         return Math.atanh(x);       }      public static double exp(double x) {         return Math.exp(x);       }      public static double log(double x) {         return Math.log(x);       }      public static double expm1(double x) {         return Math.expm1(x);       }      public static double log1p(double x) {         return Math.log1p(x);       }      public static double log10(double x) {         return Math.log10(x);       }      public static double log2(double x) {         return Math.log2(x);       }      public static double log10p(double x) {         return Math.log10p(x);       }      public static double pow(double x, double y) {         return Math.pow(x, y);       }      public static double sqrt(double x) {         return Math.sqrt(x);       }      public static double tan(double x) {         return Math.tan(x);       }      public static double asinh(double x) {         return Math.asinh(x);       }      public static double acosh(double x) {         return Math.acosh(x);       }      public static double atanh(double x) {         return Math.atanh(x);       }      public static double atan2(double y, double x) {         return Math.atan2(y, x);       }      public static double atanh(double x) {
public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':" + undesired.getLocation()          ));      }
private void setEquals(boolean value) {             this.isEquals = value;           }             @Override public boolean equals(Object obj) {             if (this == obj) {               return true;             }             if (obj == null) {               return false;             }             if (getClass()!= obj.getClass()) {           return false;           }           return super.equals(obj);         }
void apply(Node nameNode) {        this.nameNode = nameNode;       this.isPropertyAssign = isPropertyAssign;       this.maybeAliased =!assignNode.getParent().isExprResult();       this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }
public void setHourOfDay(final int hourOfDay) {             setMillis(getChronology().hours().add(getMillis(), hourOfDay));             }             public void addHours(final int hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final long hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final double hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final float hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final int hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final long hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final double hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final float hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final int hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final long hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final double hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final float hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final int hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final long hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final double hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final float hours) {             setMillis(getChronology().hours().add(getMillis(), hours));             }             public void addHours(final int hours) {             setMillis(
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, bool inferred) {    Node newName = IR.name("").useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    existingName = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);    if (existingName!= null) {      existingName.detachFromParent();    }    varNode = IR.var(existingName).useSourceInfoFrom(existingName);
