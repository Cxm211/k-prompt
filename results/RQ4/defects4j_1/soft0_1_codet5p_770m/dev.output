public int translate(CharSequence input, int index, Writer out) throws IOExcepti {              return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex? 1 : 0) + 1;          }
protected final double computeObjectiveValue(double x0) {             return 0.0;             }             }
public static boolean isPrimitiveWrapper(Class<?> type) {          if (primitiveValues.containsKey(type)) {             return true;           }           else {             primitiveValues.put(type, 0);             return false;           }       }   } \ No newline at end of file
public ElitisticListPopulation(final List<Chromosome> chromosomes,                                      final int populationLimit) {          super(chromosomes, populationLimit);         this.elitismRate = 1.0;         }      /** {@inheritDoc} */      public double getElitismRate() {          return elitismRate;          }      /** {@inheritDoc} */      public void setElitismRate(final double elitismRate) {          this.elitismRate = elitismRate;          }      /** {@inheritDoc} */      public List<Chromosome> getChromosomes() {          return chromosomes;          }      /** {@inheritDoc} */      public void setChromosomes(final List<Chromosome> chromosomes) {          this.chromosomes = chromosomes;          }      /** {@inheritDoc} */      public int getPopulationLimit() {          return populationLimit;          }      /** {@inheritDoc} */      public void setPopulationLimit(final int populationLimit) {          this.populationLimit = populationLimit;          }      /** {@inheritDoc} */      @Override public String toString() {          return "ElitisticListPopulation{" +              "chromosomes=" + chromosomes +              ", populationLimit=" + populationLimit +              ", elitismRate=" + elitismRate +              '}';          }
private boolean safelyMatches(Matcher m, Object arg) {             if (arg == null) {               return false;             }             return m.matches(arg.toString());           }       private boolean toStringEquals(Matcher m, Object arg) {             if (arg == null) {               return false;             }             return m.matches(arg.toString());           }
);              }              return result;           }          public int get(long instant) {              long localInstant = iZone.convertUTCToLocal(instant);              return iField.get(localInstant);           }          public int get(long instant, int defaultValue) {              long localInstant = iZone.convertUTCToLocal(instant);              return iField.get(localInstant, defaultValue);           }          public void set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value);           }          public void set(long instant, int value, ZoneId zone) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value, zone);           }          public void set(long instant, int value, ZoneOffset offset) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value, offset);           }          public void set(long instant, int value, ZoneOffset offset, ZoneId zone) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value, offset, zone);           }          public void set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value);           }          public void set(long instant, int value, ZoneOffset offset, ZoneId zone) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value, offset, zone);           }          public void set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value);           }          public void set(long instant, int value, ZoneOffset offset) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value, offset);           }          public void set(long instant, int value, ZoneOffset offset, ZoneId zone) {              long localInstant = iZone.convertUTCToLocal(instant);              iField.set(localInstant, value, offset, zone);           }          public void set(long instant, int value
public void printTo(StringBuffer buf) {              if (iPrefix!= null) {                  iPrefix.printTo(buf);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }             }
private static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff) {             if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) {             return DateTimeZone.UTC;          }          return DateTimeZone.forOffsetHoursMinutes(offset);        }          private static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff) {             if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) {             return DateTimeZone.UTC;          }          return DateTimeZone.forOffsetHoursMinutes(offset);        }          private static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff) {             if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(
public static Number createNumber(String str) throws NumberFormatException {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(0, decPos);              } else {                  mant = str;              }          } else {              if (decPos > -1) {                  mant = str.substring(
public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone) { this(time, zone, Locale.getDefault()); } public Week(Date time, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone) { this(time, zone, Locale.getDefault()); } public Week(Date time, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale); } public Week(Date time) { this(time, RegularTimePeriod.DEFAULT_TIME_ZONE); } public Week(Date time, TimeZone zone, Locale locale) { this(time, RegularTimePeriod.
private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator(    private void unrollBinaryOperator
public static String formatPeriod(long startMillis, long endMillis) { return formatPeriod(startMillis, endMillis, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma) { return formatPeriod(startMillis, endMillis, forma, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator) { return formatPeriod(startMillis, endMillis, forma, separator, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator, String separator2) { return formatPeriod(startMillis, endMillis, forma, separator, separator2, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator, String separator2, String separator3) { return formatPeriod(startMillis, endMillis, forma, separator, separator2, separator3, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator, String separator2, String separator3, String separator4) { return formatPeriod(startMillis, endMillis, forma, separator, separator2, separator3, separator4, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator, String separator2, String separator3, String separator4, String separator5) { return formatPeriod(startMillis, endMillis, forma, separator, separator2, separator3, separator4, separator5, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator, String separator2, String separator3, String separator4, String separator5, String separator6) { return formatPeriod(startMillis, endMillis, forma, separator, separator2, separator3, separator4, separator5, separator6, null); }  public static String formatPeriod(long startMillis, long endMillis, String forma, String separator, String separator2, String separator3, String separator4, String separator5, String separator6, String separator7) { return formatPeriod(startMillis, endMillis, forma, separator, separator2, separator3, separator4, separator5, separator6, separator7, null); }  public static String formatPeriod(long startMillis, long
public void setValue(double value) {          secondMoment.setValue(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.setValue(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.setValue(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.setValue(value);          }          n++;         }      public double getValue() {          return secondMoment.getValue();         }      public void setValue(double value) {          secondMoment.setValue(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.setValue(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.setValue(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.setValue(value);          }          n++;         }      public double getMean() {          return meanImpl.getValue();         }      public void setMean(double value) {          meanImpl.setValue(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.setValue(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.setValue(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.setValue(value);          }          n++;         }      public double getVariance() {          return varianceImpl.getValue();         }      public void setVariance(double value) {          varianceImpl.setValue(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.setValue(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.setValue(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.setValue(value);          }          n++;         }      public double getGeoMean() {          return geoMeanImpl.getValue();         }      public void setGeoMean(double value) {          geoMeanImpl.setValue(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.setValue(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.
protected double solve() {              double targetY = 0;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0;              }              return targetY;           }
public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      } public void setWeekOfYear(final int weekOfYear) {              setMillis(getChronology().weeks().add(getMillis(), weekOfYear));      } public void addWeekOfYear(final int weekOfYear) {              setMillis(getChronology().weeks().add(getMillis(), weekOfYear));      } public void addMonths(final int months) {              setMillis(getChronology().months().add(getMillis(), months));      } public void addMonths(final int months) {              setMillis(getChronology().months().add(getMillis(), months));      } public void addYears(final int years) {              setMillis(getChronology().years().add(getMillis(), years));      } public void addYears(final int years) {              setMillis(getChronology().years().add(getMillis(), years));      } public void addDays(final int days) {              setMillis(getChronology().days().add(getMillis(), days));      } public void addDays(final int days) {              setMillis(getChronology().days().add(getMillis(), days));      } public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } public void addSeconds(final int seconds) {              setMillis(getChronology().seconds().add(getMillis(), seconds));      } public void addSeconds(final int seconds) {              setMillis(getChronology().seconds().add(getMillis(), seconds));      } public void addMilliseconds(final int milliseconds) {              setMillis(getChronology().milliseconds().add(getMillis(), milliseconds));      } public void addMilliseconds(final int milliseconds) {              setMillis(getChronology().milliseconds().add(getMillis(), milliseconds));      } public void add
private VectorialPointValuePair maxCosine = new VectorialPointValuePair(0.0, 0.0); } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));             } else {             double sum = 0;             for (int i = 0; i <= j; ++i) {             sum += jacobian[i][pj] * residuals[i];             }             maxCosine = Math.max(maxCosine, Math.
(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;    }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {       this(duration, endInstant, null);    }     protected BasePeriod(ReadableDuration duration) {       this(duration, null, null);    }     protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant) {       this(duration, endInstant, null);    }     protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri peri) {       this.duration = duration;       this.endInstant = endInstant;       this.peri = peri;    }     public ReadableDuration getDuration() {       return duration;    }     public void setDuration(ReadableDuration duration) {       this.duration = duration;    }     public ReadableInstant getEndInstant() {       return endInstant;    }     public void setEndInstant(ReadableInstant endInstant) {       this.endInstant = endInstant;    }     public Peri getPeri() {       return peri;    }     public void setPeri(Peri peri) {       this.peri = peri;    }     @Override public boolean equals(Object o) {       if (this == o) {          return true;       }       if (o == null || getClass()!= o.getClass()) {          return false;       }        BasePeriod that = (BasePeriod) o;        if (duration!= null?!duration.equals(that.duration) : that.duration!= null) {          return false;       }       if (endInstant!= null?!endInstant.equals(that.endInstant) : that.endInstant!= null) {          return false;       }       if (peri!= null?!peri.equals(that.peri) : that.peri!= null) {          return false;       }        return true;    }     @Override public int hashCode() {       int result = duration!= null? duration.hashCode() : 0;       result = 31 * result + (endInstant!= null? endInstant.hashCode() : 0);       result =
private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>
public LegendItemCollection getLegendItems() {           LegendItemCollection result = new LegendItemCollection();           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset!= null) {               result.addAll(dataset.getLegendItems());           }           return result;         }
public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.charAt(input, pos));              }      }
public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          } return FastMath.pow(2 * FastMath.PI, -dim / 2) *               FastMath.pow(covarianceMatrixDeterminant, -0.5) *               getExponentTerm(vals);      }
private int indexOf(String str, int startIndex) {             int strLen = str.length();             char[] thisBuf = buffer;             int len = thisBuf.length - strLen;             outer:             for (int i = startIndex; i < len; i++) {               if (str.charAt(i) == thisBuf[i]) {                 return i;               }             }             return -1;           }
Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.management() && options.closurePass) {          for (CompilerInput input : inputs) {             if (input.getParent()!= null) {               node.replaceChild(input, input.getParent());             }             else {               node.detachFromParent();             }           }           else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return null;           }       } else {           if (node!= null) {             node.detachFromParent();           }           else {           return
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu) {             Object container = invocation.getArgumentAt(0, Object.class);             if (container == null) {             return null;             }             else {             return container;             }           } else {             if (container!= null) {             return container;           }           else {             return null;           }           }
private static Object[] createComposite(List<Object> elementPairs) {          Object[] comp = new Object[elementPairs.size()];          for (int i = 0; i < elementPairs.size(); i++) {              comp[i] = elementPairs.get(i);          }          return comp;          }          private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                   PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = new Object[elementPairs.size()];          for (int i = 0; i < elementPairs.size(); i++) {              comp[i] = elementPairs.get(i);          }          return new PeriodFormatter(comp);          }
public static void main(String[] args) {             Calendar cal1 = Calendar.getInstance();             Calendar cal2 = Calendar.getInstance();             Calendar cal3 = Calendar.getInstance();             Calendar cal4 = Calendar.getInstance();             Calendar cal5 = Calendar.getInstance();             Calendar cal6 = Calendar.getInstance();             Calendar cal7 = Calendar.getInstance();             Calendar cal8 = Calendar.getInstance();             Calendar cal9 = Calendar.getInstance();             Calendar cal10 = Calendar.getInstance();             Calendar cal11 = Calendar.getInstance();             Calendar cal12 = Calendar.getInstance();             Calendar cal13 = Calendar.getInstance();             Calendar cal14 = Calendar.getInstance();             Calendar cal15 = Calendar.getInstance();             Calendar cal16 = Calendar.getInstance();             Calendar cal17 = Calendar.getInstance();             Calendar cal18 = Calendar.getInstance();             Calendar cal19 = Calendar.getInstance();             Calendar cal20 = Calendar.getInstance();             Calendar cal21 = Calendar.getInstance();             Calendar cal22 = Calendar.getInstance();             Calendar cal23 = Calendar.getInstance();             Calendar cal24 = Calendar.getInstance();             Calendar cal25 = Calendar.getInstance();             Calendar cal26 = Calendar.getInstance();             Calendar cal27 = Calendar.getInstance();             Calendar cal28 = Calendar.getInstance();             Calendar cal29 = Calendar.getInstance();             Calendar cal30 = Calendar.getInstance();             Calendar cal31 = Calendar.getInstance();             Calendar cal32 = Calendar.getInstance();             Calendar cal33 = Calendar.getInstance();             Calendar cal34 = Calendar.getInstance();             Calendar cal35 = Calendar.getInstance();             Calendar cal36 = Calendar.getInstance();             Calendar cal37 = Calendar.getInstance();             Calendar cal38 = Calendar.getInstance();             Calendar cal39 = Calendar.getInstance();             Calendar cal40 = Calendar.getInstance();             Calendar cal41 = Calendar.getInstance();             Calendar cal42 = Calendar.getInstance();             Calendar cal43 = Calendar.getInstance();             Calendar cal44 = Calendar.getInstance();             Calendar cal45 = Calendar.getInstance();             Calendar cal46 = Calendar.getInstance();             Calendar cal47 = Calendar.getInstance();             Calendar cal48 = Calendar.getInstance();             Calendar cal49 = Calendar.getInstance();             Calendar cal50 = Calendar.getInstance();
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             value.replaceChild(parent, varNode);             parent.replaceChild(child, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private double localMin(boolean isMinim,          double x,          double d,          double e) {         double fx = computeObjectiveValue(f, x);         if (goalType == GoalType.MAXIMIZE) {              fx = -fx;          }          double fv = fx;          double fw = fx;         int count = 0;         while (count < maximalIterationCount) {              double m = 0.5 * (a + b);              final double tol1 = eps * Math.abs(x) + t;              final double tol2 = 2 * tol1;             }             return Math.min(fv, fw);           }
public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                 case Token.VAR:                  isSet = true;                  type = Name.Type.VAR;                  break;                 case Token.LET:                  isSet = true;                  type = Name.Type.LET;                  break;                 case Token.CONST:               isSet = true;               type = Name.Type.CONST;               break;                 case Token.THIS:               isSet = true;               type = Name.Type.THIS;               break;                 case Token.LET:               isSet = true;               type = Name.Type.LET;               break;                 case Token.CONST:               isSet = true;               type = Name.Type.CONST;               break;                 case Token.THIS:               isSet = true;               type = Name.Type.THIS;               break;                 case Token.LET:               isSet = true;               type = Name.Type.LET;               break;                 case Token.CONST:               isSet = true;               type = Name.Type.CONST;               break;                 case Token.THIS:               isSet = true;               type = Name.Type.THIS;               break;                 case Token.LET:               isSet = true;               type = Name.Type.LET;               break;                 case Token.CONST:               isSet = true;               type = Name.Type.CONST;               break;                 case Token.THIS:               isSet = true;               type = Name.Type.THIS;               break;                 case Token.LET:               isSet = true;               type = Name.Type.LET;               break;                 case Token.CONST:               isSet = true;               type = Name.Type.CONST;               break;                 case Token.THIS:               isSet = true;               type = Name.Type.THIS;               break;                 case Token.LET:               isSet = true;               type = Name.Type.LET;               break;                 case Token.CONST:               isSet = true;               type = Name.Type.CONST;               break;                 case Token.THIS:               isSet = true;               type = Name.Type.THIS;               break;                 case Token.LET:               isSet =
private boolean isChainedPropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;        }        return isChainedProperty;    }
Node processArrayLiteral(ArrayLiteral literalNode) {     Node newArray = IR.arrayExpr(null).useSourceInfoFrom(literalNode);     return IR.assign(literalNode, newArray).useSourceInfoFrom(literalNode);   }    private Node processInfixExpression(Node infix) {     if (infix == null) {       return null;     }     if (infix.isName()) {       return IR.name("").useSourceInfoFrom(infix);     } else {       return infix;     }   } }
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right!= null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;       }      }      return null;   }
private class AliasedTypeNode extends Node {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void apply(NodeTraversal t) {       Node newName = IR.name("").useSourceInfoFrom(typeReference);       parent.replaceChild(parent, newName);       varNode = IR.var(parent).useSourceInfoFrom(parent);       parent.replaceChild(parent, varNode);       varNode.detachFromParent();       varNode.replaceChild(parent, varNode);       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       varNode.detachFromParent();       var
protected void dropPhase2Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          }
public class Timer {     public static void main(String[] args) {         Timer timer = new Timer();         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.println(timer);         System.out.
private boolean shouldReportThis(Node n, Node parent) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);             return true;           } else {             value.detachFromParent();             varNode.detachFromParent();             return false;           }
private Node parseFunctionType(JsDocToken token) {      Node newName = IR.name("").useSourceInfoFrom(existingName);      varNode = IR.var(existingName).useSourceInfoFrom(existingName);      varNode.detachFromParent();      varNode.replaceChild(existingName, varNode);      return IR.var(existingName).useSourceInfoFrom(existingName);    } else {      return existingName;    }
private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new Complex(real, imaginary);       }            private Complex createComplex(double real, double imaginary) {           return new
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0)              {                  best = contracted;              }             }             else             {             }             }             else             {             }             }             else             {             }             }             else             {             }             }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }           else           {           }           }
private double[][] getCovariances(EstimationProblem problem) {         double[][] covariances = new double[problem.getAllParameters().length][problem.getMeasurements().length];         for (int i = 0; i < problem.getAllParameters().length; ++i) {             covariances[i] = new double[problem.getMeasurements().length];             for (int j = 0; j < problem.getMeasurements().length; ++j) {             covariances[i][j] = problem.getMeasurements()[j];             }             }             return covariances;           }
public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr) {             return "SmartNull returned by unstubbed " + formatMethodCall() + " method on mock";           }             new Reporter().smartNullPointerException(location);           return null;           }
public static synchronized GJChronology getInstance(Instant cutoverInstant) {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {             return gregorianCutover.withInstant(cutoverInstant);             }           } else {             if (cutoverInstant == null) {             return DEFAULT_CUTOVER;             }             else {
private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer<Object>() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }           });           return mock;           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else {           return null;           }           } else
public long roundFloor(long instant) {             return iField.roundFloor(instant);           } else {             long localInstant = iZone.convertUTCToLocal(instant);             localInstant = iField.roundFloor(localInstant);             return iZone.convertLocalToUTC(localInstant, false);           }
public boolean evaluateStep(final StepInterpolator interpolator) {             boolean increasing = gb >= ga;             if (parent!= null) {               parent.removeChild(this);             }             if (child!= null) {               child.detachFromParent();             }             if (parent!= null) {               parent.replaceChild(this, parent);             }             if (child!= null) {               child.detachFromParent();             }             return increasing;           }
private void visitSetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (n.getJSType()!= null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);      } }
private static int greatestCommonDivisor(int u, int v) {             if (u == v) {                 return 1;             }             else if (u > v) {               return greatestCommonDivisor(u - 1, v);             }             else {               return greatestCommonDivisor(u + 1, v);             }           }
static void register(Object value) {             Registry.getRegistry().register(new IDKey(value));           }         static void unregister(Object value) {             Registry.getRegistry().unregister(new IDKey(value));           }
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()         .setOriginalFile(sources[entry.getSourceFileId()])        .setLineNumber(entry.getSourceLine())        .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId()!= UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();    }
private String normalizeSourceName(String filename) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private void inlineNonConstants(Node v) {             Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
void addIdentifier(String identifier) {     if (identifier == null) {       return;     }     if (identifier.equals("")) {       return;     }     if (identifier.equals("null")) {       return;     }     if (identifier.equals("false")) {       return;     }     if (identifier.equals("true")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {       return;     }     if (identifier.equals("undefined")) {
private void captureArgumentsFrom(Invocation invocation) {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(null);                  }              }             } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(null);                  }              }             } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(null);                  }              }             } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(null);                  }              }             } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(null);                  }              }             } else {             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(null);                  }
public static double sinh(double x) { return Math.sinh(x); }  public static double exp(double x) { return Math.exp(x); }  public static double log(double x) { return Math.log(x); }  public static double expm1(double x) { return Math.expm1(x); }  public static double log1p(double x) { return Math.log1p(x); }  public static double log10(double x) { return Math.log10(x); }  public static double log2(double x) { return Math.log2(x); }  public static double log10p(double x) { return Math.log10p(x); }  public static double pow(double x, double y) { return Math.pow(x, y); }  public static double sqrt(double x) { return Math.sqrt(x); }  public static double tan(double x) { return Math.tan(x); }  public static double tanh(double x) { return Math.tanh(x); }  public static double tanh2(double x) { return Math.tanh2(x); }  public static double exp2(double x) { return Math.exp2(x); }  public static double expm1(double x) { return Math.expm1(x); }  public static double expm1p(double x) { return Math.expm1p(x); }  public static double log2p(double x) { return Math.log2p(x); }  public static double log10p(double x) { return Math.log10p(x); }  public static double log10(double x) { return Math.log10(x); }  public static double log2(double x) { return Math.log2(x); }  public static double log10p(double x) { return Math.log10p(x); }  public static double pow(double x, double y) { return Math.pow(x, y); }  public static double sqrt(double x) { return Math.sqrt(x); }  public static double tanh(double x) { return Math.tanh(x); }  public static double tanh2(double x)
static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      return Double.parseDouble(s);    }
FunctionTypeBuilder inferFromOverriddenFunction(Node parametersNode) {   Node newName = IR.name("").useSourceInfoFrom(existingName);   varNode = IR.var(existingName).useSourceInfoFrom(existingName);   varNode.replaceChild(existingName, varNode);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName, existingName);   varNode.replaceChild(existingName
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;             }             return i;           }           return null;         }
private void handleObjectLit(NodeTraversal t, Node n) {            Node newName = IR.name("").useSourceInfoFrom(existingName);             value.replaceChild(existingName, newName);             varNode = IR.var(existingName).useSourceInfoFrom(existingName);             parent.replaceChild(parent, varNode);           } else {             if (value!= null) {               value.detachFromParent();             }             varNode = parent;           }
private static void escapeJavaStyleString(Writer out, String str, boolean escape) {             StringBuilder sb = new StringBuilder();             for (int i = 0; i < str.length(); i++) {             char c = str.charAt(i);             if (c == '\\') {             sb.append('\\');             }             else {             sb.append(c);             }             }             if (escape) {             out.write('\\');             }             else {             out.write('/');             }             else {             out.write('\\');             }             else {             out.write('/');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {             out.write('\\');             }             else {
boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3 */      static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** * @since 2.3 */      static void unregisterAll() {         getRegistry().clear();      }      /** * @since 2.3 */      static void register(Object value) {         getRegistry().add(new IDKey(value));      }      /** * @since 2.3 */      static void registerAll() {         getRegistry().clear();      }      /** * @since 2.3 */      static void clear() {         Registry.getInstance().clear();      }      /** * @since 2.3 */      static Registry getRegistry() {         return Registry.getInstance();      }      /** * @since 2.3 */      static void setRegistry(Registry value) {         Registry.getInstance().set(value);      }      /** * @since 2.3 */      static void clearRegistry() {         Registry.getInstance().clear();      }      /** * @since 2.3 */      static <T> T get(Class<T> type) {         return Registry.getInstance().get(type);      }      /** * @since 2.3 */      static <T> void set(Class<T> type, T value) {         Registry.getInstance().set(type, value);      }      /** * @since 2.3 */      static <T> void register(Class<T> type, T value) {         Registry.getInstance().register(type, value);      }      /** * @since 2.3 */      static <T> void registerAll(Class<T> type, Collection<T> values) {         Registry.getInstance().registerAll(type, values);      }      /** * @since 2.3 */      static <T> void unregister(Class<T> type, T value) {         Registry.getInstance().unregister(type, value);      }      /** * @since 2.3 */      static <T> void unregisterAll(Class<T> type) {         Registry.getInstance().unregisterAll(type);      }
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }             } else {             if (actualTypeArgument instanceof WildcardType) {               contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));             } else {               contextualActualTypeParameters.put(typeParameter, actualTypeArgument);             }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put(typeParameter, actualTypeArgument);           }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put(typeParameter, actualTypeArgument);           }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put(typeParameter, actualTypeArgument);           }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put(typeParameter, actualTypeArgument);           }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put(typeParameter, actualTypeArgument);           }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put(typeParameter, actualTypeArgument);           }           } else {           if (actualTypeArgument instanceof WildcardType) {           contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));           } else {           contextualActualTypeParameters.put
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            String propName, JSType leftType) {     if (rightType == null) {       return false;     }     if (leftType == null) {       return false;     }     if (rightType!= leftType) {       return false;     }     if (propName == null) {       return false;     }     if (propName.length() == 0) {       return false;     }     if (propName.equals(propName)) {       return true;     }     if (propName.equalsIgnoreCase(propName)) {       return true;     }     if (propName.equalsIgnoreCase(propName.toLowerCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toUpperCase())) {       return true;     }     if (propName.equals(propName.toLowerCase())) {       return true;     }     if (propName.equals(propName.toUpperCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toLowerCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toUpperCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toLowerCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toUpperCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toLowerCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toUpperCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toLowerCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toUpperCase())) {       return true;     }     if (propName.equalsIgnoreCase(propName.toLowerCase())) {       return true;     }     if (propName.equalsIgnoreCase(
