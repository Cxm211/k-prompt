public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /**      * @param chromosomes      * @param populationLimit      * @param elitismRate      */      public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /**      * @param chromosomes      * @param populationLimit      * @param elitismRate      */      public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /**      * @param chromosomes      * @param populationLimit      * @param elitismRate      */      public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /**      * @param chromosomes      * @param populationLimit      * @param elitismRate      */      public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /**      * @param chromosomes      * @param populationLimit      * @param elitismRate      */      public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;      }      /**      * @param chromosomes      * @param populationLimit 
protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsTo
protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs
 = problem.getMeasurements().length;          int m = problem.getMeasurements().length;          int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                                            new Object[] { new Integer(m), new Integer(p)});          }         double[] errors = new double[problem.getMeasurements().length];          final double c = problem.getAllParameters().length;          for (int i = 0; i < errors.length; i++) {              errors[i] = Math.sqrt(problem.getMeasurements()[i] * problem.getMeasurements()[i] + problem.getAllParameters()[i] * problem.getAllParameters()[i]);          }         return errors;      }      public double[] guessParametersErrors(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                                            new Object[] { new Integer(m), new Integer(p)});          }         double[] errors = new double[problem.getMeasurements().length];          final double c = problem.getAllParameters().length;          for (int i = 0; i < errors.length; i++) {              errors[i] = Math.sqrt(problem.getMeasurements()[i] * problem.getMeasurements()[i] + problem.getAllParameters()[i] * problem.getAllParameters()[i]);          }         return errors;      }      public double[] guessParametersErrors(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                                            new Object[] { new Integer(m), new Integer(p)});          }         double[] errors = new double[problem.getMeasurements().length];          final double c = problem.getAllParameters().length;          for (int i = 0
public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(location);               return null;           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";           }           public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()
public Week(Date time) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public Week(Date time, TimeZone zone, Locale locale) {       */       public Week(Date time, TimeZone zone, Locale locale) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, zone, locale);       }       /** public
public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; } public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; } public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; } public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; } public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++; } public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl
void addIdentifier(String identifier) {       * Constants (true, false, null) are considered basically free,       * because it's likely that they will get folded.       */    }  } 
FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverr
Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override     
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return len > 0 && s.charAt(0) != '0';    }    static double getSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return len > 0 && s.charAt(0) != '0';    }    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return len > 0 && s.charAt(0) != '0';    }    static double getSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return len > 0 && s.charAt(0) != '0';    }    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return len > 0 && s.charAt(0) != '0';    }    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return
public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                 
public static double sinh(double x) {        if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(x);        }        if (x == 0) {            return 0;        }        if (x == 1) {            return 1;        }        if (x == 2) {            return 2;        }        if (x == 3) {            return 3;        }        if (x == 4) {            return 4;        }        if (x == 5) {            return 5;        }        if (x == 6) {            return 6;        }        if (x == 7) {            return 7;        }        if (x == 8) {            return 8;        }        if (x == 9) {            return 9;        }        if (x == 10) {            return 10;        }        if (x == 11) {            return 11;        }        if (x == 12) {            return 12;        }        if (x == 13) {            return 13;        }        if (x == 14) {            return 14;        }        if (x == 15) {            return 15;        }        if (x == 16) {            return 16;        }        if (x == 17) {            return 17;        }        if (x == 18) {            return 18;        }        if (x == 19) {            return 19;        }        if (x == 20) {            return 20;        }        if (x == 21) {            return 21;        }        if (x == 22) {            return 22;        }        if (x == 23) {            return 23;        }        if (x == 24) {            return 24;        }        if (x == 25) {            return 25;        }        if (x == 26) {            return 26;        }        if (x == 27) {            return 27;        }        if (x == 28) {            return 28;        }        if (x == 29) {            return 29;        }        if (x == 30) {            return 30;        }        if (x == 31) {            return 31;        }        if (x == 32) {            return
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix != null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              int maxDigits = iMaxPrintedDigits;              if (maxDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);             
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;        }      }      return n;      }  private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;              } else if (ratio > maxRatio) {                      maxRatio = ratio;              }              }             }             }             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;              } else if (ratio > maxRatio) {                      maxRatio = ratio;              }             }             }             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;              } else if (ratio > maxRatio) {                      maxRatio = ratio;              }             }             }             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;              } else if (ratio > maxRatio) {                      maxRatio = ratio;              }             }             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;              } else if (ratio > maxRatio) {                      maxRatio = ratio;              }             }             }             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;              } else if (ratio > maxRatio) {                      maxRatio = ratio;              }             }             }             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;      } JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve
public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga; public boolean evaluateStep(final StepInterpolator interpol
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnType
public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }    public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.
package org.mockito.internal.util; public class Timer {     public static final Timer INSTANCE = new Timer();      private Timer() {     }      public static Timer getInstance() {         return INSTANCE;     }      public static void reset() {         INSTANCE.reset();     }      public static void reset(long millis) {         INSTANCE.reset(millis);     }      public static void reset(int millis) {         INSTANCE.reset(millis);     }      public static void reset(long millis, int millis) {         INSTANCE.reset(millis, millis);     }      public static void reset(int millis, long millis) {         INSTANCE.reset(millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis, millis, millis);     }      public static void reset(long millis, int millis, int millis) {         INSTANCE.reset(millis,
protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x2) {                         x0 = 0.5 * (x0 + x2 - FastMath.max(rtol * FastMath.abs(x2), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x3) {                         x0 = 0.5 * (x0 + x3 - FastMath.max(rtol * FastMath.abs(x3), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x4) {                         x0 = 0.5 * (x0 + x4 - FastMath.max(rtol * FastMath.abs(x4), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x5) {                         x0 = 0.5 * (x0 + x5 - FastMath.max(rtol * FastMath.abs(x5), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x6) {                         x0 = 0.5 * (x0 + x6 - FastMath.max(rtol * FastMath.abs(x6), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x7) {                         x0 = 0.5 * (x0 + x7 - FastMath.max(rtol * FastMath.abs(x7), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x8) {                         x0 = 0.5 * (x0
static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */       static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value
 tol2 = eps * Math.abs(x) + t;              final double tol3 = eps * Math.abs(x) + t;              final double tol4 = eps * Math.abs(x) + t;              final double tol5 = eps * Math.abs(x) + t;              final double tol6 = eps * Math.abs(x) + t;              final double tol7 = eps * Math.abs(x) + t;              final double tol8 = eps * Math.abs(x) + t;              final double tol9 = eps * Math.abs(x) + t;              final double tol10 = eps * Math.abs(x) + t;              final double tol11 = eps * Math.abs(x) + t;              final double tol12 = eps * Math.abs(x) + t;              final double tol13 = eps * Math.abs(x) + t;              final double tol14 = eps * Math.abs(x) + t;              final double tol15 = eps * Math.abs(x) + t;              final double tol16 = eps * Math.abs(x) + t;              final double tol17 = eps * Math.abs(x) + t;              final double tol18 = eps * Math.abs(x) + t;              final double tol19 = eps * Math.abs(x) + t;              final double tol20 = eps * Math.abs(x) + t;              final double tol21 = eps * Math.abs(x) + t;              final double tol22 = eps * Math.abs(x) + t;              final double tol23 = eps * Math.abs(x) + t;              final double tol24 = eps * Math.abs(x) + t;              final double tol25 = eps * Math.abs(x) + t;              final double tol26 = eps * Math.abs(x) + t;              final double tol27 = eps * Math.abs(x) + t;              final double tol28 = eps * Math.abs(x) + t;              final double tol29 = eps * Math.abs(x) + t;              final double tol30 = eps * Math.abs(x) + t;              final double tol31 = eps * Math.abs(x) + t;              final double tol
private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(Node n, Node parent) {      }     return false;    }    /** private boolean shouldReportThis(
protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0;              }              } else {                  targetY = 0;              }              return targetY;              } protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0;              }              } else {                  targetY = 0;              }              return targetY;              } protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0;              }              } else {                  targetY = 0;              }              return targetY;              } protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0;              }              } else {                  targetY = 0;              }              return targetY;              } protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else {                  targetY = 0;              }              } else {                  targetY = 0;              }              return targetY;              } protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -RED
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }  protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best
              for (int j = startIndex; j < len; j++) {              for (int k = 0; k < strLen; k++) {              if (thisBuf[i + j + k] == str.charAt(i + j + k)) {              return i + j + k;              }              }              }              }              return -1;              }          }          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {              if (thisBuf[i + j + k] == str.charAt(i + j + k)) {              return i + j + k;              }              }              return -1;              }          }          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {              if (thisBuf[i + j + k] == str.charAt(i + j + k)) {              return i + j + k;              }              }              return -1;              }          }          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {              if (thisBuf[i + j + k] == str.charAt(i + j + k)) {              return i + j + k;              }              }              return -1;              }          }          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {              if (thisBuf[i + j + k] == str.charAt(i + j + k)) {              return i + j + k;              }              }              return -1;              }          }          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {              if (thisBuf[i + j + k] == str.charAt(i + j + k)) {              return i + j + k;              }              }              return -1;              }          }          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen
 public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   }
public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_
public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount();           if (seriesCount > 0) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           return new LegendItemCollection(seriesCount);           }           public LegendItemCollection getLegendItems() {          }           int index =
private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;          }         }         return isChainedProperty;         }         return false;         }         private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;          }         }         private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;          }         }         return isChainedProperty;         }         private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;          }         }         private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;          }         }         private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChain
 == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          Object[] comp = createComposite(elementPairs);          if (notPrinter == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          if (notPrinter == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          if (notPrinter == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          if (notPrinter == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          if (notPrinter == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);          }          if (notPrinter == notPrinter && comp instanceof Separator) {              Separator sep = (Separator) comp;                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;        case Token.IN:          return true;        case Token.OBJECTLIT:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;        case Token.IN:          return true;       
* @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */      static boolean isRegistered(Object value) {         return
private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } } private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      } else {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }
 = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);              }              offset = FieldUtils.safeMultiply(hoursOffset, 60);              if (
public Fraction pow(int power) {       */      private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }         if (Math.abs
public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers
public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pos));              }          }      public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         this(duration, null, null);      }      /** 
public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              get
protected GenericMetadataSupport actualParameterizedType(Object mock) {      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }               }));          return mock;      }      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer() {               public Object answer
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       }        return false;       }      return true;  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n,
public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;              }          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                 
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();        }  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();        }  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();        }  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();        }  private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();        }  private OriginalMapping getOriginalMappingForEntry(Entry entry
private void inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {              inlineNonConstants((Node) nameNode);              break;            }            }          }          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode instanceof Node) {
isNaN || divisor.isNaN) {              return NaN;          }          if (c == 0.0 && d == 0.0) {             return NaN;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0.0) {             return ZERO;          }          if (c == 0.0 && d == 0
public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(), weeks));      }      public void addWeeks(final int weeks) {              setMillis(getChronology().
public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false);              }          } public long roundFloor(
public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0; public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entity
DAY_OF_YEAR) &&                  cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }              } protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualType
*        * @since 2.3       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */     private static final ThreadLocal<Set<IDKey>> REGISTRY =
private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }       private boolean toStringEquals(Matcher m, Object arg) {          return String
 } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {         
private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                     
private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType() != null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);     } } private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType() != null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);     } } private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType() != null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);     } } private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType() != null && parent.isAssign()) {       return;      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType,
, Calendar.HOUR, hours);          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) {        if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n.getNodeName().equals("script")) {          scriptNodeCount++;        } else if (n
static Double getNumberValue(Node n) {    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring(0, s.length() - 1);      return Double.parseDouble(s);    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      s = s.substring
public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              }          }          public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.set(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.set(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.set(localInstant, value);                 return iZone
Node parseInputs() {          boolean staleInputs = false;       if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (staleInputs) {              staleInputs = true;              break;            }          }          if (staleInputs) {              staleInputs = true;              break;            }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (staleInputs) {              staleInputs = true;              break;            }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (staleInputs) {              staleInputs = true;              break;            }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }          }          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {            if (input.needsManagement()) {              staleInputs = true;              break;            }          }
