private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,      } else {              if (builder.length() > 0) {
boolean isNoObjectType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public final boolean isNumberObjectType() { Method call addition, Return expression modification,  HealthCheckRegistry registry = HealthCheckRegistry.getInstance();     return registry.isObjectType(this);    }    public
public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);           removeRow(index);       }
public int getDimension() {              indices[i] = idx;         }         int idx = 1; while (count < index) {             count += idx;             ++idx;         }         --idx;         indices[last] = idx;          return indices;          }
public boolean apply(Node input) { case Token.REGEXP:                    case Token.NEW:                      return true;                  }                  return false; }
public void exitScope(NodeTraversal t) {          if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          aliases.clear();          forbiddenLocals.clear();          transformation = null;
public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,  privKey public double integrate(final FirstOrderDifferentialEquations equations,                    loop     = false; } else { Assignment addition, Method call addition,
public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT: Return expression modification,  WebACL static boolean evaluatesTo
private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {          visitParameterList(t, n, type.toMaybeFunctionType());          ensureTyped(t, n, type.getInstanceType());        } else {
public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                      final double[] wi  = wData[i];                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];                          }                 }                          for (int j = 0; j < p; ++j) {                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];                          }                  }                          for (int j = 0; j < p; ++j) {                             wData[p - 1][j] = ei1[j] * secondaryBidiagonal[p - 1] / singularValues[j];                          }                  for (int i = p; i < m; ++i) {                      wData[i] = new double[p];
protected UnivariatePointValuePair doOptimize() {                  } } else { return                              best(current,                                    previous,                              isMinim);              }              ++iter;
private static final long serialVersionUID = -7105341425736035847L;           private MockitoCore mockitoCore = new MockitoCore();           private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           }
private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {              assignedToUnknownValue = true;              }            }           if (assignedToUnknownValue && hasPropertyAssign) {              changes = markReferencedVar(var) = true;              maybeUnreferenced.remove(current);              current--;
private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false; if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }     }      Node cArg = callNode.getFirstChild().getNext();
private void inlineAliases(GlobalNamespace namespace) {          continue; }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) {
public ElitisticListPopulation(final List<Chromosome> chromosomes,       */ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         this.elitismRate = elitismRate;      }      /** Assignment removal, Method call addition, Variable replacement by method call,  /***/ public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);
public void setRangeAxes(ValueAxis[] axes) {           int result = this.rangeAxes.indexOf(axis); if (result < 0) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 1) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 2) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 3) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 4) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 5) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 6) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 7) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 8) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 9) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 10) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 11) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length - 12) {              Plot parent = getParent(); Conditional (if) branch addition, throw addition, Object instantiation addition,  //} else if (result == this.rangeAxes.length -
public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }
public String escape(String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';');
private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();          if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);
public BooleanOptionHandler( @Override public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);          if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(1));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(2));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(3));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(4));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(5));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(6));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(7));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(8));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter(9));          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter10());          } else if (param == null) {             setter.addValue(false); Assignment addition, try-catch addition,  PrivateKey privateKey = PrivateKey.getInstance(params.getParameter11());          } else if (param == null) {
public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial);
private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs)) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild();
public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) { return reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /** Method call addition, Method call replacement, Return expression modification,  TypesPackage public static Collection anyCollection()
public void delete(int start, int end) {          subclasses may differ.        */ public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(0, getItemCount() - 1);           return clone;       }
public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100).doubleValue();      }      /** Method call removal, Return expression modification,  objType public Fraction divide(final int i) {         return multiply(100
public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if) branch addition, throw addition, Object instantiation addition,  privKey public static int safeMultiply(int val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L; Conditional (if)
public static boolean isEmpty(boolean[] array) {              type = element.getClass();          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  PrivateKey public static boolean isEmpty(boolean[] array) {              type = element.getClass();          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  PrivateKey public static boolean isEmpty(boolean[] array) {              type = element.getClass();          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  PrivateKey public static boolean isEmpty(boolean[] array) {              type = element.getClass();          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  PrivateKey public static boolean isEmpty(boolean[] array) {              type = element.getClass();          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type); Assignment removal, throw addition, Object instantiation addition, Return statement removal,  PrivateKey public static boolean isEmpty(boolean[] array) {              type = element.getClass();          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copy
public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end.");           }           TimeSeries copy = (TimeSeries) super.clone();           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) {
private Node tryFoldComparison(Node n, left, right) {            if (right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)) { Assignment addition, Assignment expression modification, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method call replacement, Method definition addition, Return statement addition, Variable addition,  CloudHSM private Node tryFoldComparison(Node n, left, right) {            if (right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)) { Assignment addition, Assignment expression modification, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method call replacement, Method definition addition, Return statement addition, Variable addition,  CloudHSM private Node tryFoldComparison(Node n, left, right) {            if (right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)) { Assignment addition, Assignment expression modification, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method call replacement, Method definition addition, Return statement addition, Variable addition,  CloudHSM private Node tryFoldComparison(Node n, left, right) {            if (right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)) { Assignment addition, Assignment expression modification, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method call replacement, Method definition addition, Return statement addition, Variable addition,  CloudHSM private Node tryFoldComparison(Node n, left, right) {            if (right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)) { Assignment addition, Assignment expression modification, Conditional (case in switch) branch addition, Conditional (if) branch addition, Method call addition, Method call replacement, Method definition addition, Return statement addition, Variable addition,  CloudHSM private Node tryFoldComparison
private void unrollBinaryOperator(      Node current = firstNonOperator; do {         current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    }
public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          }
public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false);              }          }
public static Number createNumber(String str) {              if (decPos > -1) {              if (expPos > -1) {                  if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos);
public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }           }
private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition,  WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) { Conditional (if) branch addition, Method call addition, Return statement addition, WebACL private boolean isInlinableObject(List<Reference> refs) {
private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0; try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }
protected void computeGeometricalProperties() {              if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);
private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");              map.put("MIT", "Pacific/Apia");              map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage");
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i))) {          return false;          }
protected PointVectorValuePair doOptimize() {                         if (checker!= null) {                         if (checker.converged(iter, previous, current)) {                              setCost(currentCost);                              return current;                          }
boolean isInlinableObject(List<Reference> refs) {          boolean ret = false;          for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();
void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      }
public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour(final int minuteOfHour) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  CloudHSM public void setMinuteOfHour
private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);
public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public boolean isSerializable() { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public boolean isSerializable() { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public boolean isSerializable() { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public boolean isSerializable() { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public boolean isSerializable() { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public boolean isSerializable() { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);       }       public MockSettings defaultAnswer(Answer defaultAnswer) { return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable
protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() { if (checker!= null) { if (checker.converged(iter, previous, current)) {                         return current;                      }                  } Method call addition, Return expression modification,  TypesPackage protected UnivariatePointValuePair doOptimize() {
public long getUnitMillis() {         * @return zero always       */ public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }          return 0; }
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(          }  private boolean canInline(
public boolean setPrototype(PrototypeObjectType prototype) { return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment addition, Assignment expression modification, Conditional (if) branch addition, Conditional (if-else) branches addition, Conditional expression reduction, Method call addition, Method call removal, Variable addition, Variable replacement by another variable;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor(); Assignment
public static Node tryCatch(Node tryBody, Node catchNode) {       Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    }
public FitnessFunction() {             return                  decode(x);          }
private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID = 9386874258972L; private volatile int iPeriod; private static final long serialVersionUID =
public static String escapeJava(String str) {         * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/ public static String escapeJava(String str) {         * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/ public static String escapeJava(String str) {         * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/ public static String escapeJava(String str) {         * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/ public static String escapeJava(String str) {         * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/ public static String escapeJava(String str) {         * @throws IOException if error occurs on underlying Writer       */ public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false);      }      /** Conditional (if) branch addition, Method call parameter addition, Method call replacement, Parameter addition in method definition, Return expression modification,  /***/ public static String escapeJava(String str) {         * @throws IOException if error occurs
void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         addExpr(first, p, context);         cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        return;        }
public static double sinh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  TabletType public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  TabletType public static double sinh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  TabletType public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  TabletType public static double sinh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  TabletType public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;      }      /** Method call addition, Method call removal, Return expression modification,  TabletType public static double sinh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean
public void noMoreInteractionsWantedInOrder(Invocation undesired) { throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + undesired.getMock() + "':",                  undesired.getLocation()          )      }
public EqualsBuilder append(Object lhs, Object rhs) {          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);          } else if (lhs.getClass()!= rhs.getClass()) {              this.setEquals(false);
void apply() { this.nameNode = nameNode;       this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
public void setMinuteOfDay(final int minuteOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  TypesPackage public void setHourOfDay(final int hourOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  TypesPackage public void setMinuteOfDay(final int minuteOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  TypesPackage public void setHourOfDay(final int hourOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  TypesPackage public void setMinuteOfDay(final int minuteOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  TypesPackage public void setHourOfDay(final int hourOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  TypesPackage public void setMinuteOfDay(final int minuteOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addMinutes(final int minutes) {              setMillis(getChronology().minutes().add(getMillis(), minutes));      } Conditional (if) branch addition,  TypesPackage public void setHourOfDay(final int hourOfDay) {        } @throws IllegalArgumentException if the value is invalid       */ public void addHours(final int hours) {              setMillis(getChronology().hours().add(getMillis(), hours));      } Conditional (if) branch addition,  TypesPackage public void setMinuteOfDay(final int minuteOfDay) {        } @throws IllegalArgumentException if the value is invalid
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info);        }       if (inferred) {         inferred =!(rhsValue!= null &&             rhsValue.isFunction() &&             (info!= null ||!scope.isDeclared(qName, false));        }        if (!inferred) {
