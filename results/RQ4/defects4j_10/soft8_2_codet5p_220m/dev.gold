public void applyAlias() {    private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;     private final Node aliasDefinition;      private final String aliasName;     AliasedTypeNode(Node typeReference, Node aliasDefinition,          String aliasName) {        this.typeReference = typeReference;       this.aliasDefinition = aliasDefinition;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       String typeName = typeReference.getString();       String aliasExpanded =           Preconditions.checkNotNull(aliasDefinition.getQualifiedName());       Preconditions.checkState(typeName.startsWith(aliasName));       typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));      }    }
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();     if (len == 0) {       return false;     }      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;        }      }     return len == 1 || s.charAt(0) != '0';    }    static double getSimpleNumber(String s) {
public Week(Date time) {       */       public Week(Date time, TimeZone zone) {          this(time, zone, Locale.getDefault());       }       /**
public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0D);       }   } \ No newline at end of file
Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);       Node target = assign.getFirstChild();       if (!validAssignmentTarget(target)) {         errorReporter.error(           "invalid assignment target",           sourceName,           target.getLineno(), "", 0);       }        return assign;      }
private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {       restoreLookAhead(token);        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),                   container           );       }
private boolean shouldReportThis(Node n, Node parent) {      }     return parent != null && NodeUtil.isGet(parent);    }    /**
public int indexOf(String str, int startIndex) {              return -1;          }          char[] thisBuf = buffer;         int len = size - strLen + 1;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {
private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg == null? "null" : arg.toString());       }   }
public double getChiSquare(EstimationProblem problem) {      public double[] guessParametersErrors(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getUnboundParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)",                                            new Object[] { new Integer(m), new Integer(p)});          }         double[] errors = new double[problem.getUnboundParameters().length];          final double c = Math.sqrt(getChiSquare(problem) / (m - p));          double[][] covar = getCovariances(problem);          for (int i = 0; i < errors.length; ++i) {
public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */      public void addWeeks(final int weeks) {         if (weeks != 0) {              setMillis(getChronology().weeks().add(getMillis(), weeks));         }      }
public boolean evaluateStep(final StepInterpolator interpolator)                         final double epsilon = (forward ? 0.25 : -0.25) * convergence;                         for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {                             ta += epsilon;                             interpolator.setInterpolatedTime(ta);                             ga = handler.g(ta, interpolator.getInterpolatedState());                         }                         if (ga * gb > 0) {                             throw MathRuntimeException.createInternalError(null);                         }                     }                      increasing = gb >= ga;
public Fraction pow(int power) {       */      private static int greatestCommonDivisor(int u, int v) {         if ((u == 0) || (v == 0)) {             if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {                 throw new ArithmeticException("overflow: gcd is 2^31");             }             return Math.abs(u) + Math.abs(v);         }         if (Math.abs(u) == 1 || Math.abs(v) == 1) {              return 1;          }
private void inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime() &&           (isInlineableDeclaredConstant(v, referenceInfo) ||            referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();
public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;               case Token.CATCH:                case Token.INC:                case Token.DEC:                  isSet = true;
protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j; ++i) {                             sum += jacobian[i][pj] * qtf[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));                      }
public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                 if (expPos > str.length()) {                     throw new NumberFormatException(str + " is not a valid number.");                 }                  mant = str.substring(0, expPos);              } else {                  mant = str;
public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false, instant);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false, instant);              if (get(result) != value) {                  throw new IllegalFieldValueException(iField.getType(), new Integer(value),                      "Illegal instant due to time zone offset transition: " +
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset == 0 && minutesOffset == 0) {              return DateTimeZone.UTC;          }         if (hoursOffset < -23 || hoursOffset > 23) {             throw new IllegalArgumentException("Hours out of range: " + hoursOffset);         }          if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {             int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - minutesOffset;              } else {                 minutesOffset = hoursInMinutes + minutesOffset;              }              offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);          } catch (ArithmeticException ex) {
FunctionTypeBuilder inferFromOverriddenFunction(        }       while (oldParams.hasNext()) {         paramBuilder.newParameterFromNode(oldParams.next());       }        parametersNode = paramBuilder.build();      }
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                 return;             }             final int iter = getIterations();             boolean converged = true;             for (int i = 0; i < simplex.length; ++i) {                 converged &= checker.converged(iter, original[i], simplex[i]);             }             if (converged) {                  return;              }
public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on mock";               }              new Reporter().smartNullPointerException(obj, location);               return null;           }
package org.mockito.internal.util; import org.mockito.exceptions.Reporter;  public class Timer {
public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset == null) {               return result;           }           int seriesCount = dataset.getRowCount();
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no          int size = elementPairs.size();          if (size >= 2 && elementPairs.get(0) instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);             if (sep.iAfterParser == null && sep.iAfterPrinter == null) {                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep);             }          }          Object[] comp = createComposite(elementPairs);          if (notPrinter) {
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);     if (maybeTypeOfThis != null) {       maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();     }      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }
*        * @since 2.3       */     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()
public void addValue(double value) {          secondMoment.increment(value);         if (meanImpl != mean) {              meanImpl.increment(value);          }         if (varianceImpl != variance) {              varianceImpl.increment(value);          }         if (geoMeanImpl != geoMean) {              geoMeanImpl.increment(value);          }          n++;
protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 final int p = agingA - MAXIMAL_AGING;                 final double weightA = (1 << p) - 1;                 final double weightB = p + 1;                 targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);              } else if (agingB >= MAXIMAL_AGING) {                 final int p = agingB - MAXIMAL_AGING;                 final double weightA = p + 1;                 final double weightB = (1 << p) - 1;                 targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);              } else {                  targetY = 0;
public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }
private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          break;                      case '/' :                         if (escapeForwardSlash) {                              out.write('\\');                         }                          out.write('/');                          break;                      default :
private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {         if (child.isQuotedString()) {           continue;         }          String name = child.getString();
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else if (typeParameter != actualTypeArgument) {                   contextualActualTypeParameters.put(typeParameter, actualTypeArgument);               }
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {        case Token.OBJECTLIT:          return true;       case Token.DELPROP:        case Token.IN:          return true;
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) > 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;
protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, epsilon) > 0) {                  columnsToDrop.add(i);              }          }
protected final double doSolve() {                      break;                  case REGULA_FALSI:                      break;                  default:
private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           && assign.getParent().getType() == Token.EXPR_RESULT) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;
* @since 2.3       */      static boolean isRegistered(Object value) {         Set<IDKey> registry = getRegistry();         return registry != null && registry.contains(new IDKey(value));      }      /**
static void register(Object value) {       * @since 2.3       */      static void unregister(Object value) {         Set<IDKey> s = getRegistry();         if (s != null) {             s.remove(new IDKey(value));             synchronized (HashCodeBuilder.class) {                 if (s.isEmpty()) {                     REGISTRY.remove();                 }             }         }      }      /**
private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;     private Set<String> modulesWithExports = Sets.newHashSet();      @Override      public void visit(NodeTraversal t, Node n, Node parent) {
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */      protected BasePeriod(long duration) {         super();         iType = PeriodType.time();         int[] values = ISOChronology.getInstanceUTC().get(this, duration);         iType = PeriodType.standard();         iValues = new int[8];         System.arraycopy(values, 0, iValues, 4, 4);      }      /**
void addIdentifier(String identifier) {       * Constants (true, false, null) are considered basically free,       * because it's likely that they will get folded when we're done.       */     @Override     void addConstant(String newcode) {       add("0");     }    }  }
Node parseInputs() {        boolean staleInputs = false;       if (options.dependencyOptions.needsManagement()) {          for (CompilerInput input : inputs) {
public static String formatPeriod(long startMillis, long endMillis, String forma              days -= 1;          }          while (days < 0) {             end.add(Calendar.MONTH, -1);             days += end.getActualMaximum(Calendar.DAY_OF_MONTH);              months -= 1;             end.add(Calendar.MONTH, 1);          }          while (months < 0) {              months += 12;              years -= 1;          }
private double localMin(boolean isMinim,          double w = x;          double d = 0;          double e = 0;         double fx = computeObjectiveValue(x);         if (!isMinim) {              fx = -fx;          }          double fv = fx;          double fw = fx;         while (true) {              double m = 0.5 * (a + b);              final double tol1 = eps * Math.abs(x) + t;              final double tol2 = 2 * tol1;
public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(localInstant, false, instant);              }          }
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine() + 1)         .setColumnPosition(entry.getSourceColumn() + 1);        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }
private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");      } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);
public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         setElitismRate(elitismRate);      }      /**
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix != null) {                  iPrefix.printTo(buf, value);              }             int bufLen = buf.length();              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {          return n;        }      }
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);        return false;      }      return true;
public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pt));              }          }      }
public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }             if(entityValue > 0xFFFF) {                 char[] chrs = Character.toChars(entityValue);                 out.write(chrs[0]);                 out.write(chrs[1]);             } else {                  out.write(entityValue);             }              return 2 + (end - start) + (isHex ? 1 : 0) + 1;          }          return 0;
static Double getNumberValue(Node n) {    }    static Double getStringNumberValue(String rawJsString) {     if (rawJsString.contains("\u000b")) {       return null;     }      String s = trimJsWhiteSpace(rawJsString);
public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER;          } else {              cutoverInstant = gregorianCutover.toInstant();             LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));             if (cutoverDate.getYear() <= 0) {                 throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01.");             }          }          GJChronology chrono;
public static double sinh(double x) {        if (x > 20) {           if (x >= LOG_MAX_VALUE) {               final double t = exp(0.5 * x);               return (0.5 * t) * t;           } else {                return 0.5 * exp(x);            }       } else if (x < -20) {           if (x <= -LOG_MAX_VALUE) {               final double t = exp(-0.5 * x);               return (-0.5 * t) * t;           } else {                return -0.5 * exp(-x);           }        }        if (x == 0) {
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&                  cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&                  cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
public Complex conjugate() {      public Complex divide(Complex divisor)          throws NullArgumentException {          MathUtils.checkNotNull(divisor);          if (isNaN || divisor.isNaN) {              return NaN;          }         if (divisor.isZero) {             return isZero ? NaN : INF;          }          if (divisor.isInfinite() && !isInfinite()) {              return ZERO;          }          final double c = divisor.getReal();          final double d = divisor.getImaginary();          if (FastMath.abs(c) < FastMath.abs(d)) {              double q = c / d;              double denominator = c * q + d;              return createComplex((real * q + imaginary) / denominator,                  (imaginary * q - real) / denominator);          } else {              double q = d / c;              double denominator = d * q + c;              return createComplex((imaginary * q + real) / denominator,                  (imaginary - real * q) / denominator);          }      }            public Complex divide(double divisor) {          if (isNaN || Double.isNaN(divisor)) {              return NaN;          }          if (divisor == 0d) {             return isZero ? NaN : INF;          }          if (Double.isInfinite(divisor)) {              return !isInfinite() ? ZERO : NaN;          }          return createComplex(real / divisor,                               imaginary  / divisor);      }      /**       * Test for the equality of two Complex objects.       * If both the real and imaginary parts of two complex numbers       * are exactly the same, and neither is {@code Double.NaN}, the two       * Complex objects are considered to be equal.       * All {@code NaN} values are considered to be equal - i.e, if either       * (or both) real and imaginary parts of the complex number are equal
public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (Matcher m : uniqueMatcherSet(indexOfVararg)) {                  if (m instanceof CapturesArguments) {                     Object rawArgument = invocation.getRawArguments()[indexOfVararg];                     for (int i = 0; i < Array.getLength(rawArgument); i++) {                         ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));                     }                  }              }          } else {
protected GenericMetadataSupport actualParameterizedType(Object mock) {      private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new SerializableAnswer() {               public Object answer(InvocationOnMock invocation) throws Throwable {                   return mock;               }
