public ElitisticListPopulation(final List<Chromosome> chromosomes,                                     final int populationLimit,                                     final double elitismRate) {          super(chromosomes, populationLimit);         this.elitismRate = elitismRate;
protected void dropPhase1Objective() {          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }
protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j;) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j;) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j;) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j;) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j;) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum / (s * cost));                      } protected VectorialPointValuePair doOptimize()                      if (s != 0) {                          double sum = 0;                          for (int i = 0; i <= j;) {                             sum += jacobian[i][pj] * residuals[i];                          }                          maxCosine = Math.max(maxCosine, Math.abs(sum / (s * cost));                      } protected VectorialPointValuePair do
public double getChiSquare(EstimationProblem problem)        throws EstimationException {          int m = problem.getMeasurements().length;         int p = problem.getAllParameters().length;          if (m <= p) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(m)});          }         double[] errors = new double[problem.getAllParameters().length];          final double c = problem.getMeasurements().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getAllParameters().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getMeasurements().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getAllParameters().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getAllParameters().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getMeasurements().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getAllParameters().length;          if (c <= m) {              throw new EstimationException("no degrees of freedom ({0} measurements, {1} parameters)", new Object[] { new Integer(c)});          }         final double c = problem.getAllParameters().length;          if (c
public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNullPointerExceptionPointerException(location);               return null;           } public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr                  return "SmartNull returned by unstubbed " + formatMethodCall()  + " method on";               }              new Reporter().smartNull
public Week(Date time) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone) {       */       public Week(Date time, TimeZone zone) {          this(time, RegularTimePeriod.DEFAULT_TIME_ZONE);       }       /** public Week(Date time, TimeZone zone)
public void addValue(double value) {          secondMoment.increment(value);         if (!(meanImpl instanceof Mean)) {              meanImpl.increment(value);          }         if (!(varianceImpl instanceof Variance)) {              varianceImpl.increment(value);          }         if (!(geoMeanImpl instanceof GeometricMean)) {              geoMeanImpl.increment(value);          }          n++;
void addIdentifier(String identifier) {       * Constants (true, false, null) are considered basically free,       * because it's likely that they will get folded.       */    }
FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverriddenFunction(        }        parametersNode = paramBuilder.build(); FunctionTypeBuilder inferFromOverr
Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);        return assign;      } Node processArrayLiteral(ArrayLiteral literalNode) {      @Override      Node processAssignment(Assignment assignmentNode) {        Node assign = processInfixExpression(assignmentNode);       
private void unrollBinaryOperator(    static boolean isSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      return len > 0 && s.charAt(index) != '0';    }    static double getSimpleNumber(String s) {      int len = s.length();      for (int index = 0; index < len; index++) {        char c = s.charAt(index);        if (c < '0' || c > '9') {          return false;      }      return len > 0 && s.charAt(index) != '0';    }
public void collect(JSModule module, Scope scope, Node n) {                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                  break;                case Token.INC:                case Token.DEC:                  isSet = true;                  type = Name.Type.FUNCTION;                 
public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }       if (x < -20) {                return -0.5 * exp(-x);        }        if (x == 0) { public static double sinh(double x) { if (x > 20) {                return 0.5 * exp(x);            }      
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {              if (iPrefix != null) {                  iPrefix.printTo(buf, value);              }              int minDigits = iMinPrintedDigits;              if (minDigits <= 1) {                  FormatUtils.appendUnpaddedInteger(buf, value);              }
private Node tryFoldArrayJoin(Node n) {      Node right = callTarget.getNext();      if (right != null) {       if (!NodeUtil.isImmutableValue(right)) {          return n;      }      }
private Integer getPivotRow(final int col, final SimplexTableau tableau) {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col);             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;
JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);      if (maybeTypeOfThis instanceof ObjectType) {        typeOfThis = (ObjectType) maybeTypeOfThis;      }      return typeOfThis;} JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {      JSType maybeTypeOfThis = safeResolve(typeOfThis, t,
public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb >= ga;public boolean evaluateStep(final StepInterpolator interpolator)                      increasing = gb
private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return recordDeepStubAnswer(                  newDeepStubMockMock(returnTypeGenericMetadata),                   container           );       } private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu          return record
public void applyAlias() {      private class AliasedTypeNode implements AliasUsage {      private final Node typeReference;      private final String aliasName;     AliasedTypeNode(Node typeReference,          String aliasName) {        this.typeReference = typeReference;        this.aliasName = aliasName;      }      @Override      public void applyAlias() {       typeReference.setString(aliasName);      }    }
public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { public class Timer { 
protected final double doSolve() {                      break;                  case REGULA_FALSI:                     if (x == x1) {                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x2) {                         x0 = 0.5 * (x0 + x2 - FastMath.max(rtol * FastMath.abs(x2), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x3) {                         x0 = 0.5 * (x0 + x3 - FastMath.max(rtol * FastMath.abs(x3), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x4) {                         x0 = 0.5 * (x0 + x4 - FastMath.max(rtol * FastMath.abs(x4), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x5) {                         x0 = 0.5 * (x0 + x5 - FastMath.max(rtol * FastMath.abs(x5), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x6) {                         x0 = 0.5 * (x0 + x6 - FastMath.max(rtol * FastMath.abs(x6), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x7) {                         x0 = 0.5 * (x0 + x7 - FastMath.max(rtol * FastMath.abs(x7), atol));                         f0 = computeObjectiveValue(x0);                     }                      break;                  case REGULA_FALSI:                     if (x == x8) {                         x0 = 0.5 * (x0
static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value) {       * @since 2.3       */         static void unregister(Object value) {         getRegistry().remove(new IDKey(value));      }      /** static void register(Object value
 tol2 = eps * Math.abs(x) + t;              final double tol3 = eps * Math.abs(x) + t;              final double tol4 = eps * Math.abs(x) + t;              final double tol5 = eps * Math.abs(x) + t;              final double tol6 = eps * Math.abs(x) + t;              final double tol7 = eps * Math.abs(x) + t;              final double tol8 = eps * Math.abs(x) + t;              final double tol9 = eps * Math.abs(x) + t;              final double tol10 = eps * Math.abs(x) + t;              final double tol11 = eps * Math.abs(x) + t;              final double tol12 = eps * Math.abs(x) + t;              final double tol13 = eps * Math.abs(x) + t;              final double tol14 = eps * Math.abs(x) + t;              final double tol15 = eps * Math.abs(x) + t;              final double tol16 = eps * Math.abs(x) + t;              final double tol17 = eps * Math.abs(x) + t;              final double tol18 = eps * Math.abs(x) + t;              final double tol19 = eps * Math.abs(x) + t;              final double tol20 = eps * Math.abs(x) + t;              final double tol21 = eps * Math.abs(x) + t;              final double tol22 = eps * Math.abs(x) + t;              final double tol23 = eps * Math.abs(x) + t;              final double tol24 = eps * Math.abs(x) + t;              final double tol25 = eps * Math.abs(x) + t;              final double tol26 = eps * Math.abs(x) + t;              final double tol27 = eps * Math.abs(x) + t;              final double tol28 = eps * Math.abs(x) + t;              final double tol29 = eps * Math.abs(x) + t;              final double tol30 = eps * Math.abs(x) + t;              final double tol31 = eps * Math.abs(x) + t;              final double tol
private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(Node n, Node parent) {      return shouldReportThis(n, parent);    }    /** private boolean shouldReportThis(
protected double doSolve() {              double targetY;              if (agingA >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yB;              } else if (agingB >= MAXIMAL_AGING) {                 targetY = -REDUCTION_FACTOR * yA;              } else {                  targetY = 0;
protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);              if (comparator.compare(contracted, best) < 0) {                  return;              }
public int indexOf(String str, int startIndex) {              return -1;          }          char[] thisBuf = buffer;         int len = thisBuf.length - strLen;          outer:          for (int i = startIndex; i < len; i++) {              for (int j = 0; j < strLen; j++) {              if (thisBuf[i] == str.charAt(j)) {              return i;              }              }              }              return -1;          }
public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   } \ No newline at end of file public static boolean isPrimitiveWrapper(Class<?> type) {          primitiveValues.put(int.class, 0);           primitiveValues.put(long.class, 0L);           primitiveValues.put(float.class, 0F);          primitiveValues.put(double.class, 0);       }   }
public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant = gregorianCutover.toInstant();          }          GJChronology chrono; public static synchronized GJChronology getInstance(              cutoverInstant = DEFAULT_CUTOVER; } else {              cutoverInstant
public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount(); public LegendItemCollection getLegendItems() {          }           int index = this.plot.getIndexOf(this);           CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {               return result;           }           int seriesCount = dataset.getRowCount
private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;  private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;  private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;  private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;  private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;  private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.getFirstChild();        if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)            && n.getType() == Token.GETPROP           ) {          boolean isChainedProperty =              n.getFirstChild().getType() == Token.GETPROP;  private boolean isPrototypePropertyAssign(Node assign) {        Node n = assign.get
 instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter instanceof Separator) {              Separator sep = (Separator) elementPairs.get(0);                  PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);                  sep = sep.finish(f.getPrinter(), f.getParser());                  return new PeriodFormatter(sep, sep.finish(f.getPrinter(), f.getParser()));          }          Object[] comp = createComposite(elementPairs);          if (notPrinter instanceof Separator) {              Separator sep = (Separator)
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.OBJECTLIT:          return true; case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { case Token.IN:          return evaluatesToLocalValue(value, locals); } static boolean evaluatesToLocalValue(Node value,
* @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** * @since 2.3       */ static boolean isRegistered(Object value) {         return getRegistry().contains(new IDKey(value));      }      /** 
private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");      }      return null;} private Node parseFunctionType(JsDocToken token) {      if (token != JsDocToken.LP) {        return reportTypeSyntaxWarning
 = FieldUtils.safeMultiply(hoursOffset, 60);              if (hoursInMinutes < 0) {                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);              } else {                 minutesOffset = FieldUtils.safeMultiply(hoursInMinutes, 60);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }              if (hoursInMinutes < 0) {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              } else {                 offset = FieldUtils.safeAdd(hoursInMinutes, -offset);              }          }
public Fraction pow(int power) {       */         private static int greatestCommonDivisor(int u, int v) {         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {              return 1;          }
public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers.get(position);                  if (m instanceof CapturesArguments) {                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);                  }              }          } else { public void captureArgumentsFrom(Invocation invocation) {                      ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));                  }              }             for (int position = indexOfVararg; position < matchers.size(); position++) {                 Matcher m = matchers
public final void translate(CharSequence input, Writer out) throws IOException {              for (int pt = 0; pt < consumed; pt++) {                 pos += Character.charCount(Character.codePointAt(input, pt));              }          }
protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri       * @param duration  the duration, in milliseconds       */ protected BasePeriod(long duration) {         this(duration, null, null);      }      /** protected BasePeriod(ReadableDuration duration, ReadableInstant
public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      } public double density(final double[] vals) throws DimensionMismatchException {              throw new DimensionMismatchException(vals.length, dim);          }         return FastMath.pow(2 * FastMath.PI, -dim / 2) *              FastMath.pow(covarianceMatrixDeterminant, 0.5) *              getExponentTerm(vals);      }
protected GenericMetadataSupport actualParameterizedType(Object mock) throws Throwable {          private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {          container.addAnswer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer(new Answer
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,            "assignment to property " + propName + " of " +            getReadableJSTypeName(owner, true),            rightType, leftType);       return false;
public static Number createNumber(String str) throws NumberFormatException {              mant = str.substring(0, decPos);          } else {              if (expPos > -1) {                  mant = str.substring(0, expPos);              } else {                  mant = str;
private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();    } private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();    } private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();    } private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();    } private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x = OriginalMapping.newBuilder()          .setOriginalFile(sources[entry.getSourceFileId()])         .setLineNumber(entry.getSourceLine())         .setColumnPosition(entry.getSourceColumn());        if (entry.getNameId() != UNMAPPED) {          x.setIdentifier(names[entry.getNameId()]);        }        return x.build();    } private OriginalMapping getOriginalMappingForEntry(Entry entry) {        Builder x
private void inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {          List<Reference> refs = referenceInfo.references;          for (int i = 1 ; i < refs.size(); i++) {            Node nameNode = refs.get(i).getNode();            if (nameNode != null) {            inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {              List<Reference> refs = referenceInfo.references;              for (int i = 1 ; i < refs.size(); i++) {              Node nameNode = refs.get(i).getNode();              if (nameNode != null) {              inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {              List<Reference> refs = referenceInfo.references;              for (int i = 1 ; i < refs.size(); i++) {              Node nameNode = refs.get(i).getNode();              if (nameNode != null) {              inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {              List<Reference> refs = referenceInfo.references;              for (int i = 1 ; i < refs.size(); i++) {              Node nameNode = refs.get(i).getNode();              if (nameNode != null) {              inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isWellDefined() &&           referenceInfo.isAssignedOnceInLifetime()) {              List<Reference> refs = referenceInfo.references;              for (int i = 1 ; i < refs.size(); i++) {              Node nameNode = refs.get(i).getNode();              if (nameNode != null) {              inlineNonConstants(        if (!maybeModifiedArguments &&            !staleVars.contains(v) &&            referenceInfo.isW
isNaN || divisor.isNaN) {              return NaN;          }          if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {             return NaN;          }          if (divisor.isInfinite() && !isInfinite()) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return NaN;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return NaN;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final double d = d.getImaginary();          if (isNaN || divisor.isNaN) {              return ZERO;          }          final double c = c.getReal();          final
public void setWeekOfWeekyear(final int weekOfWeekyear) {       * @throws IllegalArgumentException if the value is invalid       */ public void addWeeks(final int weeks) {              setMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add(getMillis(getChronology().weeks().add
public long roundFloor(long instant) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.roundFloor(localInstant);                 return iZone.convertLocalToUTC(false);              }          }
public int translate(CharSequence input, int index, Writer out) throws IOExcepti                  return 0;              }                  out.write(entityValue);              return 2 + (end - start) + (isHex ? 1 : 0) + 1;
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {          return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&                  cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&                  cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&                  cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));
protected void registerTypeVariablesOn(Type classType) {              if (actualTypeArgument instanceof WildcardType) {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));              } else {                   contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));               }
*        * @since 2.3       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {         @Override         protected Set<IDKey> initialValue() {             return new HashSet<IDKey>();         }     };      /*       * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()       */ private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<
private boolean safelyMatches(Matcher m, Object arg) {      }       private boolean toStringEquals(Matcher m, Object arg) {          return StringDescription.toString(m).equals(arg.toString());       }
private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child); } } } private void handleObjectLit(NodeTraversal t, Node n) {            child != null;            child = child.getNext()) {          String name = child.getString();          if (name != null) {          handleObjectLit(t, child);
private static void escapeJavaStyleString(Writer out, String str, boolean escape                          out.write('\\');                          break;                      case '/' :                              out.write('\\');                          out.write('/');                          break;                      default : 
private void visitGetProp(NodeTraversal t, Node n, Node parent) {      if (childType.isDict()) {        report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict");     } else if (n.getJSType() != null && parent.isAssign()) {       return;     } else if (validator.expectNotNullOrUndefined(t, n, childType,          "No properties on this expression", getNativeType(OBJECT_TYPE))) {        checkPropertyAccess(childType, property.getString(), t, n);
, Calendar.HOUR, hours);         return formatPeriod(startMillis, endMillis, forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);         return formatPeriod(startMillis, endMillis, forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);         return formatPeriod(startMillis, endMillis, forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAndCorrect(start, end, Calendar.HOUR, hours);         return formatPeriod(startMillis, endMillis, forma              days -= 1;          }          while (days < 0) {             days += 31;              months -= 1;          }          while (months < 0) {              months += 12;              years -= 1;          }         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);         hours -= reduceAnd
private String normalizeSourceName(String filename) {        AbstractPostOrderCallback {      private int scriptNodeCount = 0;      @Override      public void visit(NodeTraversal t, Node n, Node parent) {
static Double getNumberValue(Node n) {    }    static Double getStringNumberValue(String rawJsString) {      String s = trimJsWhiteSpace(rawJsString);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s = trimJsWhiteSpace(s);      String s =
public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              }          }          public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              }          }          public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(localInstant, false);              }          }          public long addWrapField(long instant, int value) {              } else {                  long localInstant = iZone.convertUTCToLocal(instant);                  localInstant = iField.addWrapField(localInstant, value);                 return iZone.convertLocalToUTC(localInstant, false);              }          }          public long set(long instant, int value) {              long localInstant = iZone.convertUTCToLocal(instant);              localInstant = iField.set(localInstant, value);             long result = iZone.convertLocalToUTC(
Node parseInputs() {          boolean staleInputs = false;       if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (CompilerInput input : inputs) {          if (options.dependencyOptions.needsManagement() && options.closurePass) {          for (Compiler
