public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return multiply(100).doubleValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }      /**       * @return the fraction percentage as a <tt>float</tt>.       */      public float percentageValue() {         return multiply(100).floatValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }      /**       * @return the fraction percentage as a <tt>float</tt>.       */      public float percentageValue() {         return multiply(100).floatValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }      /**       * @return the fraction percentage as a <tt>float</tt>.       */      public float percentageValue() {         return multiply(100).floatValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }      /**       * @return the fraction percentage as a <tt>float</tt>.       */      public float percentageValue() {         return multiply(100).floatValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }      /**       * @return the fraction percentage as a <tt>float</tt>.       */      public float percentageValue() {         return multiply(100).floatValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }      /**       * @return the fraction percentage as a <tt>float</tt>.       */      public float percentageValue() {         return multiply(100).floatValue();      }      /**       * @return the fraction percentage as a <tt>long</tt>.       */      public long percentageValue() {         return multiply(100).longValue();      }
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return true;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:         return false;        }        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:         return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:         case Token.ARRAYLIT:          return false;        }        case Token.FUNCTION:        case Token.REGEXP:          case Token.ARRAYLIT:           return false;        }        case Token.FUNCTION:         case Token.REGEXP:           case Token.ARRAYLIT:            return false;         }         case Token.FUNCTION:          case Token.REGEXP:
protected UnivariatePointValuePair doOptimize() {                  if (checker!= null) {                      if (checker.converged(getIterations(), previous, current)) {                         return current;                      }                   }               }               if (checker!= null) {                   if (checker.converged(getIterations(), previous, current)) {                       return current;                   }                  }               }               if (checker!= null) {                   if (checker.converged(getIterations(), previous, current)) {                       return current;                   }                  }               }               if (checker!= null) {                   if (checker.converged(getIterations(), previous, current)) {                       return current;                   }                  }               }               if (checker!= null) {                   if (checker.converged(getIterations(), previous, current)) {                       return current;                   }                  }               }               if (checker!= null) {                   if (checker.converged(getIterations(), previous, current)) {                       return current;                   }                   }                }               if (checker!= null) {                   if (
public double solve(final UnivariateRealFunction f,               return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }          return solve(f, min, yMin, max, yMax, initial, yInitial);
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < 0 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                  minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                  minutesOffset = hoursInMinutes - minutesOffset;              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }               int offset = 0;               try {                   int hoursInMinutes = hoursOffset * 60;                  if (hoursInMinutes < 0) {                       minutesOffset = hoursInMinutes - minutesOffset;                  } else {                       minutesOffset = hoursInMinutes + minutesOffset;                  }                   int hoursInMinutes = hoursOffset * 60;                  if (hoursInMinutes < 0) {                       minutesOffset = hoursInMinutes - minutesOffset
public long getUnitMillis() {       * @return zero always       */      public int compareTo(DurationField durationField) {         if (durationField.isSupported()) {             return 1;         }        if (durationField.isSupported() &&
private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                  assignedToUnknownValue = true;               }              maybeUnreferenced.remove(current);             }           }           if (assignedToUnknownValue && hasPropertyAssign) {               changes = markReferencedVar(var) || changes;               maybeUnreferenced.remove(current);               current--;             }           }           if (assignedToUnknownValue && hasPropertyAssign) {               changes = markReferencedVar(var) || changes;               maybeUnreferenced.remove(current);               current--;             }           }           if (assignedToUnknownValue && hasPropertyAssign) {               changes = markReferencedVar(var) || changes;               maybeUnreferenced.remove(current);               current--;             }           }           if (assignedToUnknownValue && hasPropertyAssign) {               changes = markReferencedVar(var) || changes;               maybeUnreferenced.remove(current);               current--;             }           }           if (assignedToUnknownValue && hasPropertyAssign) {               changes = markReferencedVar(var) || changes;               maybeUnreferenced.remove(current);                current--;             }           }           if (assignedToUnknownValue && hasPropertyAssign) {               changes = markReferencedVar(var) || changes;                maybeUnreferenced.remove(current);                 current--;              }           }           if (assignedToUnknownValue && has
public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                  return -val1;              case 0:                  return 0L;              case -1:                   return -val1;               case 0:                   return 0L;               case -1:                   return -val1;                case 0:                   return 0L;                 case -1:                    return -val1;                  case 0:                      return 0L;                    case -1:                       return -val1;
private boolean isVarInlineForbidden(Var var) {        */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;       if (refs.isEmpty()) {         return false;       }        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();          isInlinableObject(parent);          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();           isInlinableObject(parent);          }          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();           isInlinableObject(parent);          }          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();           isInlinableObject(parent);          }          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();           isInlinableObject(parent);          }          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();           isInlinableObject(parent);          }          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();           isInlinableObject(parent);          }          ret = false;        }         for (Reference ref : refs) {           Node name = ref.getNode();           Node parent = ref.getParent();            isInlinableObject(parent);           }           ret = false;         }          for (Reference ref : refs) {
public EqualsBuilder append(Object lhs, Object rhs) {           }           Class lhsClass = lhs.getClass();           if (!lhsClass.isArray()) {                  isEquals = lhs.equals(rhs);           } else if (lhs.getClass()!= rhs.getClass()) {               this.setEquals(false);           }
private Node tryMinimizeIf(Node n) {              !mayEffectMutableState(lhs)) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild();             if (!mayEffectMutableState(lhs)) {                 n.removeChild(cond);              }              Node assignName = thenOp.removeFirstChild();              if (!mayEffectMutableState(lhs)) {                  n.removeChild(cond);              }              Node assignName = thenOp.removeFirstChild();              if (!mayEffectMutableState(lhs)) {                  n.removeChild(cond);              }              Node assignName = thenOp.removeFirstChild();              if (!mayEffectMutableState(lhs)) {                  n.removeChild(cond);              }              Node assignName = thenOp.removeFirstChild();              if (!mayEffectMutableState(lhs)) {                  n.removeChild(cond);              }              Node assignName = thenOp.removeFirstChild();              if (!mayEffectMutableState(lhs)) {                  n.removeChild(cond);              }              Node assignName = thenOp.removeFirstChild();              if (!mayEffectMutableState(lhs)) {                  n.removeChild(cond);              }               Node assignName = thenOp.removeFirstChild();               if (!mayEffectMutableState(lhs)) {                   n.removeChild(cond);                }                Node assignName = thenOp.removeFirstChild();                if (!mayEffectMutableState(lhs)) {                    n.removeChild(cond);                 }                  Node assignName = thenOp.removeFirstChild();                  if (!mayEffectMutableState(lhs)) {                      n.removeChild(cond);
private boolean isInlinableObject(List<Reference> refs) {     if (refs.isEmpty()) {       return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;     }      return false;
private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar()) {           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);           }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }          }
public void exitScope(NodeTraversal t) {        if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);          injectedDecls.clear();           transformation = null;
public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return anyCollection();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) anyCollection();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) anyCollection();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) anyCollection();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return (T) reportMatcher(new InstanceOf(clazz)).<T>returnNull();       }       /**        * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {
protected UnivariatePointValuePair doOptimize() {                       }                   } else {                   return                                best(current,                                     previous,                               isMinim);                   }                  incrementIterationCount();               }               ++iter;               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }               incrementIterationCount();               }                incrementIterationCount();                }                incrementIterationCount();                }
public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true, false);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, true, true, false, true, false, true);      }      /**       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str
private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject(instance);              if (injected!= null) {                  injectionOccurred |= true;                  mocks.remove(injected);                  is buggy program
public static Node tryFinally(Node tryBody, Node finallyBody) {    public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock(), tryBody.getFirstChild());      Preconditions.checkState(catchNode.isCatch(), catchNode.getFirstChild());     Node catchBody = block(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    }
protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(true);             if ((Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);                 is buggy program
public boolean setPrototype(PrototypeObjectType prototype) {        return false;      }     boolean replacedPrototype = prototype!= null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", null, true);      this.prototype.setOwnerFunction(this);      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor();        if (superClass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType subclass = getSubclassConstructor(prototype);        if (subclass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType superClass = getSuperClassConstructor();        if (superClass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType subclass = getSubclassConstructor(prototype);        if (subclass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType superClass = getSuperClassConstructor();        if (superClass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType subclass = getSubclassConstructor(prototype);        if (subclass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType superClass = getSuperClassConstructor();        if (superClass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType subclass = getSubclassConstructor(prototype);        if (subclass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType superClass = getSuperClassConstructor();        if (superClass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType subclass = getSubclassConstructor(prototype);        if (subclass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType superClass = getSuperClassConstructor();        if (superClass == null) {          throw new IllegalArgumentException("Null 'prototype' argument.");        }        FunctionType subclass = getSubclassConstructor(prototype);         if (subclass == null) {           throw new IllegalArgumentException("Null 'prototype' argument.");         }         FunctionType superClass = getSuperClass
public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);                 final double[][] eData = e.getData();                 final double[][] wData = new double[m][p];                 double[] ei1 = eData[0];                 for (int i = 0; i < p - 1; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                      final double[] wi  = w
public boolean apply(Node input) {                   case Token.REGEXP:                   case Token.NEW:                     return true;                  }                  return false;                }              }              return false;             }             return false;            }            return false;           }           return false;          }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }          return false;         }
public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos);               }
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);         if (v2D == null) {             return null;         }         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));         if (loc1 == null) {             return null;         }          Location loc2 = getRemainingRegion().checkPoint(line2.toSubSpace(v2D));         if (loc2 == null) {             return null;         }          Location loc3 = getRemainingRegion().checkPoint(line3.toSubSpace(v2D));         if (loc3 == null) {             return null;         }          Location loc4 = getRemainingRegion().checkPoint(line4.toSubSpace(v2D));         if (loc4 == null) {             return null;         }          Location loc5 = getRemainingRegion().checkPoint(line5.toSubSpace(v2D));         if (loc5 == null) {             return null;         }          Location loc6 = getRemainingRegion().checkPoint(line6.toSubSpace(v2D));         if (loc6 == null) {             return null;         }          Location loc7 = getRemainingRegion().checkPoint(line7.toSubSpace(v2D));         if (loc7 == null) {             return null;         }          Location loc8 = getRemainingRegion().checkPoint(line8.toSubSpace(v2D));         if (loc8 == null) {             return null;         }          Location loc9 = getRemainingRegion().checkPoint(line9.toSubSpace(v2D));         if (loc9 == null) {             return null;         }          Location loc10 = getRemainingRegion().checkPoint(line10.toSubSpace(v2D));         if (loc10 == null) {             return null;         }          Location loc11 = getRemainingRegion().checkPoint(line11.toSubSpace(v2D));         if (loc11 == null) {             return null;         }          Location loc12 = getRemainingRegion().checkPoint(line12.toSubSpace(v2D));         if (loc12 == null) {             return null;
public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return                  decode(x);          }
private boolean canInline(          }        }     }
public ElitisticListPopulation(final List<Chromosome> chromosomes,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(getPopulationSize(populationLimit),
void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);          addExpr(first, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }       addExpr(first, p, context);        cc.addOp(opstr, true);         addExpr(last, p + 1, rhsContext);        }        return;      }
public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false, instant);              }           }
protected PointVectorValuePair doOptimize() {                       if (checker!= null) {                           if (checker.converged(getIterations(), previous, current)) {                                setCost(currentCost);                               return current;                           }                       }
void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally         * block. See ECMA 262 Sections 8.9 & 12.14         */       if (NodeUtil.hasFinally(n)) {         Node finallyBlock = n.getLastChild();         tryMinimizeExits(finallyBlock, exitType, labelName);       }      }     }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }
public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = params.getParameter(0);         if (param == null || param.length() == 0) {            setter.addValue(true);            return 0;         }          if (params.getBoolean(1)) {            setter.addValue(true);             return 1;         }          if (params.getBoolean(2)) {            setter.addValue(true);             return 2;         }          if (params.getBoolean(3)) {            setter.addValue(true);             return 3;         }          if (params.getBoolean(4)) {            setter.addValue(true);             return 4;         }          if (params.getBoolean(5)) {            setter.addValue(true);             return 5;         }          if (params.getBoolean(6)) {            setter.addValue(true);             return 6;         }          if (params.getBoolean(7)) {            setter.addValue(true);             return 7;         }          if (params.getBoolean(8)) {            setter.addValue(true);             return 8;         }          if (params.getBoolean(9)) {            setter.addValue(true);             return 9;         }          if (params.getBoolean(10)) {            setter.addValue(true);             return 10;         }          if (params.getBoolean(11)) {            setter.addValue(true);             return 11;         }          if (params.getBoolean(12)) {            setter.addValue(true);              return 12;          }           if (params.getBoolean(13)) {             setter.addValue(true);
private static final long serialVersionUID = 9386874258972L;                 private volatile int iPeriod;                 private final long serialVersionUID = 9386874258972L;                 private volatile int iPeriod;                 private final long serialVersionUID = 9386874258972L;                 private volatile int iPeriod;                 private final long serialVersionUID = 9386874258972L;                 private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                  private final long serialVersionUID = 9386874258972L;                  private volatile int iPeriod;                   private final long serialVersionUID = 9386874258972L;                   private volatile int iPeriod;                   private final long serialVersionUID = 9386874258972L;                   private volatile int iPeriod;                   private final long serialVersionUID = 9386874258972L;                   private volatile int iPeriod;                    private final long serialVersionUID = 9386874258972L;                    private volatile int iPeriod;                     private final long serialVersionUID = 9386874258972L;                     private volatile int iPeriod;
private static synchronized String getConvertedId(String id) {
public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType();    }    public boolean isNumberObjectType() {     return!isNoObjectType() &&!isNoResolvedType();    }    }    public boolean isObjectType() {     return isNoObjectType() || isNoResolvedType();    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }    }
public TimeSeries createCopy(int start, int end)               throw new IllegalArgumentException("Requires start <= end.");            }            TimeSeries copy = (TimeSeries) super.clone();            copy.data = new java.util.ArrayList();            if (this.data.size() > 0) {               for (int index = start; index <= end; index++) {                  if (this.data.get(index)!= null) {
public String escape(String str) {      public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             char c = str.charAt(i);              String entityName = this.entityName(c);              if (entityName == null) {                 if (c > 0x7F) { writer.write("&
public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */      public void addHours(final int hours) {         if (hours!= 0) {              setMillis(getChronology().hours().add(getMillis(), hours));         }      }
public double integrate(final FirstOrderDifferentialEquations equations,                   interpolator.storeTime(stepStart);                  stepSize = 0;                  loop     = false;                  } else {                        stepSize = 0;                       interpolator.storeTime(stepStart);                       stepSize = 0;                   }                   loop     = false;                   } else {                        stepSize = 0;                       interpolator.storeTime(stepStart);                       stepSize = 0;                   }                   loop                   } else {                        stepSize = 0;                       interpolator.storeTime(stepStart);                       stepSize = 0;                   }                   loop                   } else {                       stepSize = 0;                      interpolator.storeTime(stepStart);                      stepSize = 0;                   }                   loop                   } else {                       stepSize = 0;                      interpolator.storeTime(stepStart);                      stepSize = 0;                   }                   loop                   } else {                       stepSize = 0;                      interpolator.storeTime(stepStart);                       stepSize = 0;                    }                    loop
public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try {                  final Float f = createFloat(str);                 if (!(f.isInfinite() || (f.floatValue() == 0.0F &&!allZeros))) {                      return f;                  } } catch (final NumberFormatException nfe) {          }          try {                  final Double d = createDouble(str);                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D &&!allZeros))) {                      return d;                  } } catch (final NumberFormatException nfe) {          }          try {                  final String s = createString(str);                 if (!(s.isInfinite() || (s.doubleValue() == 0.0S &&!allZeros))) {                      return s;                  } } } catch (final NumberFormatException nfe) {          }          try {                  final String s = createString(str);                 if (!(s.isInfinite() || (s.doubleValue() == 0.0S &&!allZeros))) {                      return s;                  } } } catch (final NumberFormatException nfe) {          }           try {                   final String s = createString(str);                  if (!(s.
public int getDimension() {              indices[i] = idx;          }         int idx = 1;         while (count < index) {             count += idx;            incrementidx();             ++idx;         }         --idx;         indices[last] = idx;          return indices;      }
public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false, instant);              }           }
private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();     boolean hasSideEffects = false;     if (block.hasChildren()) {       Preconditions.checkState(block.hasOneChild());       Node stmt = block.getFirstChild();       if (stmt.isReturn()) {         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler)) {         hasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);       }      }      Node cArg = callNode.getFirstChild().getNext();      if (!hasSideEffects && NodeUtil.mayHaveSideEffects(cArg, compiler
private static final long serialVersionUID = -7105341425736035847L;      private MockitoCore mockitoCore = new MockitoCore();      private ReturnsEmptyValues delegate = new ReturnsEmptyValues();       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =
public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException {          Object clone = createCopy(getItemCount() - 1, 0);           return clone;       }
public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);         int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          chrono = parseChronology(chrono);          int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);         }          chrono = selectChronology(chrono);          int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);         }          chrono = parseChronology(chrono);          int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);         }          chrono = selectChronology(chrono);          int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(               instantLocal, chrono, iLocale, iPivotYear, defaultYear);         }          chrono = parseChronology(chrono);          int defaultYear = chrono.year().get(instantLocal);          DateTimeParserBucket bucket = new DateTimeParserBucket(               instantLocal, chrono, iLocale, iPivotYear, defaultYear);         }          chrono = selectChronology(chrono);          int defaultYear = chrono.year().get(instantLocal);           DateTimeParserBucket bucket = new DateTimeParserBucket(                instantLocal, chrono, iLocale, iPivotYear, defaultYear);          }
public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                  "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",                  undesired.getLocation()          ));      }
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;         }       while (s.charAt(0) >= '0' && s.charAt(0) <= '9') {         s = s.substring(1);       }        for (int i = 1; i < length; i++) {         if (             !Character.isJavaIdentifierPart(s.charAt(i)) ||              s.charAt(i) >= '0' && s.charAt(i) <= '9') {            return false;          }         }         for (int i = 1; i < length; i++) {          if (             !Character.isJavaIdentifierPart(s.charAt(i)) ||              s.charAt(i) >= '0' && s.charAt(i) <= '9') {            return false;          }         }       }        for (int i = 1; i < length; i++) {         if (            !Character.isJavaIdentifierPart(s.charAt(i)) ||              s.charAt(i) >= '0' && s.charAt(i) <= '9') {           return false;          }         }       }        for (int i = 1; i < length; i++) {         if (            !Character.isJavaIdentifierPart(s.charAt(i)) ||              s.charAt(i) >= '0' && s.charAt(i) <= '9') {           return false;          }         }       }        for (int i = 1; i < length; i++) {         if (            !Character.isJavaIdentifierPart(s.charAt(i)) ||              s.charAt(i) >= '0' && s.charAt(i) <= '9') {           return false;          }         }       }        for (int i = 1; i < length; i++) {
private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType!= null) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());        } else {          type = getJSType(constructor).restrictByNotNullOrUndefined();          if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {             FunctionType fnType = type.toMaybeFunctionType();           if (fnType!= null) {              visitParameterList(t, n, fnType);              ensureTyped(t, n, fnType.getInstanceType());           } else {              type = getJSType(constructor).restrictByNotNullOrUndefined();              if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {                 FunctionType fnType = type.toMaybeFunctionType();               if (fnType!= null) {                  visitParameterList(t, n, fnType);                  ensureTyped(t, n, fnType.getInstanceType());              } else {                 type = getJSType(constructor).restrictByNotNullOrUndefined();                 if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {                    FunctionType fnType = type.toMaybeFunctionType();                  if (fnType!= null) {                     visitParameterList(t, n, fnType);                     ensureTyped(t, n, fnType.getInstanceType());                  } else {                     type = getJSType(constructor).restrictByNotNullOrUndefined();                    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {                       FunctionType fnType = type.toMaybeFunctionType();
private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.listSeparator();        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current!= n);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNonOperator.getFirstChild(), rightPrecedence, rhsContext);    }      addExpr(firstNon
public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public int getRangeAxisIndex(ValueAxis axis) {         if (axis == null) {              throw new IllegalArgumentException("Null 'axis' argument.");         }           int result = this.rangeAxes.indexOf(axis);           if (result < 0) {               Plot parent = getParent();              if (parent == null) {                  throw new IllegalArgumentException("Null 'parent' argument.");              }              int result = this.rangeAxes.indexOf(axis);              if (result < 0) {                  Plot parent = getParent();                 if (parent == null) {                     throw new IllegalArgumentException("Null 'parent' argument.");                 }              }              int result = this.rangeAxes.indexOf(axis);              if (result < 0) {                  Plot parent = getParent();                 if (parent == null) {                     throw new IllegalArgumentException("Null 'parent' argument.");                 }              }              int result = this.rangeAxes.indexOf(axis);              if (result < 0) {                  Plot parent = getParent();                 if (parent == null) {                     throw new IllegalArgumentException("Null 'parent' argument.");                 }              }              int result = this.rangeAxes.indexOf(axis);              if (result < 0) {                  Plot parent = getParent();                 if (parent == null) {                     throw new IllegalArgumentException("Null 'parent' argument.");                  }               }               int result = this.rangeAxes.indexOf(axis);               if (result
public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {         if (rowKey == null) {             throw new IllegalArgumentException("Null 'rowKey' argument.");         }         int index = getRowIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index = getIndex(rowKey);         if (index >= 0) {             removeRow(index);         }       }         int index =
public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) || (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (Double.isNaN(x) && Double.isNaN(y));      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y == x);      }      /**       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return (x == y) && (y ==
public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */      public void addMinutes(final int minutes) {         if (minutes!= 0) {              setMillis(getChronology().minutes().add(getMillis(), minutes));         }      }
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,      do {        switch (token) {          case STAR:            if (ignoreStar) {            } else {              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());              }              if (builder.length() > 0) {               lineStart = builder.charCodeAt(0);               lineEnd = builder.charCodeAt(builder.length());               }               if (builder.length() > 0) {                lineStart = builder.charCodeAt(0);                lineEnd = builder.charCodeAt(builder.length());                }                if (builder.length() > 0) {
public MockSettings defaultAnswer(Answer defaultAnswer) {       }       public boolean isSerializable() {          return extraInterfaces!= null && java.util.Arrays.asList(extraInterfaces).contains(Serializable.class);       }       public void initiateMockName(Class classToMock) {         if (extraInterfaces == null) {             return;         }
void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;        this.maybeAliased =!assignNode.getParent().isExprResult();        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||             NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =             maybeAliased ||             NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||              NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =             maybeAliased ||              NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||               NodeUtil.mayHaveSideEffects(assignNode.getFirstChild());       }        this.mayHaveSecondarySideEffects =              maybeAliased ||               NodeUtil.mayHaveSideEffects(assignNode.get
private Node tryFoldComparison(Node n, Node left, Node right) {            && right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)));           int rhType = right.getType();           switch (rhType) {            case Token.VOID:              if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {                  return n;               }               int rhType = right.getType();               switch (rhType) {                 case Token.VOID:                  if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {                      return n;                   }                  int rhType = right.getType();                  switch (rhType) {                   case Token.VOID:                   if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {                       return n;                   }                   int rhType = right.getType();                   switch (rhType) {                     case Token.VOID:                     if (!NodeUtil.isLiteralValue(right.getFirstChild(), false)) {                         return n;                      }                      int rhType = right.getType();                     switch (rhType) {                       case Token.VOID:                       if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
private void inlineAliases(GlobalNamespace namespace) {          continue;        }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 1) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 2) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 3) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 4) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 5) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 6) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 7) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 8) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 9) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 10) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 11) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 12) {         continue;       }       if (name.globalSets == 1 && name.localSets == 0 &&
private static boolean isAssignable(Type type, ParameterizedType toParameterized                 toClass, typeVarAssigns);         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {             Type toTypeArg = entry.getValue();             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());            if (toTypeArg.isAssignableFrom(fromTypeArg)) {
public static boolean isEmpty(boolean[] array) {          } else if (element!= null) {              type = element.getClass();          } else {             type = Object.class;          } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);          return false;         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }         }
public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }              else {                  this.seriesKeys = null;                  this.categoryKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;               }            }               else {                   this.categoryKeys = null;                  this.seriesKeys = null;                }             }               else {                    this.categoryKeys = null;
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }        if (inferred) {         inferred =!(rhsValue!= null &&             rhsValue.isFunction() &&             (info!= null ||!scope.isDeclared(qName, false)));         }         if (!inferred) {           return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }        }        if (!inferred) {          return;         }        }        if (!scope.isDeclared(qName, false)) {          return;         }
