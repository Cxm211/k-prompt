public Fraction divide(final int i) {       * @return the fraction percentage as a <tt>double</tt>.       */      public double percentageValue() {         return 100 * doubleValue();      }      /**
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {         return false;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:
protected UnivariatePointValuePair doOptimize() {                  if (checker != null) {                      if (checker.converged(iter, previous, current)) {                         return best(current, previous, isMinim);                      }                  }
public double solve(final UnivariateRealFunction f,              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          }         if (yMin * yMax > 0) {             throw MathRuntimeException.createIllegalArgumentException(                   NON_BRACKETING_MESSAGE, min, max, yMin, yMax);         }          return solve(f, min, yMin, max, yMax, initial, yInitial);
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff          if (hoursOffset < -23 || hoursOffset > 23) {              throw new IllegalArgumentException("Hours out of range: " + hoursOffset);          }         if (minutesOffset < -59 || minutesOffset > 59) {              throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);          }         if (hoursOffset > 0 && minutesOffset < 0) {             throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset);         }          int offset = 0;          try {              int hoursInMinutes = hoursOffset * 60;              if (hoursInMinutes < 0) {                 minutesOffset = hoursInMinutes - Math.abs(minutesOffset);              } else {                  minutesOffset = hoursInMinutes + minutesOffset;              }
public long getUnitMillis() {       * @return zero always       */      public int compareTo(DurationField durationField) {          return 0;      }
private void interpretAssigns() {                  assign.assignNode.getLastChild(), true)) {                assignedToUnknownValue = true;              }             if (assign.maybeAliased) {               maybeEscaped = true;             }            }           if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {              changes = markReferencedVar(var) || changes;              maybeUnreferenced.remove(current);              current--;
public static int safeMultiply(int val1, int val2) {      public static long safeMultiply(long val1, int val2) {          switch (val2) {              case -1:                 if (val1 == Long.MIN_VALUE) {                     throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2);                 }                  return -val1;              case 0:                  return 0L;
private boolean isVarInlineForbidden(Var var) {       */      private boolean isInlinableObject(List<Reference> refs) {        boolean ret = false;       Set<String> validProperties = Sets.newHashSet();        for (Reference ref : refs) {          Node name = ref.getNode();          Node parent = ref.getParent();
public EqualsBuilder append(Object lhs, Object rhs) {          }          Class lhsClass = lhs.getClass();          if (!lhsClass.isArray()) {             if (lhs instanceof java.math.BigDecimal) {                 isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);             } else {                  isEquals = lhs.equals(rhs);             }          } else if (lhs.getClass() != rhs.getClass()) {              this.setEquals(false);
private Node tryMinimizeIf(Node n) {               !mayEffectMutableState(lhs) &&               (!mayHaveSideEffects(cond) ||                   (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {              n.removeChild(cond);              Node assignName = thenOp.removeFirstChild();
private boolean isInlinableObject(List<Reference> refs) {           if (gramps.isDelProp()) {             return false;           }
private void findAliases(NodeTraversal t) {          Node n = v.getNode();          int type = n.getType();          Node parent = n.getParent();         if (parent.isVar() &&             n.hasChildren() && n.getFirstChild().isQualifiedName()) {            String name = n.getString();            Var aliasVar = scope.getVar(name);            aliases.put(name, aliasVar);
public void exitScope(NodeTraversal t) {        if (t.getScopeDepth() == 2) {          renameNamespaceShadows(t);         injectedDecls.clear();          aliases.clear();          forbiddenLocals.clear();          transformation = null;
public static Collection anyCollection() {       * @return <code>null</code>.        */       public static <T> T isA(Class<T> clazz) {          return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);       }       /**
protected UnivariatePointValuePair doOptimize() {                      }                  } } else {                 return best(best,                              best(current,                                   previous,                                  isMinim),                              isMinim);              }              ++iter;
public static String escapeJava(String str) {       * @throws IOException if error occurs on underlying Writer       */      public static void escapeJava(Writer out, String str) throws IOException {         escapeJavaStyleString(out, str, false, false);      }      /**
private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object      private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {          for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {              Field field = it.next();             Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();              if (injected != null) {                  injectionOccurred |= true;                  mocks.remove(injected);
public static Node tryFinally(Node tryBody, Node finallyBody) {    public static Node tryCatch(Node tryBody, Node catchNode) {      Preconditions.checkState(tryBody.isBlock());      Preconditions.checkState(catchNode.isCatch());     Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);      return new Node(Token.TRY, tryBody, catchBody);    }
protected void computeGeometricalProperties() {          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false);             if (tree.getCut() == null && (Boolean) tree.getAttribute()) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);
public boolean setPrototype(PrototypeObjectType prototype) {        return false;      }     PrototypeObjectType oldPrototype = this.prototype;     boolean replacedPrototype = oldPrototype != null;      this.prototype = prototype;      this.prototypeSlot = new SimpleSlot("prototype", prototype, true);      this.prototype.setOwnerFunction(this);     if (oldPrototype != null) {       oldPrototype.setOwnerFunction(null);     }      if (isConstructor() || isInterface()) {        FunctionType superClass = getSuperClassConstructor();
public RealMatrix getU()              if (m >= n) {                  final RealMatrix e =                     eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);                  final double[][] eData = e.getData();                  final double[][] wData = new double[m][p];                  double[] ei1 = eData[0];                 for (int i = 0; i < p; ++i) {                      final double mi = mainBidiagonal[i];                      final double[] ei0 = ei1;                      final double[] wi  = wData[i];                     if (i < n - 1) {                          ei1 = eData[i + 1];                          final double si = secondaryBidiagonal[i];                          for (int j = 0; j < p; ++j) {                              wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];                          }                     } else {                          for (int j = 0; j < p; ++j) {                             wi[j] = mi * ei0[j] / singularValues[j];                          }                     }                 }                  for (int i = p; i < m; ++i) {                      wData[i] = new double[p];
public boolean apply(Node input) {                    case Token.REGEXP:                    case Token.NEW:                      return true;                   case Token.NAME:                     Var var = scope.getOwnSlot(input.getString());                     if (var != null                         && var.getParentNode().isCatch()) {                       return true;                     }                  }                  return false;                }
public static Number createNumber(String str) throws NumberFormatException {          if (decPos > -1) {              if (expPos > -1) {                 if (expPos < decPos || expPos > str.length()) {                      throw new NumberFormatException(str + " is not a valid number.");                  }                  dec = str.substring(decPos + 1, expPos);
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin          Vector2D v2D = line1.intersection(line2);         if (v2D == null) {             return null;         }          Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
public FitnessFunction() {           * @return the original objective variables, possibly repaired.           */          public double[] repairAndDecode(final double[] x) {             return boundaries != null && isRepairMode ?                 decode(repair(x)) :                  decode(x);          }
private boolean canInline(           if (convention.getSingletonGetterClassName(callNode) != null) {             return false;           }          }        }
public ElitisticListPopulation(final List<Chromosome> chromosomes,       */      public ElitisticListPopulation(final int populationLimit, final double elitismRate) {          super(populationLimit);         setElitismRate(elitismRate);      }      /**
void add(Node n, Context context) {          cc.addOp(opstr, true);          addExpr(last, p, rhsContext);        } else {         unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);        }        return;      }
public long add(long instant, long value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false, instant);              }          }
protected PointVectorValuePair doOptimize() {                      if (checker != null) {                         if (checker.converged(getIterations(), previous, current)) {                              setCost(currentCost);                              return current;                          }
void tryMinimizeExits(Node n, int exitType, String labelName) {         * can cause problems if it changes the completion type of the finally         * block. See ECMA 262 Sections 8.9 & 12.14         */      }
public BooleanOptionHandler(        @Override        public int parseArguments(Parameters params) throws CmdLineException {         String param = null;         try {           param = params.getParameter(0);         } catch (CmdLineException e) {}          if (param == null) {            setter.addValue(true);
private static final long serialVersionUID = 9386874258972L;           private static final long START_1972 = 2L * 365L * 86400L * 1000L;            private volatile int iPeriod;
private static synchronized String getConvertedId(String id) {              map = new HashMap<String, String>();              map.put("GMT", "UTC");             map.put("WET", "WET");             map.put("CET", "CET");             map.put("MET", "CET");             map.put("ECT", "CET");             map.put("EET", "EET");              map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu");              map.put("AST", "America/Anchorage");
public boolean isNoObjectType() {    }    public final boolean isEmptyType() {     return isNoType() || isNoObjectType() || isNoResolvedType() ||         (registry.getNativeFunctionType(              JSTypeNative.LEAST_FUNCTION_TYPE) == this);    }    public boolean isNumberObjectType() {
public TimeSeries createCopy(int start, int end)              throw new IllegalArgumentException("Requires start <= end.");           }           TimeSeries copy = (TimeSeries) super.clone();          copy.minY = Double.NaN;          copy.maxY = Double.NaN;           copy.data = new java.util.ArrayList();           if (this.data.size() > 0) {               for (int index = start; index <= end; index++) {
public String escape(String str) {      public void escape(Writer writer, String str) throws IOException {          int len = str.length();          for (int i = 0; i < len; i++) {             int c = Character.codePointAt(str, i);               String entityName = this.entityName(c);              if (entityName == null) {                 if (c >= 0x010000 && i < len - 1) {                     writer.write("&                     writer.write(Integer.toString(c, 10));                     writer.write(';');                     i++;                 } else if (c > 0x7F) {  writer.write("&                      writer.write(Integer.toString(c, 10));                      writer.write(';');
public void setHourOfDay(final int hourOfDay) {       * @throws IllegalArgumentException if the value is invalid       */      public void addHours(final int hours) {         if (hours != 0) {              setMillis(getChronology().hours().add(getMillis(), hours));         }      }
public double integrate(final FirstOrderDifferentialEquations equations,                   interpolator.storeTime(stepStart);                   System.arraycopy(y, 0, yTmp, 0, y0.length);                   hNew     = 0;                   stepSize = 0;                    loop     = false;                } else {
public static Number createNumber(final String str) throws NumberFormatException          final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);          try { if(numDecimals <= 7){                  final Float f = createFloat(str);                  if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {                      return f;                  }             } } catch (final NumberFormatException nfe) {          }          try { if(numDecimals <= 16){                  final Double d = createDouble(str);                  if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {                      return d;                  }             } } catch (final NumberFormatException nfe) {          }
public int getDimension() {              indices[i] = idx;          }         indices[last] = index - count;          return indices;      }
public long add(long instant, int value) {              } else {                 long localInstant = iZone.convertUTCToLocal(instant);                 localInstant = iField.add(localInstant, value);                return iZone.convertLocalToUTC(localInstant, false, instant);              }          }
private CanInlineResult canInlineReferenceDirectly(      Node block = fnNode.getLastChild();      Node cArg = callNode.getFirstChild().getNext();
private static final long serialVersionUID = -7105341425736035847L;      private transient MockitoCore mockitoCore;      private transient ReturnsEmptyValues delegate;       public Object answer(InvocationOnMock invocation) throws Throwable {           GenericMetadataSupport returnTypeGenericMetadata =                   actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());           Class<?> rawType = returnTypeGenericMetadata.rawType();          instantiateMockitoCoreIfNeeded();          instantiateDelegateIfNeeded();           if (!mockitoCore.isTypeMockable(rawType)) {               return delegate.returnValueFor(rawType);           }
public void delete(int start, int end) {       *         subclasses may differ.        */       public Object clone() throws CloneNotSupportedException {          TimeSeries clone = (TimeSeries) super.clone();          clone.data = (List) ObjectUtilities.deepClone(this.data);           return clone;       }
public int parseInto(ReadWritableInstant instant, String text, int position) {          long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology();         int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);
public void noMoreInteractionsWantedInOrder(Invocation undesired) {          throw new VerificationInOrderFailure(join(                  "No interactions wanted here:",                  new LocationImpl(),                 "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",                  undesired.getLocation()          ));      }
public static boolean isJSIdentifier(String s) {        int length = s.length();        if (length == 0 ||           Character.isIdentifierIgnorable(s.charAt(0)) ||            !Character.isJavaIdentifierStart(s.charAt(0))) {          return false;        }        for (int i = 1; i < length; i++) {         if (Character.isIdentifierIgnorable(s.charAt(i)) ||              !Character.isJavaIdentifierPart(s.charAt(i))) {            return false;          }
private void visitNew(NodeTraversal t, Node n) {      JSType type = getJSType(constructor).restrictByNotNullOrUndefined();      if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {        FunctionType fnType = type.toMaybeFunctionType();       if (fnType != null && fnType.hasInstanceType()) {          visitParameterList(t, n, fnType);          ensureTyped(t, n, fnType.getInstanceType());        } else {
private void unrollBinaryOperator(      Node current = firstNonOperator;      do {        current = current.getParent();       cc.addOp(opStr, true);        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);      } while (current != n);    }
public void setRangeAxes(ValueAxis[] axes) {       * @since 1.0.7        */       public int getRangeAxisIndex(ValueAxis axis) {          if (axis == null) {              throw new IllegalArgumentException("Null 'axis' argument.");          }           int result = this.rangeAxes.indexOf(axis);  if (result < 0) {              Plot parent = getParent();
public void removeRow(int rowIndex) {       */       public void removeRow(Comparable rowKey) {           int index = getRowIndex(rowKey);          if (index < 0) {              throw new UnknownKeyException("Row key (" + rowKey                       + ") not recognised.");          }           removeRow(index);       }
public static double cosh(double x) {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) {         return equals(x, y, 1);      }      /**
public void setMinuteOfHour(final int minuteOfHour) {       * @throws IllegalArgumentException if the value is invalid       */      public void addMinutes(final int minutes) {         if (minutes != 0) {              setMillis(getChronology().minutes().add(getMillis(), minutes));         }      }
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,     int lineStartChar = -1;      do {        switch (token) {          case STAR:            if (ignoreStar) {             lineStartChar = stream.getCharno() + 1;            } else {              if (builder.length() > 0) {
public MockSettings defaultAnswer(Answer defaultAnswer) {      }       public boolean isSerializable() {          return serializable;       }       public void initiateMockName(Class classToMock) {
void apply() {        this.nameNode = nameNode;        this.isPropertyAssign = isPropertyAssign;       this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);        this.mayHaveSecondarySideEffects =            maybeAliased ||            NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
private Node tryFoldComparison(Node n, Node left, Node right) {            && right.getString().equals("undefined"))            || (Token.VOID == right.getType()                && NodeUtil.isLiteralValue(right.getFirstChild(), false)));     int lhType = getNormalizedNodeType(left);     int rhType = getNormalizedNodeType(right);      switch (lhType) {        case Token.VOID:          if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
private void inlineAliases(GlobalNamespace namespace) {          continue;        }       if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&            name.aliasingGets > 0) {
private static boolean isAssignable(Type type, ParameterizedType toParameterized                  toClass, typeVarAssigns);         for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {             Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);             Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
public static boolean isEmpty(boolean[] array) {          } else if (element != null) {              type = element.getClass();          } else {             throw new IllegalArgumentException("Arguments cannot both be null");                      } @SuppressWarnings("unchecked")          T[] newArray = (T[]) copyArrayGrow1(array, type);
public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,              }               else {                  this.seriesKeys = new Comparable[0];                  this.categoryKeys = new Comparable[0];               }           }
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,              || FunctionTypeBuilder.isFunctionTypeDeclaration(info));        }       if (inferred && rhsValue != null && rhsValue.isFunction()) {         if (info != null) {           inferred = false;         } else if (!scope.isDeclared(qName, false) &&                    n.isUnscopedQualifiedName()) {           inferred = false;         }        }        if (!inferred) {
