zend_hash_destroy(&pcre_globals->pcre_cache);  }  PHP_INI_BEGIN() STD_PHP_INI_ENTRY("pcre.backtrack_limit", "1000000", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)  STD_PHP_INI_ENTRY("pcre.recursion_limit", "100000", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)  PHP_INI_END()  static PHP_MINFO_FUNCTION(pcre)
buffer *compress_cache_dir;  array  *compress;  off_t   compress_max_filesize;  } plugin_config;  typedef struct {  PLUGIN_DATA;  free(p);  return HANDLER_GO_ON;  }  static int mkdir_recursive(char *dir) {  char *p = dir;  if (!dir ||!dir[0])  return -1;  }  *p++ = '/';  }  return (mkdir(dir, 0700)!= 0) && (errno!= EEXIST)? -1 : 0;  }  static int mkdir_for_file(char *filename) {  char *p = filename;  if (!filename ||!filename[0])  { "compress.cache-dir",             NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },  { "compress.filetype",              NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },  { "compress.max-filesize",          NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },  { NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }  };  p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));  for (i = 0; i < srv->config_context->used; i++) {  plugin_config *s;  s = calloc(1, sizeof(plugin_config));  s->compress_cache_dir = buffer_init();  s->compress = array_init();  s->compress_max_filesize = 0;  cv[0].destination = s->compress_cache_dir;  cv[1].destination = s->compress;  cv[2].destination = &(s->compress_max_filesize);  p->config_storage[i] = s;  if (0!= config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {  return HANDLER_ERROR;  }  if (!buffer_is_empty(s->compress_cache_dir)) {  struct stat st;  if (0!= stat(s->compress_cache_dir->ptr, &st)) {
if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {  response_header_overwrite(srv, con, CONST_STR_LEN("Transfer-Encoding"), CONST_STR_LEN("chunked"));  allow_keep_alive = 1; } else if (con->response.content_length >= 0) {  buffer_copy_off_t(srv->tmp_buf, con->response.content_length);  response_header_overwrite(srv, con, CONST_STR_LEN("Content-Length"), srv->tmp_buf->ptr, srv->tmp_buf->used - 1);
"An error occurred creating output PDF file");  goto fail;  }  fail:  ret = EXIT_FAILURE;  success:
program_name);  } if ((z_len == 0 &&!decompress) || z_len > MAX_SUFFIX) { fprintf(stderr, "%s: incorrect suffix '%s'\n", program_name, z_suffix);  do_exit(ERROR);  }  if (do_lzw &&!decompress) work = lzw;
(void) imagewidth; (void) spp;  for (row = 0; row < imagelength; row++) {  if (TIFFReadScanline(in, buf, row, 0) < 0 &&!ignore) goto bad;  if (TIFFWriteScanline(out, buf, row, 0) < 0)  goto bad;  }  _TIFFfree(buf); return 1;  bad:  _TIFFfree(buf); return 0;  }  typedef void biasFn (void *image, void *bias, uint32 pixels);  buf = _TIFFmalloc(bufSize);  biasBuf = _TIFFmalloc(bufSize);  for (row = 0; row < imagelength; row++) { if (TIFFReadScanline(in, buf, row, 0) < 0 &&!ignore) goto bad; if (TIFFReadScanline(bias, biasBuf, row, 0) < 0 &&!ignore) goto bad;  subtractLine (buf, biasBuf, imagewidth); if (TIFFWriteScanline(out, buf, row, 0) < 0)  goto bad;  } _TIFFfree(buf); _TIFFfree(biasBuf);
RETURN_FALSE; \  } \  } static void finfo_objects_dtor(void *object, zend_object_handle handle TSRMLS_DC)  {  struct finfo_object *intern = (struct finfo_object *) object;  if (intern->ptr) {  zend_object_std_init(&intern->zo, class_type TSRMLS_CC);  object_properties_init(&intern->zo, class_type);  intern->ptr = NULL; retval.handle = zend_objects_store_put(intern, finfo_objects_dtor, NULL, NULL TSRMLS_CC);  retval.handlers = (zend_object_handlers *) &finfo_object_handlers;  return retval;  }  php_info_print_table_row(2, "version", PHP_FILEINFO_VERSION);  php_info_print_table_end();  }  PHP_FUNCTION(finfo_open)  {  long options = MAGIC_NONE;  FILEINFO_DECLARE_INIT_OBJECT(object)  char resolved_path[MAXPATHLEN];  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|lp", &options, &file, &file_len) == FAILURE) {  RETURN_FALSE;  }  if (object) {  if (php_check_open_basedir(file TSRMLS_CC)) {  RETURN_FALSE;  }  if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) {  RETURN_FALSE;  }  file = resolved_path;  if (finfo->magic == NULL) {  efree(finfo);  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid mode '%ld'.", options);  RETURN_FALSE;  }  if (magic_load(finfo->magic, file) == -1) {  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed to load magic database at '%s'.", file);  magic_close(finfo->magic);  efree(finfo);
static TIFFErrorHandler old_error_handler = 0; static int status = 0; static int showdata = 0; static int rawdata = 0; static int showwords = 0; static int readdata = 0; static int stoponerr = 1;  static void usage(void);  static void tiffinfo(TIFF*, uint16, long); static void PrivateErrorHandler(const char* module, const char* fmt, va_list ap) { if (old_error_handler) (*old_error_handler)(module,fmt,ap); status = 1; }  int  main(int argc, char* argv[])  {  }  if (optind >= argc)  usage(); old_error_handler = _TIFFerrorHandler;  multiplefiles = (argc - optind > 1);  for (; optind < argc; optind++) {  if (multiplefiles)  TIFFClose(tif);  }  } return (status);  }  char* stuff[] = {  "usage: tiffinfo [options] input...",
cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on")  }  ltostr(buf, con->request.content_length);  cgi_env_add(&env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf));  cgi_env_add(&env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(con->physical.path));  cgi_env_add(&env, CONST_STR_LEN("SCRIPT_NAME"), CONST_BUF_LEN(con->uri.path));  cgi_env_add(&env, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(con->physical.doc_root));
}  PHP_FUNCTION(dom_document_save_html)  { zval *id;  xmlDoc *docp; dom_object *intern; xmlChar *mem;  int size, format;  dom_doc_propsptr doc_props; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &id, dom_document_class_entry) == FAILURE) {  return;  }  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);  doc_props = dom_get_doc_props(intern->document);  format = doc_props->formatoutput;  htmlDocDumpMemoryFormat(docp, &mem, &size, format);  htmlDocDumpMemory(docp, &mem, &size);  if (!size) {  if (mem)  xmlFree(mem); RETURN_FALSE;  } RETVAL_STRINGL(mem, size, 1); xmlFree(mem);  }  PHP_FUNCTION(domdocument, registerNodeClass)
} else {  if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {  zend_error(E_NOTICE,"Undefined index:  %s", Z_STRVAL_P(offset));  }  }  break;
fnname_len = strlen(fn->common.function_name);  if (aliases) {  while (aliases[i]) { if (!aliases[i]->trait_method->ce || (fn->common.scope == aliases[i]->trait_method->ce &&  (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,  aliases[i]->trait_method->mname_len, fn->common.function_name, fnname_len) == 0))) {  if (aliases[i]->alias) {  fn_copy = *fn;  zend_traits_duplicate_function(&fn_copy, estrndup(aliases[i]->alias, aliases[i]->alias_len) TSRMLS_CC);  if (aliases) {  i = 0;  while (aliases[i]) { if ((!aliases[i]->trait_method->ce || fn->common.scope == aliases[i]->trait_method->ce) &&  (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,  aliases[i]->trait_method->mname_len,  fn->common.function_name, fnname_len) == 0)) {
{  zend_object *object;  if (class_type->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) { char *what = class_type->ce_flags & ZEND_ACC_INTERFACE? "interface" : "abstract class";  zend_error(E_ERROR, "Cannot instantiate %s %s", what, class_type->name);  }  zend_update_class_constants(class_type TSRMLS_CC);
magic[1] = (char) imagic1;  } else {  magic[0] = (char)get_byte();  magic[1] = (char)get_byte();  imagic1 = 0;  }  method = -1;  part_nb++;
for (i = 0; i < 8; i++) {  ts = (ts << 4) + hex2int(*(ts_str + i));  } if (srv->cur_ts - ts > p->conf.timeout || srv->cur_ts - ts < -p->conf.timeout) {  if (con->conf.log_request_handling) {  TRACE("timestamp is too old: %ld, timeout: %d", ts, p->conf.timeout);  } con->http_status = 408;  return HANDLER_FINISHED;  }  rel_uri = ts_str + 8;
