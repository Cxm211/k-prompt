zend_hash_destroy(&pcre_globals->pcre_cache);  }  PHP_INI_BEGIN() STD_PHP_INI_ENTRY("pcre.backtrack_limit", "1000000", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)  STD_PHP_INI_ENTRY("pcre.recursion_limit", "100000", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)  PHP_INI
buffer *compress_cache_dir;  array  *compress;  off_t   compress_max_filesize;  } plugin_config;  typedef struct {  PLUGIN_DATA  free(p);  return HANDLER_GO_ON;  }  static int mkdir_recursive(char *dir) {  char *p = dir;  if (!dir || !dir[0])  return -1;  }  *p++ = '/';  }  return (mkdir(dir, 0700) != 0) && (errno != EEXIST) ? -1 :
if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {  response_header_overwrite(srv, con, CONST_STR_LEN("Transfer-Encoding"), CONST_STR_LEN("chunked"));  allow_keep_alive = 1;  } else if (con->response.content_length >= 0) {  buffer_copy_off_t(srv->tmp_buf, con->response.content_length);  response_header_overwrite(srv, con, CONST_STR_LEN("Content-Length"), srv->tmp
"An error occurred creating output PDF file");  goto fail;  }  fail:  ret = EXIT_FAILURE;  success:
program_name);  } if ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) { fprintf(stderr, "%s: incorrect suffix '%s'\n", program_name, z_suffix);  do_exit(ERROR);  }  if (do_lzw && !decompress) work = lzw;
(void) imagewidth; (void) spp;  for (row = 0; row < imagelength; row++) {  if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) goto bad;  if (TIFFWriteScanline(out, buf, row, 0) < 0)  goto bad;  }  _TIFFfree(buf); return 1;  bad:  _TIFFfree(buf); return 0;  }  typedef void biasFn (void *image, void *bias, uint32 pixels);
RETURN_FALSE; \  } \  } static void finfo_objects_dtor(void *object, zend_object_handle handle TSRMLS_DC)  {  struct finfo_object *intern = (struct finfo_object *) object;  if (intern->ptr) {  zend_object_std_init(&intern->zo, class_type TSRMLS_CC);  object_properties_init(&intern->zo, class_type);  intern->ptr = NULL; retval.handle = zend_objects_store_
static TIFFErrorHandler old_error_handler = 0; static int status = 0; static int showdata = 0; static int rawdata = 0; static int showwords = 0; static int readdata = 0; static int stoponerr = 1;  static void usage(void);  static void tiffinfo(TIFF*, uint16, long); static void PrivateErrorHandler(const char* module, const char* fmt, va_list ap) { if (old_error_handler) (*old_error_handler)(module,fmt,ap); status = 1; }
cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));  }  ltostr(buf, con->request.content_length);  cgi_env_add(&env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf));  cgi_env_add(&env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(con->physical.path));  cgi_env_add(&env, CONST_STR_LEN("SCRIPT_
}  PHP_FUNCTION(dom_document_save_html)  { zval *id;  xmlDoc *docp; dom_object *intern; xmlChar *mem;  int size, format;  dom_doc_propsptr doc_props; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O", &id, dom_document_class_entry) == FAILURE) {  return;  }  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);
} else {  if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {  zend_error(E_NOTICE,"Undefined index:  %s", Z_STRVAL_P(offset));  }  }  break;
fnname_len = strlen(fn->common.function_name);  if (aliases) {  while (aliases[i]) { if (!aliases[i]->trait_method->ce || (fn->common.scope == aliases[i]->trait_method->ce &&  (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,  aliases[i]->trait_method->mname_len, fn->common.function_name, fnname_len) == 0))) {  if (aliases[i]->alias) {
{  zend_object *object;  if (class_type->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) { char *what = class_type->ce_flags & ZEND_ACC_INTERFACE ? "interface" : "abstract class";  zend_error(E_ERROR, "Cannot instantiate %s %s", what, class_type->name);  }  zend_update_class_constants(class_type TSRMLS_CC);
magic[1] = (char) imagic1;  } else {  magic[0] = (char)get_byte();  magic[1] = (char)get_byte();  imagic1 = 0;  }  method = -1;  part_nb++;
for (i = 0; i < 8; i++) {  ts = (ts << 4) + hex2int(*(ts_str + i));  } if (srv->cur_ts - ts > p->conf.timeout || srv->cur_ts - ts < -p->conf.timeout) {  if (con->conf.log_request_handling) {  TRACE("timestamp is too old: %ld, timeout: %d", ts, p->conf.timeout);  } con->http_status = 408;  return HANDLER_FINISHED;  }
