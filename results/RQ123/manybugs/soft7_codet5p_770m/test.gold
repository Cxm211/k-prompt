zend_hash_destroy(&pcre_globals->pcre_cache);  }  PHP_INI_BEGIN() STD_PHP_INI_ENTRY("pcre.backtrack_limit", "100000", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)  STD_PHP_INI_ENTRY("pcre.recursion_limit", "100000", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)  PHP_INI_END()  static PHP_MINFO_FUNCTION(pcre)
buffer *compress_cache_dir;  array  *compress;  off_t   compress_max_filesize; int     allowed_encodings;  } plugin_config;  typedef struct {  PLUGIN_DATA;  free(p);  return HANDLER_GO_ON;  }  static int mkdir_recursive(char *dir) {  char *p = dir;  if (!dir || !dir[0])  return -1;  }  *p++ = '/'; if (!*p) return 0;  }  return (mkdir(dir, 0700) != 0) && (errno != EEXIST) ? -1 : 0;  }  static int mkdir_for_file(char *filename) {  char *p = filename;  if (!filename || !filename[0])  { "compress.cache-dir",             NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },  { "compress.filetype",              NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },  { "compress.max-filesize",          NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION }, { "compress.allowed-encodings",     NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },  { NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }  };  p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));  for (i = 0; i < srv->config_context->used; i++) {  plugin_config *s; array  *encodings_arr = array_init();  s = calloc(1, sizeof(plugin_config));  s->compress_cache_dir = buffer_init();  s->compress = array_init();  s->compress_max_filesize = 0; s->allowed_encodings = 0;  cv[0].destination = s->compress_cache_dir;  cv[1].destination = s->compress;  cv[2].destination = &(s->compress_max_filesize); cv[3].destination = encodings_arr;  p->config_storage[i] = s;  if (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {  return HANDLER_ERROR;  } if (encodings_arr->used) { size_t j = 0; for (j = 0; j < encodings_arr->used; j++) { data_string *ds = (data_string *)encodings_arr->data[j]; if (NULL != strstr(ds->value->ptr, "gzip")) s->allowed_encodings |= HTTP_ACCEPT_ENCODING_GZIP; if (NULL != strstr(ds->value->ptr, "deflate")) s->allowed_encodings |= HTTP_ACCEPT_ENCODING_DEFLATE; if (NULL != strstr(ds->value->ptr, "bzip2")) s->allowed_encodings |= HTTP_ACCEPT_ENCODING_BZIP2; } } else { s->allowed_encodings = 0 | HTTP_ACCEPT_ENCODING_GZIP | HTTP_ACCEPT_ENCODING_DEFLATE | HTTP_ACCEPT_ENCODING_BZIP2 ; } array_free(encodings_arr);  if (!buffer_is_empty(s->compress_cache_dir)) {  struct stat st;  if (0 != stat(s->compress_cache_dir->ptr, &st)) {  PATCH_OPTION(compress_cache_dir);  PATCH_OPTION(compress);  PATCH_OPTION(compress_max_filesize); PATCH_OPTION(allowed_encodings);  for (i = 1; i < srv->config_context->used; i++) {  data_config *dc = (data_config *)srv->config_context->data[i];  s = p->config_storage[i];  PATCH_OPTION(compress);  } else if (buffer_is_equal_string(du->key, CONST_STR_LEN("compress.max-filesize"))) {  PATCH_OPTION(compress_max_filesize); } else if (buffer_is_equal_string(du->key, CONST_STR_LEN("compress.allowed-encodings"))) { PATCH_OPTION(allowed_encodings);  }  }  }  data_string *ds;  int accept_encoding = 0;  char *value;  int matched_encodings = 0;  const char *dflt_gzip = "gzip";  const char *dflt_deflate = "deflate";  return HANDLER_GO_ON;  }  value = ds->value->ptr;  if (NULL != strstr(value, "gzip")) accept_encoding |= HTTP_ACCEPT_ENCODING_GZIP;  if (NULL != strstr(value, "deflate")) accept_encoding |= HTTP_ACCEPT_ENCODING_DEFLATE;  if (NULL != strstr(value, "compress")) accept_encoding |= HTTP_ACCEPT_ENCODING_COMPRESS; if (NULL != strstr(value, "bzip2")) accept_encoding |= HTTP_ACCEPT_ENCODING_BZIP2; if (NULL != strstr(value, "identity")) accept_encoding |= HTTP_ACCEPT_ENCODING_IDENTITY; matched_encodings = accept_encoding & p->conf.allowed_encodings; if (0 == matched_encodings) {  if (con->conf.log_request_handling) TRACE("we don't support the requested encoding: %s", value);  return HANDLER_GO_ON;  }
if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {  response_header_overwrite(srv, con, CONST_STR_LEN("Transfer-Encoding"), CONST_STR_LEN("chunked"));  allow_keep_alive = 1; } else if ((con->http_status >= 100 && con->http_status < 200) || con->http_status == 204 || con->http_status == 304) { allow_keep_alive = 1;  } else if (con->response.content_length >= 0) {  buffer_copy_off_t(srv->tmp_buf, con->response.content_length);  response_header_overwrite(srv, con, CONST_STR_LEN("Content-Length"), srv->tmp_buf->ptr, srv->tmp_buf->used - 1);
"An error occurred creating output PDF file");  goto fail;  } goto success;  fail:  ret = EXIT_FAILURE;  success:
program_name);  } if (z_len == 0 || z_len > MAX_SUFFIX) { fprintf(stderr, "%s: invalid suffix '%s'\n", program_name, z_suffix);  do_exit(ERROR);  }  if (do_lzw && !decompress) work = lzw;
(void) imagewidth; (void) spp;  for (row = 0; row < imagelength; row++) {  if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) goto done;  if (TIFFWriteScanline(out, buf, row, 0) < 0)  goto bad;  } done:  _TIFFfree(buf); return (TRUE);  bad:  _TIFFfree(buf); return (FALSE);  }  typedef void biasFn (void *image, void *bias, uint32 pixels);  buf = _TIFFmalloc(bufSize);  biasBuf = _TIFFmalloc(bufSize);  for (row = 0; row < imagelength; row++) { if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) break; if (TIFFReadScanline(bias, biasBuf, row, 0) < 0 && !ignore) break;  subtractLine (buf, biasBuf, imagewidth); if (TIFFWriteScanline(out, buf, row, 0) < 0) { _TIFFfree(buf); _TIFFfree(biasBuf); return FALSE;  }  } _TIFFfree(buf); _TIFFfree(biasBuf); TIFFSetDirectory (bias, TIFFCurrentDirectory(bias)); return TRUE; }else{ fprintf (stderr, "No support for biasing %d bit pixels\n", sampleBits); return FALSE;  } }  fprintf (stderr,"Bias image %s,%d\nis not the same size as %s,%d\n",  TIFFFileName(bias), TIFFCurrentDirectory(bias),  TIFFFileName(in), TIFFCurrentDirectory(in)); return FALSE; }else{  fprintf (stderr, "Can't bias %s,%d as it has >1 Sample/Pixel\n",  TIFFFileName(in), TIFFCurrentDirectory(in)); return FALSE;  }  }  DECLAREcpFunc(cpDecodedStrips)  tsize_t cc = (row + rowsperstrip > imagelength) ?  TIFFVStripSize(in, imagelength - row) : stripsize;  if (TIFFReadEncodedStrip(in, s, buf, cc) < 0 && !ignore) break; if (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) { _TIFFfree(buf); return (FALSE); }  row += rowsperstrip;  }  _TIFFfree(buf); return (TRUE);  } return (FALSE);  }  DECLAREcpFunc(cpSeparate2SeparateByRow)  {  for (s = 0; s < spp; s++) {  for (row = 0; row < imagelength; row++) {  if (TIFFReadScanline(in, buf, row, s) < 0 && !ignore) goto done;  if (TIFFWriteScanline(out, buf, row, s) < 0)  goto bad;  }  } done:  _TIFFfree(buf); return (TRUE);  bad:  _TIFFfree(buf); return (FALSE);  }  DECLAREcpFunc(cpContig2SeparateByRow)  {  for (s = 0; s < spp; s++) {  for (row = 0; row < imagelength; row++) {  if (TIFFReadScanline(in, inbuf, row, 0) < 0 && !ignore) goto done;  inp = ((uint8*)inbuf) + s;  outp = (uint8*)outbuf;  for (n = imagewidth; n-- > 0;) {  goto bad;  }  } done:  if (inbuf) _TIFFfree(inbuf);  if (outbuf) _TIFFfree(outbuf); return (TRUE);  bad:  if (inbuf) _TIFFfree(inbuf);  if (outbuf) _TIFFfree(outbuf); return (FALSE);  }  DECLAREcpFunc(cpSeparate2ContigByRow)  {  for (row = 0; row < imagelength; row++) {  for (s = 0; s < spp; s++) {  if (TIFFReadScanline(in, inbuf, row, s) < 0 && !ignore) goto done;  inp = (uint8*)inbuf;  outp = ((uint8*)outbuf) + s;  for (n = imagewidth; n-- > 0;) {  if (TIFFWriteScanline(out, outbuf, row, 0) < 0)  goto bad;  } done:  if (inbuf) _TIFFfree(inbuf);  if (outbuf) _TIFFfree(outbuf);  return (TRUE);
RETURN_FALSE; \  } \  } static void finfo_objects_free(void *object TSRMLS_DC)  {  struct finfo_object *intern = (struct finfo_object *) object;  if (intern->ptr) {  zend_object_std_init(&intern->zo, class_type TSRMLS_CC);  object_properties_init(&intern->zo, class_type);  intern->ptr = NULL; retval.handle = zend_objects_store_put(intern, NULL, finfo_objects_free, NULL TSRMLS_CC);  retval.handlers = (zend_object_handlers *) &finfo_object_handlers;  return retval;  }  php_info_print_table_row(2, "version", PHP_FILEINFO_VERSION);  php_info_print_table_end();  } do {              \ if (object) {           \ zend_object_store_ctor_failed(object TSRMLS_CC); \ zval_dtor(object);         \ ZVAL_NULL(object);         \ }              \ } while (0)  PHP_FUNCTION(finfo_open)  {  long options = MAGIC_NONE;  FILEINFO_DECLARE_INIT_OBJECT(object)  char resolved_path[MAXPATHLEN];  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|lp", &options, &file, &file_len) == FAILURE) { FILEINFO_DESTROY_OBJECT(object);  RETURN_FALSE;  }  if (object) {  if (php_check_open_basedir(file TSRMLS_CC)) { FILEINFO_DESTROY_OBJECT(object);  RETURN_FALSE;  }  if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) { FILEINFO_DESTROY_OBJECT(object);  RETURN_FALSE;  }  file = resolved_path;  if (finfo->magic == NULL) {  efree(finfo);  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid mode '%ld'.", options); FILEINFO_DESTROY_OBJECT(object);  RETURN_FALSE;  }  if (magic_load(finfo->magic, file) == -1) {  php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed to load magic database at '%s'.", file);  magic_close(finfo->magic);  efree(finfo); FILEINFO_DESTROY_OBJECT(object);  RETURN_FALSE;  }  if (object) {
int showdata = 0; int rawdata = 0; int showwords = 0; int readdata = 0; int stoponerr = 1;  static void usage(void);  static void tiffinfo(TIFF*, uint16, long);  int  main(int argc, char* argv[])  {  }  if (optind >= argc)  usage();  multiplefiles = (argc - optind > 1);  for (; optind < argc; optind++) {  if (multiplefiles)  TIFFClose(tif);  }  } return (0);  }  char* stuff[] = {  "usage: tiffinfo [options] input...",
cgi_env_add(&env, CONST_STR_LEN("HTTPS"), CONST_STR_LEN("on"));  } if (con->request.content_length > 0) {  ltostr(buf, con->request.content_length);  cgi_env_add(&env, CONST_STR_LEN("CONTENT_LENGTH"), buf, strlen(buf)); }  cgi_env_add(&env, CONST_STR_LEN("SCRIPT_FILENAME"), CONST_BUF_LEN(con->physical.path));  cgi_env_add(&env, CONST_STR_LEN("SCRIPT_NAME"), CONST_BUF_LEN(con->uri.path));  cgi_env_add(&env, CONST_STR_LEN("DOCUMENT_ROOT"), CONST_BUF_LEN(con->physical.doc_root));
}  PHP_FUNCTION(dom_document_save_html)  { zval *id, *nodep = NULL;  xmlDoc *docp; xmlNode *node; xmlBufferPtr buf; dom_object *intern, *nodeobj; xmlChar *mem = NULL;  int size, format;  dom_doc_propsptr doc_props; if (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), "O|O!", &id, dom_document_class_entry, &nodep, dom_node_class_entry) == FAILURE) {  return;  }  DOM_GET_OBJ(docp, id, xmlDocPtr, intern);  doc_props = dom_get_doc_props(intern->document);  format = doc_props->formatoutput; if (nodep != NULL) { DOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj); if (node->doc != docp) { php_dom_throw_error(WRONG_DOCUMENT_ERR, dom_get_strict_error(intern->document) TSRMLS_CC); RETURN_FALSE; } buf = xmlBufferCreate(); if (!buf) { php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not fetch buffer"); RETURN_FALSE; } xmlNodeDump(buf, docp, node, 0, format); mem = (xmlChar*) xmlBufferContent(buf); if (!mem) { RETVAL_FALSE; } else { RETVAL_STRING(mem, 1); } xmlBufferFree(buf); } else {  htmlDocDumpMemoryFormat(docp, &mem, &size, format);  htmlDocDumpMemory(docp, &mem, &size);  if (!size) { RETVAL_FALSE; } else { RETVAL_STRINGL(mem, size, 1); }  if (mem)  xmlFree(mem);  }  }  PHP_METHOD(domdocument, registerNodeClass)
} else {  if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {  zend_error(E_NOTICE,"Undefined index:  %s", Z_STRVAL_P(offset)); } else { spl_array_object *obj = intern; while (1) { if ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) { break; } else if (Z_TYPE_P(obj->array) == IS_OBJECT) { if ((obj->ar_flags & SPL_ARRAY_USE_OTHER) == 0) { obj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC); break; } else { obj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC); } } else { obj = NULL; break; } } if (obj) { zend_property_info *property_info = zend_get_property_info(obj->std.ce, offset, 1 TSRMLS_CC); if (property_info && (property_info->flags & ZEND_ACC_STATIC) == 0 && property_info->offset >= 0) { obj->std.properties_table[property_info->offset] = NULL; } }  }  }  break;
fnname_len = strlen(fn->common.function_name);  if (aliases) {  while (aliases[i]) { if ( (!aliases[i]->trait_method->ce || fn->common.scope == aliases[i]->trait_method->ce) &&  (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,  aliases[i]->trait_method->mname_len, fn->common.function_name, fnname_len) == 0)) {  if (aliases[i]->alias) {  fn_copy = *fn;  zend_traits_duplicate_function(&fn_copy, estrndup(aliases[i]->alias, aliases[i]->alias_len) TSRMLS_CC);  if (aliases) {  i = 0;  while (aliases[i]) { if ( (!aliases[i]->trait_method->ce || fn->common.scope == aliases[i]->trait_method->ce) &&  (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,  aliases[i]->trait_method->mname_len,  fn->common.function_name, fnname_len) == 0)) {
{  zend_object *object;  if (class_type->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) { char *what =   (class_type->ce_flags & ZEND_ACC_INTERFACE)                ? "interface" :((class_type->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) ? "trait" :                                                              "abstract class";  zend_error(E_ERROR, "Cannot instantiate %s %s", what, class_type->name);  }  zend_update_class_constants(class_type TSRMLS_CC);
magic[1] = (char) imagic1;  } else {  magic[0] = (char)get_byte(); if (magic[0]) {  magic[1] = (char)get_byte();  imagic1 = 0; } else { imagic1 = try_byte (); magic[1] = (char) imagic1; }  }  method = -1;  part_nb++;
for (i = 0; i < 8; i++) {  ts = (ts << 4) + hex2int(*(ts_str + i));  } if ( (srv->cur_ts > ts && srv->cur_ts - ts > p->conf.timeout) || (srv->cur_ts < ts && ts - srv->cur_ts > p->conf.timeout) ) {  if (con->conf.log_request_handling) {  TRACE("timestamp is too old: %ld, timeout: %d", ts, p->conf.timeout);  } con->http_status = 410;  return HANDLER_FINISHED;  }  rel_uri = ts_str + 8;
