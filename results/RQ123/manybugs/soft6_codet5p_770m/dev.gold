void zend_do_implements_trait(znode *trait_name TSRMLS_DC)  {  zend_op *opline; if ((CG(active_class_entry)->ce_flags & ZEND_ACC_INTERFACE)) { zend_error(E_COMPILE_ERROR, "Cannot use traits inside of interfaces. %s is used in %s", Z_STRVAL(trait_name->u.constant), CG(active_class_entry)->name); }  switch (zend_get_class_fetch_type(Z_STRVAL(trait_name->u.constant), Z_STRLEN(trait_name->u.constant))) {  case ZEND_FETCH_CLASS_SELF:  case ZEND_FETCH_CLASS_PARENT:
ZEND_BEGIN_ARG_INFO_EX(arginfo_token_get_all, 0, 0, 1)  ZEND_ARG_INFO(0, source)  ZEND_END_ARG_INFO()  int token_type;  zend_bool destroy;  int token_line = 1;  array_init(return_value);  ZVAL_NULL(&token);  while ((token_type = lex_scan(&token TSRMLS_CC))) {  zval_dtor(&token);  }  ZVAL_NULL(&token); if (need_tokens != -1) { if (token_type != T_WHITESPACE && token_type != T_OPEN_TAG && token_type != T_COMMENT && token_type != T_DOC_COMMENT && --need_tokens == 0 ) { if (zendcursor != zendlimit) { MAKE_STD_ZVAL(keyword); array_init(keyword); add_next_index_long(keyword, T_INLINE_HTML); add_next_index_stringl(keyword, (char *)zendcursor, zendlimit - zendcursor, 1); add_next_index_long(keyword, token_line); add_next_index_zval(return_value, keyword); }  break;  } } else if (token_type == T_HALT_COMPILER) { need_tokens = 3; } token_line = CG(zend_lineno);  }  }  PHP_FUNCTION(token_get_all)
server_socket *srv_sock = con->srv_socket;  if (dc->parent && dc->parent->context_ndx) {  if (con->conf.log_condition_handling) { TRACE("checking if the parent (%s) evaluates to 'true'", BUF_STR(dc->parent->key));  } switch (config_check_cond_cached(srv, con, dc->parent)) { case COND_RESULT_FALSE:  return COND_RESULT_FALSE; case COND_RESULT_UNSET: return COND_RESULT_UNSET; default: break;  }  }  if (dc->prev) {  if (con->conf.log_condition_handling) { TRACE("triggering eval of successors of (%s) [in else]", BUF_STR(dc->key));  }  config_check_cond_cached(srv, con, dc->prev); if (con->conf.log_condition_handling) { TRACE("(%s) [in else] -> %s", BUF_STR(dc->key), con->cond_cache[dc->context_ndx].result == COND_RESULT_FALSE ? "false" : "we will see");  } switch (con->cond_cache[dc->context_ndx].result) { case COND_RESULT_FALSE: return con->cond_cache[dc->context_ndx].result; default: break;  } }  if (!con->conditional_is_valid[dc->comp]) {  if (con->conf.log_condition_handling) { TRACE("is condition [%d] (%s) already valid ? %s", dc->comp, BUF_STR(dc->key), con->conditional_is_valid[dc->comp] ? "yeah" : "nej");  }  return COND_RESULT_UNSET;  }  if (con->conf.log_condition_handling) {  TRACE("[%d] result: %s",  dc->context_ndx, caches[dc->context_ndx].result == COND_RESULT_UNSET ? "unknown" : (caches[dc->context_ndx].result == COND_RESULT_TRUE ? "true" : "false") );  }  } else {  if (con->conf.log_condition_cache_handling) {  TRACE("[%d] (cached) result: %s",  dc->context_ndx, caches[dc->context_ndx].result == COND_RESULT_UNSET ? "unknown" : (caches[dc->context_ndx].result == COND_RESULT_TRUE ? "true" : "false") );  }  }  return caches[dc->context_ndx].result;
PHPAPI zend_class_entry *spl_ce_RecursiveIterator;  PHPAPI zend_class_entry *spl_ce_RecursiveIteratorIterator;  PHPAPI zend_class_entry *spl_ce_FilterIterator; PHPAPI zend_class_entry *spl_ce_CallbackFilterIterator;  PHPAPI zend_class_entry *spl_ce_RecursiveFilterIterator; PHPAPI zend_class_entry *spl_ce_RecursiveCallbackFilterIterator;  PHPAPI zend_class_entry *spl_ce_ParentIterator;  PHPAPI zend_class_entry *spl_ce_SeekableIterator;  PHPAPI zend_class_entry *spl_ce_LimitIterator;  break;  } case DIT_CallbackFilterIterator: case DIT_RecursiveCallbackFilterIterator: { _spl_cbfilter_it_intern *cfi = emalloc(sizeof(*cfi)); if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Of", &zobject, ce_inner, &cfi->fci, &cfi->fcc) == FAILURE) { zend_restore_error_handling(&error_handling TSRMLS_CC); efree(cfi); return NULL; } if (cfi->fci.function_name) { Z_ADDREF_P(cfi->fci.function_name); } if (cfi->fci.object_ptr) { Z_ADDREF_P(cfi->fci.object_ptr); } intern->u.cbfilter = cfi; break; }  default:  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "O", &zobject, ce_inner) == FAILURE) {  zend_restore_error_handling(&error_handling TSRMLS_CC);  {  spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_FilterIterator, zend_ce_iterator, DIT_FilterIterator);  } SPL_METHOD(CallbackFilterIterator, __construct) { spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_CallbackFilterIterator, zend_ce_iterator, DIT_CallbackFilterIterator); }  SPL_METHOD(dual_it, getInnerIterator)  {  spl_dual_it_object   *intern;  intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);  spl_filter_it_next(getThis(), intern TSRMLS_CC);  } SPL_METHOD(RecursiveCallbackFilterIterator, __construct) { spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RecursiveCallbackFilterIterator, spl_ce_RecursiveIterator, DIT_RecursiveCallbackFilterIterator); }  SPL_METHOD(RecursiveFilterIterator, __construct)  {  spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RecursiveFilterIterator, spl_ce_RecursiveIterator, DIT_RecursiveFilterIterator);  zval_ptr_dtor(&retval);  }  } SPL_METHOD(RecursiveCallbackFilterIterator, getChildren) { spl_dual_it_object   *intern; zval                 *retval; if (zend_parse_parameters_none() == FAILURE) { return; } intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC); zend_call_method_with_0_params(&intern->inner.zobject, intern->inner.ce, NULL, "getchildren", &retval); if (!EG(exception) && retval) { spl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, retval, intern->u.cbfilter->fci.function_name TSRMLS_CC); } if (retval) { zval_ptr_dtor(&retval); } }  SPL_METHOD(ParentIterator, __construct)  {  spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_ParentIterator, spl_ce_RecursiveIterator, DIT_ParentIterator);  {  spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RegexIterator, zend_ce_iterator, DIT_RegexIterator);  } SPL_METHOD(CallbackFilterIterator, accept) { spl_dual_it_object     *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC); zend_fcall_info        *fci = &intern->u.cbfilter->fci; zend_fcall_info_cache  *fcc = &intern->u.cbfilter->fcc; zval                  **params[3]; zval                    zkey; zval                   *zkey_p = &zkey; zval                   *result; if (zend_parse_parameters_none() == FAILURE) { return; } if (intern->current.data == NULL) { RETURN_FALSE; } INIT_PZVAL(&zkey); if (intern->current.key_type == HASH_KEY_IS_LONG) { ZVAL_LONG(&zkey, intern->current.int_key); } else { ZVAL_STRINGL(&zkey, intern->current.str_key, intern->current.str_key_len-1, 0); } params[0] = &intern->current.data; params[1] = &zkey_p; params[2] = &intern->inner.zobject; fci->retval_ptr_ptr = &result; fci->param_count = 3; fci->params = params; fci->no_separation = 0; if (zend_call_function(fci, fcc TSRMLS_CC) != SUCCESS || !result) { RETURN_FALSE; } if (EG(exception)) { return; } RETURN_ZVAL(result, 1, 1); }  SPL_METHOD(RegexIterator, accept)  {  spl_dual_it_object *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);  }  } if (object->dit_type == DIT_CallbackFilterIterator || object->dit_type == DIT_RecursiveCallbackFilterIterator) { if (object->u.cbfilter) { if (object->u.cbfilter->fci.function_name) { zval_ptr_dtor(&object->u.cbfilter->fci.function_name); } if (object->u.cbfilter->fci.object_ptr) { zval_ptr_dtor(&object->u.cbfilter->fci.object_ptr); } efree(object->u.cbfilter); } }  zend_object_std_dtor(&object->std TSRMLS_CC);  efree(object);  }  SPL_ABSTRACT_ME(FilterIterator, accept,   arginfo_recursive_it_void)  {NULL, NULL, NULL}  }; ZEND_BEGIN_ARG_INFO(arginfo_callback_filter_it___construct, 0) ZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0) ZEND_ARG_INFO(0, callback) ZEND_END_ARG_INFO(); static const zend_function_entry spl_funcs_CallbackFilterIterator[] = { SPL_ME(CallbackFilterIterator, __construct, arginfo_callback_filter_it___construct, ZEND_ACC_PUBLIC) SPL_ME(CallbackFilterIterator, accept,      arginfo_recursive_it_void, ZEND_ACC_PUBLIC) {NULL, NULL, NULL} }; ZEND_BEGIN_ARG_INFO(arginfo_recursive_callback_filter_it___construct, 0) ZEND_ARG_OBJ_INFO(0, iterator, RecursiveIterator, 0) ZEND_ARG_INFO(0, callback) ZEND_END_ARG_INFO(); static const zend_function_entry spl_funcs_RecursiveCallbackFilterIterator[] = { SPL_ME(RecursiveCallbackFilterIterator, __construct, arginfo_recursive_callback_filter_it___construct, ZEND_ACC_PUBLIC) SPL_ME(RecursiveFilterIterator,  hasChildren,      arginfo_recursive_it_void, ZEND_ACC_PUBLIC) SPL_ME(RecursiveCallbackFilterIterator,  getChildren,      arginfo_recursive_it_void, ZEND_ACC_PUBLIC) {NULL, NULL, NULL} };  ZEND_BEGIN_ARG_INFO(arginfo_parent_it___construct, 0)  ZEND_ARG_OBJ_INFO(0, iterator, RecursiveIterator, 0)  ZEND_END_ARG_INFO();  spl_ce_FilterIterator->ce_flags |= ZEND_ACC_EXPLICIT_ABSTRACT_CLASS;  REGISTER_SPL_SUB_CLASS_EX(RecursiveFilterIterator, FilterIterator, spl_dual_it_new, spl_funcs_RecursiveFilterIterator);  REGISTER_SPL_IMPLEMENTS(RecursiveFilterIterator, RecursiveIterator); REGISTER_SPL_SUB_CLASS_EX(CallbackFilterIterator, FilterIterator, spl_dual_it_new, spl_funcs_CallbackFilterIterator); REGISTER_SPL_SUB_CLASS_EX(RecursiveCallbackFilterIterator, CallbackFilterIterator, spl_dual_it_new, spl_funcs_RecursiveCallbackFilterIterator); REGISTER_SPL_IMPLEMENTS(RecursiveCallbackFilterIterator, RecursiveIterator);  REGISTER_SPL_SUB_CLASS_EX(ParentIterator, RecursiveFilterIterator, spl_dual_it_new, spl_funcs_ParentIterator);  REGISTER_SPL_INTERFACE(Countable);  REGISTER_SPL_INTERFACE(SeekableIterator);
"                              stated shared object doesn't have the stated\n"  "                              text symbol.  Patterns can contain ? and *.\n"  "    --soname-synonyms=syn1=pattern1,syn2=pattern2,... synonym soname\n" "              specify patterns for function wrapping or replacement.\n" "              To use a non-libc malloc library that is\n" "                  in the main exe:  --soname-synonyms=somalloc=NONE\n" "                  in libxyzzy.so:   --soname-synonyms=somalloc=libxyzzy.so\n"  "\n";  Char* usage2 =  "\n"
{  zend_uint child_flags;  zend_uint parent_flags = parent->common.fn_flags; if ((parent->common.scope->ce_flags & ZEND_ACC_INTERFACE) == 0 && parent->common.fn_flags & ZEND_ACC_ABSTRACT  && parent->common.scope != (child->common.prototype ? child->common.prototype->common.scope : child->common.scope)  && child->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_IMPLEMENTED_ABSTRACT)) {  zend_error(E_COMPILE_ERROR, "Can't inherit abstract function %s::%s() (previously declared abstract in %s)",
}  if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {  if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) { do_inheritance_check_on_method(fn, other_trait_fn TSRMLS_CC);  zend_function_dtor(other_trait_fn);  zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);  } else {  if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) { do_inheritance_check_on_method(other_trait_fn, fn TSRMLS_CC);  abstract_solved = 1;  } else {  collision++;
php_stream_fill_read_buffer(stream, len + toread TSRMLS_CC);  just_read = (stream->writepos - stream->readpos) - len;  len += just_read; if (just_read == 0) {  break;  }  }
static GAsyncQueue *pcap_queue;  static gint64 pcap_queue_bytes;  static gint64 pcap_queue_packets; static gint64 pcap_queue_byte_limit = 1024 * 1024; static gint64 pcap_queue_packet_limit = 1000;  static gboolean capture_child = FALSE;  static gchar *sig_pipe_name = NULL;
}  if (bsize == 0)  { ssize = SIZ (a) >= 0 ? (asize != 0) : -1;  if (ALLOC (g) < asize)  _mpz_realloc (g, asize);  gp = PTR (g);
return fd_head;  }  static gboolean free_all_reassembled_fragments(gpointer key_arg _U_, gpointer value,  gpointer user_data _U_)  { fragment_data *fd_head; for (fd_head = value; fd_head != NULL; fd_head = fd_head->next) {  if(fd_head->data && !(fd_head->flags&FD_NOT_MALLOCED)) {  g_free(fd_head->data);  fd_head->data = NULL;  }  }  return TRUE;  }  }  }  void  fragment_table_init(GHashTable **fragment_table)  {  g_hash_table_foreach_remove(*reassembled_table,  free_all_reassembled_fragments, NULL);  } else {  *reassembled_table = g_hash_table_new(reassembled_hash,  reassembled_equal);  }  }  void  reassembled_key *new_key;  fragment_data *fd;  if (fd_head->next == NULL) {  new_key = se_alloc(sizeof(reassembled_key));  new_key->frame = pinfo->fd->num;  new_key->id = id;  g_hash_table_insert(reassembled_table, new_key, fd_head);  } else {  for (fd = fd_head->next; fd != NULL; fd = fd->next){  new_key = se_alloc(sizeof(reassembled_key));  new_key->frame = fd->frame;  new_key->id = id;  g_hash_table_insert(reassembled_table, new_key,  }  fragment_reassembled(fd_head, pinfo, reassembled_table, id);  if (fd_head->next != NULL) {  new_key = se_alloc(sizeof(reassembled_key));  new_key->frame = pinfo->fd->num;  new_key->id = id;  g_hash_table_insert(reassembled_table, new_key, fd_head);
}  if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {  if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) { if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) { if (   !zend_do_perform_implementation_check(fn, other_trait_fn TSRMLS_CC) || !zend_do_perform_implementation_check(other_trait_fn, fn TSRMLS_CC)) { zend_get_function_declaration(fn TSRMLS_CC), zend_get_function_declaration(other_trait_fn TSRMLS_CC)); } } else {  do_inheritance_check_on_method(fn, other_trait_fn TSRMLS_CC); }  zend_function_dtor(other_trait_fn);  zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);  } else {
}  void php_filter_validate_email(PHP_INPUT_FILTER_PARAM_DECL)  { const char regexp[] = "/^(?!(?:(?:\\x22?\\x5C[\\x00-\\x7E]\\x22?)|(?:\\x22?[^\\x5C\\x22]\\x22?)){255,})(?!(?:(?:\\x22?\\x5C[\\x00-\\x7E]\\x22?)|(?:\\x22?[^\\x5C\\x22]\\x22?)){65,}@)(?:(?:[\\x21\\x23-\\x27\\x2A\\x2B\\x2D\\x2F-\\x39\\x3D\\x3F\\x5E-\\x7E]+)|(?:\\x22(?:[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x21\\x23-\\x5B\\x5D-\\x7F]|(?:\\x5C[\\x00-\\x7F]))*\\x22))(?:\\.(?:(?:[\\x21\\x23-\\x27\\x2A\\x2B\\x2D\\x2F-\\x39\\x3D\\x3F\\x5E-\\x7E]+)|(?:\\x22(?:[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x21\\x23-\\x5B\\x5D-\\x7F]|(?:\\x5C[\\x00-\\x7F]))*\\x22)))*@(?:(?:(?!.*[^.]{64,})(?:(?:(?:xn--)?[a-z0-9]+(?:-+[a-z0-9]+)*\\.){1,126}){1,}(?:(?:[a-z][a-z0-9]*)|(?:(?:xn--)[a-z0-9]+))(?:-+[a-z0-9]+)*)|(?:\\[(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){7})|(?:(?!(?:.*[a-f0-9][:\\]]){7,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?)))|(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){5}:)|(?:(?!(?:.*[a-f0-9]:){5,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3}:)?)))?(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))(?:\\.(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))){3}))\\]))$/iD";  pcre       *re = NULL;  pcre_extra *pcre_extra = NULL;  int preg_options = 0;
