def reverse_linked_list(node):     prevnode = None     nextnode = None     while node:         nextnode = node.successor         node.successor = prevnode         node = nextnode     return prevnode
def flatten(arr):     for x in arr:         if isinstance(x, list):             for y in flatten(x):                 yield y         else:             yield flatten(x)
from collections import defaultdict def shortest_path_lengths(n, length_by_edge):     length_by_path = defaultdict(lambda: float('inf'))     length_by_path.update({(i, i): 0 for i in range(n)})     length_by_path.update(length_by_edge)     for k in range(n):         for i in range(n):             for j in range(n):                 length_by_path[i, j] = min(                     length_by_path[i, j],                     length_by_path[i, k] + length_by_path[j, k]                 )     return length_by_path
def possible_change(coins, total):     if total == 0:         return 1     if total < 0:         return 0     first, *rest = coins     return possible_change(coins, total - first) + possible_change(rest, total)
