*  * @see NormalizableKey    */  public abstract void putNormalizedKey(T record, byte[] target, int offset, int numBytes);   /**    * Writes the record in such a fashion that all keys are normalizing and at the beginning of the serialized data.
}    public void glGetBufferParameteriv (int target, int pname, IntBuffer params) {    GL15.glGetBufferParameteriv(target, pname, params);    }    public int glGetError () {
}       final PassFactory renameVars =        new PassFactory("renameVars", true) {      @Override      protected CompilerPass createInternal(final AbstractCompiler compiler) {
+ options.toString() + ".");          printProviderWritten();        } catch (InvalidParameterException e) {         out.println(keyName + " has not been created. " + e.getMessage());          throw e;        } catch (IOException e) {         out.println(keyName + " has not been created. " + e.getMessage());          throw e;        } catch (NoSuchAlgorithmException e) {         out.println(keyName + " has not been created. " + e.getMessage());          throw e;        }      }
* @see <a href="http:       */      public List<Trends> getWeeklyTrends() throws TwitterException {         return Trends.createTrendsList(get(getSearchBaseURL()                  + "trends/weekly.json", false));      }
* @param servers the servers that need to restart.       */      @LogMessage(level = Level.INFO)     @Message(id = 10807, value = "Domain model has changed on re-connect. The following servers will need to be restarted for changes to take affect: %s")      void domainModelChangedOnReConnect(Set<ServerIdentity> servers);      /**
if(currentStage.isStaticComplete()) {       logger.debug("NODE {}: Retry timout: Advancing");        setCurrentStage(currentStage.getNextStage());       }       else {
split.total = 3;   split.numFront = (r1? 1 : 0) + (r2? 1 : 0) + (r3? 1 : 0);    split.numBack = split.total - split.numFront;   split.setSide(r2);    int first = 0;
}    };   final PassFactory nameUnmappedAnonymousFunctions =        new PassFactory("nameAnonymousFunctions", true) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
ConfigurableEmbeddedServletContainerFactory factory = getFactory();    final Date[] date = new Date[1];    this.container = factory    .getEmbeddedServletContainer(new ServletContextInitializer() {       @Override       public void onStartup(ServletContext servletContext)         throws ServletException {
public interface AdvancedCxfEndpointBuilder              extends                  AdvancedCxfEndpointConsumerBuilder, AdvancedCxfEndpointProducerBuilder {          default CxfEndpointBuilder basic() {
"functions are set.");       final PassFactory generateExports =        new PassFactory("generateExports", true) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
ResourceBundle.getBundle("checkstylecompilation");                  String version = compilationProperties.getString("checkstyle.compile.version");                  assertEquals(String.format("<?xml version=\"1.0\" encoding=\"UTF-8\"?>%n"                         + "<checkstyle version=\"" + version + "\">%n"                         + "<file name=\""                         + expectedPath                         + "\">%n"                          + "</file>%n"                         + "</checkstyle>%n"), systemOut.getLog());                  assertEquals("", systemErr.getLog());              }          });
final PassFactory removeUnusedPrototypeProperties =        new PassFactory("removeUnusedPrototypeProperties", false) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
bar.expectedMessageCount(0);          MockEndpoint start = getMockEndpoint("mock:start");         start.expectedMinimumMessageCount(6);          template.sendBody("activemq:queue:foo", "Hello World");
* @param manager a block metadata manager handle     */    private BlockStoreMeta(BlockMetadataManager manager, boolean shouldIncludeBlockIds) {     Preconditions.checkNotNull(manager);      for (StorageTier tier : manager.getTiers()) {        Long capacityBytes = mCapacityBytesOnTiers.get(tier.getTierAlias());        Long usedBytes = mUsedBytesOnTiers.get(tier.getTierAlias());
};       final PassFactory aliasKeywords =        new PassFactory("aliasKeywords", true) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
*       * @return the message.       */     @Message(id = 10850, value = "No handler for operation %s at address %s")      String noHandlerForOperation(String operationName, PathAddress address);      /**
* Try to infer the actual types, which may be narrower     * than the declared types.     */   final PassFactory tightenTypesBuilder =        new PassFactory("tightenTypes", true) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
final PrintWriter output = mock(PrintWriter.class);          when(request.getMethod()).thenReturn("POST");         when(request.getServletPath()).thenReturn("/");          when(request.getParameterNames()).thenReturn(Collections.enumeration(ImmutableList.of("runs")));          when(request.getParameterValues("runs")).thenReturn(new String[]{"1"});          when(response.getWriter()).thenReturn(output);
public interface BeanstalkEndpointProducerBuilder              extends                  EndpointProducerBuilder {          default AdvancedBeanstalkEndpointProducerBuilder advanced() {
String dumpTracedMessagesAsXml(String nodeId);      @ManagedAttribute(description = "Number of total debugged messages")     public long getDebugCounter();      @ManagedOperation(description = "Resets the debug counter")     public void resetDebugCounter();  }
* Alias string literals with global variables, to avoid creating lots of     * transient objects.     */   final PassFactory aliasStrings =        new PassFactory("aliasStrings", true) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
return new ErrorCommand(ERROR_CLIENT);          }          if (st.hasMoreTokens()) {             flag = Integer.valueOf(st.nextToken());          } else {              return new ErrorCommand(ERROR_CLIENT);          }
mw.visitVarInsn(ALOAD, context.var("out"));          mw.visitVarInsn(ILOAD, context.var("seperator"));          mw.visitVarInsn(ALOAD, context.fieldName());         mw.visitVarInsn(LLOAD, context.var("long"));          mw.visitMethodInsn(INVOKEVIRTUAL, getType(SerializeWriter.class), "writeFieldValue", "(CLjava/lang/String;J)V");          _seperator(mw, context);
"JSC_REFERENCE_BEFORE_DECLARE",        "Variable referenced before declaration: {0}");   static final DiagnosticType REDECLARED_VARIABLE = DiagnosticType.error(        "JSC_REDECLARED_VARIABLE",        "Redeclared variable: {0}");
public interface AdvancedLdapEndpointBuilder              extends                  EndpointProducerBuilder {          default LdapEndpointBuilder basic() {
};       final PassFactory closureCheckGetCssName =        new PassFactory("checkMissingGetCssName", true) {      @Override      protected CompilerPass createInternal(AbstractCompiler compiler) {
return additionalReplacements;    }   final PassFactory printNameReferenceGraph =      new PassFactory("printNameReferenceGraph", true) {      @Override      protected CompilerPass createInternal(final AbstractCompiler compiler) {
* @should return null if no implementation id is defined yet    */   @Authorized(PrivilegeConstants.MANAGE_IMPLEMENTATION_ID)  public ImplementationId getImplementationId();   /**    * Set the given <code>implementationId</code> as this implementation's unique id
this.rejectionPolicyFactory = new ServerTimeRejectionPolicyFactory();      this.maxPendingPersists = (maxPendingPersists > 0)? maxPendingPersists : defaultPending;     Preconditions.checkArgument(maxPendingPersists > 0, "RealtimePlumberSchool requires maxPendingPersists > 0");      Preconditions.checkNotNull(windowPeriod, "RealtimePlumberSchool requires a windowPeriod.");      Preconditions.checkNotNull(basePersistDirectory, "RealtimePlumberSchool requires a basePersistDirectory.");      Preconditions.checkNotNull(segmentGranularity, "RealtimePlumberSchool requires a segmentGranularity.");
*       * @param context The start context       */     public void start(StartContext context) throws StartException {          classifyingModuleLoader = new ClassifyingModuleLoader(delegates, Module.getCurrentLoader());          Module.setModuleLoaderSelector(new SimpleModuleLoaderSelector(classifyingModuleLoader));      }
