{"name": "BREADTH_FIRST_SEARCH.java", "problem": "public static Set<Node> nodesvisited = new HashSet<>(); public static boolean breadth_first_search(Node startnode, Node goalnode) { Deque<Node> queue = new ArrayDeque<>(); queue.addLast(startnode); nodesvisited.add(startnode); while (true) { Node node = queue.removeFirst(); if (node == goalnode) { return true; } else { for (Node successor_node : node.getSuccessors()) { if (!nodesvisited.contains(successor_node)) { queue.addFirst(successor_node); nodesvisited.add(successor_node); } } } } } }", "fixed": "public static Set<Node> nodesvisited = new HashSet<>(); public static boolean breadth_first_search(Node startnode, Node goalnode) { Deque<Node> queue = new ArrayDeque<>(); queue.addLast(startnode); nodesvisited.add(startnode); while (!queue.isEmpty()) { Node node = queue.removeFirst(); if (node == goalnode) { return true; } else { for (Node successor_node : node.getSuccessors()) { if (!nodesvisited.contains(successor_node)) { queue.addFirst(successor_node); nodesvisited.add(successor_node); } } } } return false; } }", "hint": "Breadth-First Search\nInput:\n    startnode: A digraph node", "input": [], "output": ""}
{"name": "PASCAL.java", "problem": "public static ArrayList<ArrayList<Integer>> pascal(int n) { ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>(); ArrayList<Integer> init = new ArrayList<Integer>(); init.add(1); rows.add(init); for (int r=1; r<n; r++) { ArrayList<Integer> row = new ArrayList<Integer>(); for (int c=0; c<r; c++) { int upleft, upright; if (c > 0) { upleft = rows.get(r-1).get(c-1); } else { upleft = 0; } if (c < r) { upright = rows.get(r-1).get(c); } else { upright = 0; } row.add(upleft+upright); } rows.add(row); } return rows; } }", "fixed": "public static ArrayList<ArrayList<Integer>> pascal(int n) { ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>(); ArrayList<Integer> init = new ArrayList<Integer>(); init.add(1); rows.add(init); for (int r=1; r<n; r++) { ArrayList<Integer> row = new ArrayList<Integer>(); for (int c=0; c<r+1; c++) { int upleft, upright; if (c > 0) { upleft = rows.get(r-1).get(c-1); } else { upleft = 0; } if (c < r) { upright = rows.get(r-1).get(c); } else { upright = 0; } row.add(upleft+upright); } rows.add(row); } return rows; } }", "hint": "Pascal's Triangle\npascal\nInput:", "input": [3], "output": [[1], [1, 1], [1, 2, 1]]}
{"name": "KHEAPSORT.java", "problem": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) { PriorityQueue<Integer> heap = new PriorityQueue<Integer>(); for (Integer v : arr.subList(0,k)) { heap.add(v); } ArrayList<Integer> output = new ArrayList<Integer>(); for (Integer x : arr) { heap.add(x); Integer popped = heap.poll(); output.add(popped); } while (!heap.isEmpty()) { output.add(heap.poll()); } return output; } }", "fixed": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) { PriorityQueue<Integer> heap = new PriorityQueue<Integer>(); for (Integer v : arr.subList(0,k)) { heap.add(v); } ArrayList<Integer> output = new ArrayList<Integer>(); for (Integer x : arr.subList(k, arr.size())) { heap.add(x); Integer popped = heap.poll(); output.add(popped); } while (!heap.isEmpty()) { output.add(heap.poll()); } return output; } }", "hint": "K-Heapsort\nk-heapsort\nSorts an almost-sorted array, wherein every element is no more than k units from its sorted position, in O(n log k) time.", "input": [[3, 2, 1, 5, 4], 2], "output": [1, 2, 3, 4, 5]}
{"name": "SHUNTING_YARD.java", "problem": "public static List shunting_yard(ArrayList tokens) { Map<String, Integer> precedence = new HashMap<String, Integer>(); precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\",2); ArrayList rpntokens = new ArrayList(100); ArrayDeque opstack = new ArrayDeque(); for (Object token: tokens) { if (Integer.class.isInstance(token)) { rpntokens.add((Integer) token); } else { String operator = (String) token; while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) { rpntokens.add(opstack.pop()); } } } while (!opstack.isEmpty()) { rpntokens.add(opstack.pop()); } return rpntokens; } }", "fixed": "public static List shunting_yard(ArrayList tokens) { Map<String, Integer> precedence = new HashMap<String, Integer>(); precedence.put(\"+\", 1); precedence.put(\"-\", 1); precedence.put(\"*\", 2); precedence.put(\"/\", 2); ArrayList rpntokens = new ArrayList(100); ArrayDeque opstack = new ArrayDeque(); for (Object token : tokens) { if (Integer.class.isInstance(token)) { rpntokens.add((Integer) token); } else { String operator = (String) token; while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) { rpntokens.add(opstack.pop()); } opstack.push(token); } } while (!opstack.isEmpty()) { rpntokens.add(opstack.pop()); } return rpntokens; } }", "hint": "Infix to RPN Conversion\nshunting-yard\nUses Dijkstra's shunting-yard algorithm to transform infix notation into equivalent Reverse Polish Notation.", "input": [[34, "-", 12, "/", 5]], "output": [34, 12, 5, "/", "-"]}
