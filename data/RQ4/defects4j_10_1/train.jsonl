{"project": "Math", "bugId": 100, "problem": " public double getChiSquare(EstimationProblem problem) {\n         final int rows = problem.getMeasurements().length;\n        final int cols = problem.getAllParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {", "fixed": " public double getChiSquare(EstimationProblem problem) {\n         final int rows = problem.getMeasurements().length;\n        final int cols = problem.getUnboundParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {", "observations": "Apply the same replace of methods in three different places.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 111, "problem": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType;\n         }\n         @Override", "fixed": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n         }\n         @Override", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 66, "problem": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "fixed": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Time", "bugId": 2, "problem": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {", "fixed": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Closure", "bugId": 42, "problem": " Node processExpressionStatement(ExpressionStatement statementNode) {\n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),", "fixed": " Node processExpressionStatement(ExpressionStatement statementNode) {\n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n      if (loopNode.isForEach()) {\n        errorReporter.error(\n            \"unsupported language extension: for each\",\n            sourceName,\n            loopNode.getLineno(), \"\", 0);\n        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      }\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 95, "problem": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             ret = d / (d - 2.0);\n         return ret;\n     }", "fixed": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret = 1.0;\n         double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n             ret = d / (d - 2.0);\n        }\n         return ret;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["initFix", "wrapsIf"]}
{"project": "Lang", "bugId": 39, "problem": " private static String replaceEach(String text, String[] searchList, String[] rep\n         for (int i = 0; i < searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\nincrease += 3 * greater;", "fixed": " private static String replaceEach(String text, String[] searchList, String[] rep\n         for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\nincrease += 3 * greater;", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckP"]}
{"project": "Mockito", "bugId": 6, "problem": " public static byte anyByte() {\n      * @return <code>0</code>.\r\n      */\r\n     public static char anyChar() {\r\n        return reportMatcher(Any.ANY).returnChar();\r\n     }\r\n     /**\r", "fixed": " public static byte anyByte() {\n      * @return <code>0</code>.\r\n      */\r\n     public static char anyChar() {\r\n        return reportMatcher(new InstanceOf(Character.class)).returnChar();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
