{"project": "Mockito", "bugId": 6, "problem": " public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n        return reportMatcher(new InstanceOf(Short.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 112, "problem": " private boolean inferTemplatedTypesForCall(\n     }\n    Map<TemplateType, JSType> inferred = \n        inferTemplateTypesFromParameters(fnType, n);", "fixed": " private boolean inferTemplatedTypesForCall(\n     }\n    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n        inferTemplateTypesFromParameters(fnType, n),\n        new Predicate<TemplateType>() {\n          @Override\n          public boolean apply(TemplateType key) {\n            return keys.contains(key);\n          }}\n        );", "observations": "Adds an inline interface implementation for a parameter of type Predicate on filterKeys method call.", "repairActions": ["assignExpChange", "mcAdd", "mdAdd", "mdOverride", "objInstAdd", "tyImpInterf"], "repairPatterns": ["wrapsMethod"]}
{"project": "Math", "bugId": 13, "problem": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "Contains the patch of Math-13", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 19, "problem": " protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +", "fixed": " protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n      case Token.THIS:\n        break;\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +", "observations": "", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Mockito", "bugId": 12, "problem": " public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n                 return (Class) actual;\r\n         }\r\n         return Object.class;\r", "fixed": " public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n            if (actual instanceof Class) {\r\n                 return (Class) actual;\r\n            } else if (actual instanceof ParameterizedType) {\r\n                return (Class) ((ParameterizedType) actual).getRawType();\r\n            }\r\n         }\r\n         return Object.class;\r", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
