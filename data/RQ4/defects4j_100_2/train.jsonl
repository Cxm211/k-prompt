{"project": "Math", "bugId": 45, "problem": "      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);", "fixed": "      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n        long lRow = (long) rowDimension;\n        long lCol = (long) columnDimension;\n        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Mockito", "bugId": 6, "problem": " public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 61, "problem": " static boolean functionCallHasSideEffects(\n       }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "fixed": " static boolean functionCallHasSideEffects(\n       }\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 85, "problem": " public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +", "fixed": " public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +", "observations": "Changes operator in condition.", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 66, "problem": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n     }\n     /**", "fixed": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(1000);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1e-11);\n        setRelativeAccuracy(1e-9);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 31, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n \t\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t}", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n \t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}", "observations": "Partially the same as Lang 30", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 107, "problem": " protected CompilerOptions createOptions() {\n       options.messageBundle = new EmptyMessageBundle();\n     }\n     return options;", "fixed": " protected CompilerOptions createOptions() {\n       options.messageBundle = new EmptyMessageBundle();\n      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n     }\n     return options;", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Mockito", "bugId": 23, "problem": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "fixed": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n    private synchronized void instantiateMockitoCoreIfNeeded() {\r\n        if (mockitoCore == null) {\r\n            mockitoCore = new MockitoCore();\r\n        }\r\n    }\r\n    private synchronized void instantiateDelegateIfNeeded() {\r\n        if (delegate == null) {\r\n            delegate = new ReturnsEmptyValues();\r\n        }\r\n    }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Math", "bugId": 66, "problem": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "fixed": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 7, "problem": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "fixed": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          return ctorType.getGreatestSubtype(type);\n        } else {\n          return type.isSubtype(ctorType) ? null : type;\n        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "mcRem", "retBranchAdd", "retRem"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "wrongComp"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n             if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;", "fixed": " public PointVectorValuePair doOptimize() {\n             if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 74, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale = new double[y0.length];\n           if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n             } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "observations": "A vector/object was instantiated.The way to initialize values was changed.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "mcRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Math", "bugId": 90, "problem": " public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());", "fixed": " public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Math", "bugId": 59, "problem": " public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n     }\n     /** Compute the maximum of two values", "fixed": " public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n     /** Compute the maximum of two values", "observations": "", "repairActions": ["retExpChange", "varReplVar"], "repairPatterns": ["singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 37, "problem": " public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);", "fixed": " public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n             return NaN;\n         }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Math", "bugId": 103, "problem": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n     }\n     /**", "fixed": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) {\n                return 0.0d;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1.0d;\n            } else {\n                throw ex;\n            }\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "retBranchAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "wrapsTryCatch", "wrongComp"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "fixed": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                     }\n                 }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best;\n                     }\n                 }", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Math", "bugId": 15, "problem": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }", "fixed": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 87, "problem": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                 row = i;\n                } else {\n                 return null;\n                }\n             }\n         }\n         return row;", "fixed": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                 return null;\n             }\n         }\n         return row;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 120, "problem": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n           break;\n         } else if (block.isLoop) {\n           return false;", "fixed": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n           break;\n         } else if (block.isLoop) {\n           return false;", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                return new VectorialPointValuePair(point, objective);\n             }", "fixed": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                return current;\n             }", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Closure", "bugId": 71, "problem": " private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n      boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;", "fixed": " private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n      boolean isOverride = parent.getJSDocInfo() != null &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;", "observations": "The null-check is done in a boolean expression assigned to a variable and not to a conditional test.", "repairActions": ["assignExpChange", "mcAdd", "mcRem"], "repairPatterns": ["expLogicMod", "missNullCheckN", "singleLine"]}
{"project": "Chart", "bugId": 21, "problem": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "fixed": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n        }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Closure", "bugId": 70, "problem": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "fixed": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Closure", "bugId": 60, "problem": " static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n       case Token.VOID:\n           return TernaryValue.FALSE;\n       case Token.NAME:\n         String name = n.getString();", "fixed": " static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n       case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n           return TernaryValue.FALSE;\n        }\n        break;\n       case Token.NAME:\n         String name = n.getString();", "observations": "", "repairActions": ["condBranCaseAdd", "condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIf"]}
{"project": "Chart", "bugId": 15, "problem": " public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n         PiePlotState state = new PiePlotState(info);\r\n         state.setPassesRequired(2);\r\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\r\n                     plot.getDataset()));\r\n         state.setLatestAngle(plot.getStartAngle());\r\n         return state;\r", "fixed": " public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n         PiePlotState state = new PiePlotState(info);\r\n         state.setPassesRequired(2);\r\n        if (this.dataset != null) {\r\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\r\n                     plot.getDataset()));\r\n        }\r\n         state.setLatestAngle(plot.getStartAngle());\r\n         return state;\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "missNullCheckP", "wrapsIf"]}
{"project": "Math", "bugId": 89, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n             addValue((Comparable<?>) v);            \n     }\n     /**", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n        } else {\n            throw new IllegalArgumentException(\"Object must implement Comparable\");\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Lang", "bugId": 4, "problem": "      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n        lookupMap = new HashMap<CharSequence, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0], seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;", "fixed": "      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n        lookupMap = new HashMap<String, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0].toString(), seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Math", "bugId": 70, "problem": " public double solve(double min, double max)\n     \n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n     }\n     ", "fixed": " public double solve(double min, double max)\n     \n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n     }\n     ", "observations": "Call overloaded method without one parameter.", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Closure", "bugId": 25, "problem": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n     Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "fixed": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n     Node constructor = n.getFirstChild();\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcRem"], "repairPatterns": ["blockRemove", "notClassified"]}
{"project": "Closure", "bugId": 76, "problem": " private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {", "fixed": " private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\nif (ControlFlowGraph.isEnteringNewCfgNode(n)) {\n      return VariableLiveness.MAYBE_LIVE;\n    }\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Closure", "bugId": 68, "problem": " private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n     return reportGenericTypeSyntaxWarning();\n   }", "fixed": " private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }", "observations": "An assignment was moved outside a branch.", "repairActions": ["mcAdd"], "repairPatterns": ["codeMove", "copyPaste", "missComp", "unwrapIfElse"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = computeFollowing(n);\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Lang", "bugId": 4, "problem": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "fixed": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq.toString());\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 31, "problem": " Node parseInputs() {\n       if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {", "fixed": " Node parseInputs() {\n       if (options.dependencyOptions.needsManagement() &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {", "observations": "", "repairActions": ["condExpRed"], "repairPatterns": ["expLogicReduce", "singleLine"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(residuals);\n             for (int k = 0; k < solvedCols; ++k) {", "fixed": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(qtf);\n             for (int k = 0; k < solvedCols; ++k) {", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 41, "problem": " public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n        return out;\n     }", "fixed": " public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n        return out + arrayPrefix;\n     }", "observations": "Existent condittional expression with null-check is expanded.", "repairActions": ["assignAdd", "condBranIfAdd", "condExpExpand", "loopAdd", "mcAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Closure", "bugId": 3, "problem": " public void enterScope(NodeTraversal t) {\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n      if (c.canInline()) {\n         c.inlineVariable();", "fixed": " public void enterScope(NodeTraversal t) {\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n      if (c.canInline(t.getScope())) {\n         c.inlineVariable();", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "condExpMod", "mcAdd", "mcParAdd", "mcRepl", "mdParAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {", "fixed": " private void findAliases(NodeTraversal t) {\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 58, "problem": " public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n     }\n     /**", "fixed": " public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n     }\n     /**", "observations": "Call overloaded method without one parameter.", "repairActions": ["mcParRem", "mcRepl", "objInstRem", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Lang", "bugId": 29, "problem": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static float toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "fixed": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static int toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "observations": "Changes return type of method.", "repairActions": ["mdRetTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Math", "bugId": 17, "problem": " public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n             return multiplyFast(x);\n     }\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.", "fixed": " public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n        if (x >= 0 && x < RADIX) {\n             return multiplyFast(x);\n        } else {\n            return multiply(newInstance(x));\n        }\n     }\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 94, "problem": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Time", "bugId": 3, "problem": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n     }", "fixed": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Chart", "bugId": 4, "problem": " public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r", "fixed": " public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                if (r != null) {\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Time", "bugId": 1, "problem": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +", "fixed": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                if (loopUnitField.isSupported() == false) {\n                    if (lastUnitField.isSupported()) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                        types[i - 1].getName() + \" < \" + loopType.getName());\n                    } else {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +", "observations": "", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "exThrowsAdd", "mcAdd", "objInstAdd", "retRem"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRem", "expLogicExpand"]}
{"project": "Math", "bugId": 104, "problem": "     private static final long serialVersionUID = -6587513359895466954L;\n     \n    private static final double DEFAULT_EPSILON = 10e-9;\n     \n     private static double[] lanczos =", "fixed": "     private static final long serialVersionUID = -6587513359895466954L;\n     \n    private static final double DEFAULT_EPSILON = 10e-15;\n     \n     private static double[] lanczos =", "observations": "", "repairActions": ["assignExpChange"], "repairPatterns": ["constChange", "initFix", "singleLine"]}
{"project": "Closure", "bugId": 10, "problem": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "fixed": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 37, "problem": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "fixed": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Math", "bugId": 10, "problem": " public void atan2(final double[] y, final int yOffset,\n         }\n     }", "fixed": " public void atan2(final double[] y, final int yOffset,\n         }\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n     }", "observations": "", "repairActions": ["assignAdd", "mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Closure", "bugId": 30, "problem": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n   @Override", "fixed": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n   @Override", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Lang", "bugId": 23, "problem": "  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";", "fixed": "  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n    private static final int HASH_SEED = 31;\n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";", "observations": "Implements equals and hascode to work with hash structures of Collections", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mdAdd", "mdOverride", "varAdd"], "repairPatterns": ["condBlockRetAdd", "fixAPI", "wrongComp"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n           Node childVal = child.getFirstChild();", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n          validProperties.add(child.getString());\n           Node childVal = child.getFirstChild();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 81, "problem": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "fixed": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 3) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Lang", "bugId": 52, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                     default :\n                         out.write(ch);\n                         break;", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                     default :\n                         out.write(ch);\n                         break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 13, "problem": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "Contains the patch of Math-13", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;", "fixed": " public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 103, "problem": " private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n         return true;\n       case Token.FUNCTION:\n         return false;", "fixed": " private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n      case Token.INSTANCEOF:\n         return true;\n       case Token.FUNCTION:\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN", "missNullCheckP"]}
{"project": "Math", "bugId": 14, "problem": "      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n     }\n     /**", "fixed": "      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n        weightMatrix = new DiagonalMatrix(weight);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "missComp", "wrapsIfElse"]}
{"project": "Chart", "bugId": 2, "problem": " public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "fixed": " public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                    double value = intervalXYData.getXValue(series, item);\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum = Math.min(minimum, value);\r\n                        maximum = Math.max(maximum, value);\r\n                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Closure", "bugId": 55, "problem": " public Node parseHelperCode(Reducer reducer) {\n   }\n   private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n   }\n   /**", "fixed": " public Node parseHelperCode(Reducer reducer) {\n   }\n   private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n)\n        && !NodeUtil.isGetOrSetKey(n.getParent());\n   }\n   /**", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Mockito", "bugId": 14, "problem": " public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n        mockingProgress.verificationStarted(mode);\r\n         return mock;\r\n     }\r", "fixed": " public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\r\n         return mock;\r\n     }\r", "observations": "An existing parameter (\"mode\") was wrapped by a constructor call, instantiating MockAwareVerificationMode object", "repairActions": ["condBranIfAdd", "mcAdd", "mcParValChange", "objInstAdd"], "repairPatterns": ["wrapsIf", "wrapsMethod"]}
{"project": "Closure", "bugId": 9, "problem": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Mockito", "bugId": 9, "problem": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "fixed": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n    \t}\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 22, "problem": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return true;\n     }\n     ", "fixed": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return false;\n     }\n     ", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Closure", "bugId": 14, "problem": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "fixed": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "observations": "Parameter value change.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["constChange", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 15, "problem": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n     \n     private static final double F_1_3 = 1d / 3d;", "fixed": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n     \n     private static final double F_1_3 = 1d / 3d;", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Chart", "bugId": 10, "problem": " public StandardToolTipTagFragmentGenerator() {\n      * @return The formatted HTML area tag attribute(s).\r\n      */\r\n     public String generateToolTipFragment(String toolTipText) {\r\n        return \" title=\\\"\" + toolTipText\r\n             + \"\\\" alt=\\\"\\\"\";\r\n     }\r", "fixed": " public StandardToolTipTagFragmentGenerator() {\n      * @return The formatted HTML area tag attribute(s).\r\n      */\r\n     public String generateToolTipFragment(String toolTipText) {\r\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \r\n             + \"\\\" alt=\\\"\\\"\";\r\n     }\r", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsMethod"]}
{"project": "Closure", "bugId": 32, "problem": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n             return new ExtractionInfo(multilineText, token);\n           }\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n           builder.append(toString(token));\n           line = stream.getRemainingJSDocLine();", "fixed": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n             return new ExtractionInfo(multilineText, token);\n           }\n           builder.append(toString(token));\n           line = stream.getRemainingJSDocLine();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Chart", "bugId": 19, "problem": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "fixed": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 116, "problem": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\n     Node cArg = callNode.getFirstChild().getNext();", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\nboolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(\n            stmt.getFirstChild(), compiler);\n      }\n    }\n     Node cArg = callNode.getFirstChild().getNext();", "observations": "Strange... what is removed in 115 is added again in 116.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Mockito", "bugId": 5, "problem": " public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }", "fixed": " public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n            catch (AssertionError e) {\n                 error = handleVerifyException(e);\n             }\n         }", "observations": "Change parameter type in catch command.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Closure", "bugId": 127, "problem": " private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);", "fixed": " private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n    private boolean inFinally(Node parent, Node child) {\n      if (parent == null || parent.isFunction()) {\n        return false;\n      } else if (NodeUtil.isTryFinallyNode(parent, child)) {\n        return true;\n      } else {\n        return inFinally(parent.getParent(), parent);\n      }\n    }\n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);", "observations": "", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcAdd", "mdAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand", "missComp", "missNullCheckP"]}
{"project": "Closure", "bugId": 51, "problem": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "fixed": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x && !isNegativeZero(x)) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n     return next;\n   }", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n    while (next != null && next.getType() == Token.BLOCK) {\n      if (next.hasChildren()) {\n        next = next.getFirstChild();\n      } else {\n        next = computeFollowing(next);\n      }\n    }\n     return next;\n   }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Closure", "bugId": 79, "problem": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n   }\n   /**", "fixed": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n    compiler.reportCodeChange();\n   }\n   /**", "observations": "Calls overloaded method with extra parameters.", "repairActions": ["mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node block(Node ... stmts) {\n     return block;\n   }\n   public static Node script(Node ... stmts) {", "fixed": " public static Node block(Node ... stmts) {\n     return block;\n   }\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n   public static Node script(Node ... stmts) {", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 101, "problem": " protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n    if (flags.process_closure_primitives) {\n      options.closurePass = true;\n    }\n     initOptionsFromFlags(options);\n     return options;\n   }", "fixed": " protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n    options.closurePass = flags.process_closure_primitives;\n     initOptionsFromFlags(options);\n     return options;\n   }", "observations": "", "repairActions": ["assignExpChange", "condBranRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "fixed": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Math", "bugId": 83, "problem": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "fixed": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Lang", "bugId": 10, "problem": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "fixed": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "observations": "", "repairActions": ["assignRem", "condBranIfAdd", "mcRem", "varRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Closure", "bugId": 124, "problem": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n       node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "fixed": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n    while (node.isGetProp()) {\n       node = node.getFirstChild();\n    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "observations": "", "repairActions": ["loopAdd", "mcAdd"], "repairPatterns": ["missComp", "wrapsLoop"]}
{"project": "Chart", "bugId": 22, "problem": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n        if (row >= 0) {\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n         }\r\n         else {\r\n             return null;\r", "fixed": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n        int index = rowData.getIndex(columnKey);\r\n        if (index >= 0) {\r\n            return rowData.getObject(index);\r\n         }\r\n         else {\r\n             return null;\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Lang", "bugId": 44, "problem": " public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n         if (val.startsWith(\"--\")) {", "fixed": " public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n         if (val.startsWith(\"--\")) {", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Math", "bugId": 12, "problem": "  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n    implements RandomGenerator {\n     \n     \n     private double nextGaussian;", "fixed": "  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n    implements RandomGenerator,\n               Serializable {\n     \n    private static final long serialVersionUID = 20130104L;\n     \n     private double nextGaussian;", "observations": "imports and implements java.io.Serializable.", "repairActions": ["assignAdd", "tyImpInterf", "varAdd"], "repairPatterns": ["notClassified"]}
{"project": "Math", "bugId": 14, "problem": " private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 30, "problem": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final int n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "fixed": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final double n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Closure", "bugId": 105, "problem": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n    if (sb.length() > 0) {\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));", "fixed": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n    if (sb != null) {\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));", "observations": "Moves the instantiation of StringBuilder to another place.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "condExpMod", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "expLogicMod", "initFix"]}
{"project": "Math", "bugId": 95, "problem": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             ret = d / (d - 2.0);\n         return ret;\n     }", "fixed": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret = 1.0;\n         double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n             ret = d / (d - 2.0);\n        }\n         return ret;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["initFix", "wrapsIf"]}
{"project": "Mockito", "bugId": 7, "problem": " private void readTypeVariables() {\n             for (Type type : typeVariable.getBounds()) {\r\n                 registerTypeVariablesOn(type);\r\n             }\r\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n         }\r", "fixed": " private void readTypeVariables() {\n             for (Type type : typeVariable.getBounds()) {\r\n                 registerTypeVariablesOn(type);\r\n             }\r\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\r\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n         }\r", "observations": "Instantiates and initializes an TypeVariable vector.", "repairActions": ["mcAdd", "objInstAdd"], "repairPatterns": ["missComp", "singleLine"]}
