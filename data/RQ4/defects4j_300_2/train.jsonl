{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }", "fixed": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                     fu = -fu;\n                 }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n         int searchLen = searchChars.length;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                         return i;\n                 }\n             }\n         }", "fixed": " public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                         return i;\n                    }\n                 }\n             }\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 41, "problem": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "fixed": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Closure", "bugId": 13, "problem": " private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n        traverse(c);\n         Node next = c.getNext();\n         c = next;\n       }", "fixed": " private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         Node next = c.getNext();\n        traverse(c);\n         c = next;\n       }", "observations": "Only one line of code was moved.", "repairActions": ["mcMove"], "repairPatterns": ["codeMove", "singleLine"]}
{"project": "Math", "bugId": 95, "problem": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             ret = d / (d - 2.0);\n         return ret;\n     }", "fixed": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret = 1.0;\n         double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n             ret = d / (d - 2.0);\n        }\n         return ret;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["initFix", "wrapsIf"]}
{"project": "Mockito", "bugId": 23, "problem": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "fixed": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n\t\t        .serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Mockito", "bugId": 24, "problem": " public Object answer(InvocationOnMock invocation) {\n            return 1;\n         }\n         Class<?> returnType = invocation.getMethod().getReturnType();", "fixed": " public Object answer(InvocationOnMock invocation) {\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n         }\n         Class<?> returnType = invocation.getMethod().getReturnType();", "observations": "If-Else implicit in \"exp?x:y\" format", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n            }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 104, "problem": "     private static final long serialVersionUID = -6587513359895466954L;\n     \n    private static final double DEFAULT_EPSILON = 10e-9;\n     \n     private static double[] lanczos =", "fixed": "     private static final long serialVersionUID = -6587513359895466954L;\n     \n    private static final double DEFAULT_EPSILON = 10e-15;\n     \n     private static double[] lanczos =", "observations": "", "repairActions": ["assignExpChange"], "repairPatterns": ["constChange", "initFix", "singleLine"]}
{"project": "Time", "bugId": 13, "problem": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }", "fixed": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n                        buf.insert(bufLen, '-');\n                    }\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expArithMod", "wrapsIfElse"]}
{"project": "Math", "bugId": 99, "problem": " public static int lcm(int a, int b) {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n         return lcm;\n     }", "fixed": " public static int lcm(int a, int b) {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n         return lcm;\n     }", "observations": "Instantiates a vector object as part of the exception creation.", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Closure", "bugId": 65, "problem": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "fixed": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\000\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Mockito", "bugId": 28, "problem": " public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\r\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\r\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n         }\r\n     }\r", "fixed": " public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\r\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\r\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n            mocks.remove(injected);\r\n         }\r\n     }\r", "observations": "Changes method signature adding new parameter.", "repairActions": ["assignAdd", "mcAdd", "varAdd"], "repairPatterns": ["missComp", "singleLine", "wrapsMethod"]}
{"project": "Closure", "bugId": 58, "problem": " private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             lhs = lhs.getLastChild();\n           }\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;", "fixed": " private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             lhs = lhs.getLastChild();\n           }\n          if (NodeUtil.isName(lhs)) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n          } else {\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Closure", "bugId": 26, "problem": " private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n      if (!modulesWithExports.contains(moduleName)) {\n        return;\n      }\n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Mockito", "bugId": 30, "problem": " public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n    public void smartNullPointerException(Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"", "fixed": " public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n    public void smartNullPointerException(Object obj, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n                obj,\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"", "observations": "Adds new parameter to method signature, ajust code.", "repairActions": ["mcParAdd", "mcRepl", "mdParAdd", "objInstMod"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Time", "bugId": 14, "problem": " public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {", "fixed": " public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 109, "problem": " private Node parseTypeExpression(JsDocToken token) {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n   }\n   /**", "fixed": " private Node parseTypeExpression(JsDocToken token) {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n   }\n   /**", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "mcRepl", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockRetAdd", "wrapsIfElse", "wrongComp", "wrongMethodRef"]}
{"project": "Time", "bugId": 23, "problem": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "fixed": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "observations": "Changes entries in a key-value map.", "repairActions": ["mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Closure", "bugId": 37, "problem": " Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n       Node bodyNode = transform(functionNode.getBody());\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;", "fixed": " Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n       Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;", "observations": "Replaces method call by overloaded method with extra parameters.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["condBlockOthersAdd", "wrongMethodRef"]}
{"project": "Math", "bugId": 37, "problem": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "fixed": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n        return reportMatcher(new InstanceOf(Long.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 60, "problem": " public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }", "fixed": " public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }", "observations": "", "repairActions": ["loopCondChange", "varReplVar"], "repairPatterns": ["expLogicMod", "wrongVarRef"]}
{"project": "Math", "bugId": 9, "problem": " public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n         return reverted;\n     }", "fixed": " public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n        final Line reverted = new Line(this);\n        reverted.direction = reverted.direction.negate();\n         return reverted;\n     }", "observations": "Replaced constructor by overloaded version. Changes object attribute value by direct assignment.", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "objInstMod"], "repairPatterns": ["initFix", "wrongMethodRef"]}
{"project": "Lang", "bugId": 33, "problem": " private static String toCanonicalName(String className) {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n         }\n         return classes;\n     }", "fixed": " private static String toCanonicalName(String className) {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i] == null ? null : array[i].getClass();\n         }\n         return classes;\n     }", "observations": "Wrap-with applied with IfElse-Expression", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckP", "singleLine", "wrapsIfElse"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                return new VectorialPointValuePair(point, objective);\n             }", "fixed": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                return current;\n             }", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Math", "bugId": 83, "problem": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "fixed": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Closure", "bugId": 21, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isExprResult()) {\n       return;\n     }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isExprResult() || n.isBlock()) {\n       return;\n     }", "observations": "", "repairActions": ["assignRem", "condBranRem", "condExpExpand", "loopRem", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockRem", "expLogicExpand", "expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 98, "problem": " Reference getInitializingReferenceForConstants() {\n     boolean isAssignedOnceInLifetime() {\n       Reference ref = getOneAndOnlyAssignment();\n       if (ref == null) {\n         return false;\n       }\n       return true;\n     }\n     ", "fixed": " Reference getInitializingReferenceForConstants() {\n     boolean isAssignedOnceInLifetime() {\n       Reference ref = getOneAndOnlyAssignment();\n       if (ref == null) {\n         return false;\n       }\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n       return true;\n     }\n     ", "observations": "New class attributes were added.", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n         sb.append(property);\n         sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n         ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }", "fixed": " String toStringHelper(boolean forAnnotations) {\n         sb.append(property);\n         sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n         ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 4, "problem": " public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n     private String exceptionCauseMessageIfAvailable(Exception details) {\n         return details.getCause().getMessage();\n     }", "fixed": " public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n     private String exceptionCauseMessageIfAvailable(Exception details) {\n        if (details.getCause() == null) {\n            return details.getMessage();\n        }\n         return details.getCause().getMessage();\n     }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Time", "bugId": 25, "problem": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n         }\n         return offsetAdjusted;\n     }", "fixed": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n         }\n         return offsetAdjusted;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Time", "bugId": 24, "problem": " public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');", "fixed": " public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 38, "problem": " private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\nthrow new PathIsExploredException();\n             }\n         } while (getEvaluations() < npt);\n}", "fixed": " private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n             }\n         } while (getEvaluations() < npt);\n}", "observations": "Removes Exception Thrown. The throws line is commented in code... maybe the change isn't a final one.", "repairActions": ["assignExpChange", "exThrowsRem", "objInstRem"], "repairPatterns": ["copyPaste", "expArithMod", "initFix", "wrongComp"]}
{"project": "Closure", "bugId": 53, "problem": " private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n       Node replacement;\n         nodes.add(new Node(Token.TRUE));", "fixed": " private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n       Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = new Node(Token.TRUE);\n      } else {\n         nodes.add(new Node(Token.TRUE));", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 15, "problem": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }", "fixed": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Time", "bugId": 2, "problem": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n         return 0;\n     }", "fixed": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n         return 0;\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Mockito", "bugId": 31, "problem": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \t\tprivate String formatMethodCall() {\r\n\t\t\treturn invocation.getMethod().getName() + \"()\";\r\n \t\t}\r\n     }\r", "fixed": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \t\tprivate String formatMethodCall() {\r\n\t\t\tString args = Arrays.toString(invocation.getArguments());\r\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\r\n \t\t}\r\n     }\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Math", "bugId": 39, "problem": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n         for (int k = 1; k < stages; ++k) {", "fixed": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n         for (int k = 1; k < stages; ++k) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 8, "problem": " public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();", "fixed": " public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n        final Object[] out = new Object[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();", "observations": "Ajust the object initialization to reflect type changed.", "repairActions": ["mcRem", "mdRetTyChange", "varTyChange"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 34, "problem": " void endCaseBody() {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n        if (getLastChar() != ' ') {\n           append(\" \");\n         }\n         append(op);", "fixed": " void endCaseBody() {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n           append(\" \");\n         }\n         append(op);", "observations": "", "repairActions": ["condExpExpand", "mcAdd", "mcParAdd", "mcRepl", "varReplVar"], "repairPatterns": ["expLogicExpand", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 40, "problem": " public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n        return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }", "fixed": " public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n     }", "observations": "", "repairActions": ["assignAdd", "loopAdd", "mcAdd", "mcRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrongComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n        return reportMatcher(new InstanceOf(Short.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 30, "problem": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n   @Override", "fixed": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n   @Override", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 34, "problem": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "fixed": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Time", "bugId": 3, "problem": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n     }", "fixed": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 6, "problem": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(Any.ANY).returnFalse();\r\n     }\r\n     /**\r", "fixed": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 22, "problem": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return true;\n     }\n     ", "fixed": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return false;\n     }\n     ", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Lang", "bugId": 31, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n \t\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t}", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n \t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}", "observations": "Partially the same as Lang 30", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp", "wrapsIfElse"]}
{"project": "Lang", "bugId": 46, "problem": " public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n        return escapeJavaStyleString(str, true);\n     }\n     /**", "fixed": " public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n        return escapeJavaStyleString(str, true, true);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 52, "problem": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0;\n   }\n   static double getSimpleNumber(String s) {", "fixed": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0 && s.charAt(0) != '0';\n   }\n   static double getSimpleNumber(String s) {", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 72, "problem": " public double solve(final UnivariateRealFunction f,\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n             return result;\n         }", "fixed": " public double solve(final UnivariateRealFunction f,\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n             return result;\n         }", "observations": "Similar changes in two different places, the same melhod is targeted, the same argument is changed, only the new values applied are different.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 89, "problem": " boolean canCollapseUnannotatedChildNames() {\n       }\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n         return false;\n       }", "fixed": " boolean canCollapseUnannotatedChildNames() {\n       }\n      if (aliasingGets > 0) {\n         return false;\n       }", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missNullCheckN"]}
{"project": "Chart", "bugId": 21, "problem": " public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r", "fixed": " public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n        else {\r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Lang", "bugId": 59, "problem": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);", "observations": "", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 24, "problem": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return current;\n             }\n             ++iter;\n         }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["copyPaste", "wrapsMethod"]}
{"project": "Closure", "bugId": 66, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n         }\n         break;", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n        } else {\n          typeable = false;\n         }\n         break;", "observations": "", "repairActions": ["assignAdd", "condBranElseAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Time", "bugId": 3, "problem": " public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n     }", "fixed": " public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n        if (amount != 0) {\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 49, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n       case Token.FUNCTION:\n         nameStack.pop();\n         break;\n       case Token.CATCH:", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n       case Token.FUNCTION:\n        nameStack.pop();\n         nameStack.pop();\n         break;\n      case Token.LP:\n        break;\n       case Token.CATCH:", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranCaseAdd", "condBranRem", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n        return reportMatcher(Any.ANY).returnString();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n        return reportMatcher(new InstanceOf(String.class)).returnString();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Chart", "bugId": 9, "problem": " public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\nendIndex = -(endIndex + 1);\nendIndex = endIndex - 1;\n         }\r\n        if (endIndex < 0) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r", "fixed": " public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\nendIndex = -(endIndex + 1);\nendIndex = endIndex - 1;\n         }\r\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i];\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 68, "problem": " boolean parse() {\n                         }\n                         break;\n                     }\n                   token = eatTokensUntilEOL();\n                  }\n                   continue retry;\n               }\n             }", "fixed": " boolean parse() {\n                         }\n                         break;\n                     }\n                  }\n                   token = eatTokensUntilEOL();\n                   continue retry;\n               }\n             }", "observations": "An assignment was moved outside a branch.", "repairActions": ["mcAdd"], "repairPatterns": ["codeMove", "copyPaste", "missComp", "unwrapIfElse"]}
{"project": "Math", "bugId": 79, "problem": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "fixed": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["notClassified"]}
{"project": "Mockito", "bugId": 17, "problem": " public MockUtil() {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\r\n         Class<?>[] ancillaryTypes;\r\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\r\n         Object spiedInstance = settings.getSpiedInstance();\r", "fixed": " public MockUtil() {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\r\n         Class<?>[] ancillaryTypes;\r\n        if (settings.isSerializable()) {\r\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\r\n        } else {\r\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\r\n        }\r\n         Object spiedInstance = settings.getSpiedInstance();\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Lang", "bugId": 15, "problem": " private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n             return typeVarAssigns;\n         }", "fixed": " private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        if (toClass.equals(cls)) {\n             return typeVarAssigns;\n         }", "observations": "Change local var type.", "repairActions": ["assignExpChange", "condExpRed", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicReduce", "wrongMethodRef"]}
{"project": "Math", "bugId": 98, "problem": " public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[v.length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {", "fixed": " public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {", "observations": "Changes dimension of two vectors.", "repairActions": ["varReplVar"], "repairPatterns": ["copyPaste", "initFix", "wrongVarRef"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n         int iter = 0;\n         while (true) {", "fixed": " protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        UnivariatePointValuePair best = current;\n         int iter = 0;\n         while (true) {", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Mockito", "bugId": 29, "problem": " public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n        description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }", "fixed": " public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }", "observations": "Wrapping implicit in \"exp?x:y\" format", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckP", "singleLine", "wrapsIfElse"]}
{"project": "Closure", "bugId": 72, "problem": " private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n      if (li.referenced) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {", "fixed": " private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n      if (li.referenced || !removeUnused) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {", "observations": "Instantiates an anonymous object and make a method call on it.", "repairActions": ["condExpExpand", "mcAdd", "objInstAdd"], "repairPatterns": ["expLogicExpand", "missComp"]}
{"project": "Math", "bugId": 47, "problem": " public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n     }\n     ", "fixed": " public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n        isZero = real == 0 && imaginary == 0;\n     }\n     ", "observations": "The \"WrapWith\" condition is in the form \"exp?a:b\". The added variable is a class attribute.", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "retExpChange", "varAdd"], "repairPatterns": ["copyPaste", "expLogicMod", "wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 62, "problem": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "fixed": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "observations": "Just changed the operator in \"if\" condition", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 19, "problem": " protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +", "fixed": " protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n      case Token.THIS:\n        break;\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +", "observations": "", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Mockito", "bugId": 2, "problem": "     private long startTime = -1;\n     public Timer(long durationMillis) {\n         this.durationMillis = durationMillis;\n     }", "fixed": "     private long startTime = -1;\n     public Timer(long durationMillis) {\n        validateInput(durationMillis);\n         this.durationMillis = durationMillis;\n     }", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Closure", "bugId": 115, "problem": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "condBlockRem"]}
{"project": "Math", "bugId": 101, "problem": " public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n        if (\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {", "fixed": " public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Lang", "bugId": 36, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n        if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand"]}
{"project": "Time", "bugId": 26, "problem": " public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }", "fixed": " public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Lang", "bugId": 52, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                     default :\n                         out.write(ch);\n                         break;", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                     default :\n                         out.write(ch);\n                         break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 93, "problem": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "fixed": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            if (searchChars.indexOf(ch) < 0) {\n                     return i;\n             }\n         }\n         return INDEX_NOT_FOUND;", "fixed": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                     return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n             }\n         }\n         return INDEX_NOT_FOUND;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Math", "bugId": 37, "problem": " public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);", "fixed": " public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n             return NaN;\n         }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n        return (T) anyObject();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 2, "problem": " public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "fixed": " public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n        if (str.contains(\"\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Chart", "bugId": 11, "problem": " public static boolean equal(GeneralPath p1, GeneralPath p2) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();", "fixed": " public static boolean equal(GeneralPath p1, GeneralPath p2) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();", "observations": "Replaces var referencing of target object of a call.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 78, "problem": " public boolean evaluateStep(final StepInterpolator interpolator)\n                 if (g0Positive ^ (gb >= 0)) {", "fixed": " public boolean evaluateStep(final StepInterpolator interpolator)\n                 if (g0Positive ^ (gb >= 0)) {\n                    if (ga * gb > 0) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Math", "bugId": 74, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale = new double[y0.length];\n           if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n             } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "observations": "A vector/object was instantiated.The way to initialize values was changed.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "mcRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Lang", "bugId": 47, "problem": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missNullCheckP"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n            zone = timeZone;\n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node block(Node ... stmts) {\n     return block;\n   }\n   public static Node script(Node ... stmts) {", "fixed": " public static Node block(Node ... stmts) {\n     return block;\n   }\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n   public static Node script(Node ... stmts) {", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Lang", "bugId": 4, "problem": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "fixed": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq.toString());\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar) {\n           Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n               null;\n          Node varNode = parent;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "fixed": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n           Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n               null;\n          Node varNode = null;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Time", "bugId": 2, "problem": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {", "fixed": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Closure", "bugId": 76, "problem": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\nif (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n      }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "fixed": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Closure", "bugId": 14, "problem": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "fixed": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "observations": "Parameter value change.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["constChange", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 106, "problem": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r", "fixed": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n        if (den.intValue() < 0) {\r\n            pos.setIndex(initialIndex);\r\n            return null;\r\n        }\r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r", "observations": "Only one variable is different between the two blocks of code in patch.", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste"]}
{"project": "Lang", "bugId": 36, "problem": " public static boolean isNumber(String str) {\n                 return false;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'", "fixed": " public static boolean isNumber(String str) {\n                 return false;\n             }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    return false;\n                }\n                return foundDigit;\n            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand"]}
{"project": "Closure", "bugId": 99, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n             return false;\n           }\n       }\n     }", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n        if (NodeUtil.isGet(lhs)) {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n        }\n       }\n     }", "observations": "Changed condition in expression, adds an extra computing in line 131.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "expLogicMod", "wrapsIf"]}
{"project": "Mockito", "bugId": 10, "problem": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n                withSettingsUsing(returnTypeGenericMetadata)\r\n         );\r\n     }\r\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n        return mockSettings.serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r", "fixed": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\r\n        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\r\n         );\r\n     }\r\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n        return propagateSerializationSettings(mockSettings, parentMockSettings)\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\r\n        return mockSettings.serializable(parentMockSettings.getSerializableMode());\r\n    }\r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r", "observations": "Changes signature of existent methods, adding new params.", "repairActions": ["mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         }\n         PointValuePair current = null;\n        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n            ++iter;\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }", "fixed": " protected PointValuePair doOptimize() {\n         }\n         PointValuePair current = null;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n            incrementIterationCount();\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                     return current;\n                 }", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 51, "problem": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "fixed": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x && !isNegativeZero(x)) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return \"{...}\";\n     }\n   }", "fixed": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n     }\n   }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Closure", "bugId": 80, "problem": " static boolean isBooleanResultHelper(Node n) {\n       case Token.NOT:\n         return true;\n       default:\n         return false;", "fixed": " static boolean isBooleanResultHelper(Node n) {\n       case Token.NOT:\n      case Token.DELPROP:\n         return true;\n       default:\n         return false;", "observations": "These blocks are inserted as extra switch clauses. Should be a \"Missing Condition\", \"Missing Block\" or both?", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["expLogicExpand"]}
{"project": "Mockito", "bugId": 6, "problem": " public static String anyString() {\n      * @return empty List.\r\n      */\r\n     public static List anyList() {\r\n        return reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static String anyString() {\n      * @return empty List.\r\n      */\r\n     public static List anyList() {\r\n        return reportMatcher(new InstanceOf(List.class)).returnList();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "fixed": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Mockito", "bugId": 23, "problem": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "fixed": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n    private synchronized void instantiateMockitoCoreIfNeeded() {\r\n        if (mockitoCore == null) {\r\n            mockitoCore = new MockitoCore();\r\n        }\r\n    }\r\n    private synchronized void instantiateDelegateIfNeeded() {\r\n        if (delegate == null) {\r\n            delegate = new ReturnsEmptyValues();\r\n        }\r\n    }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Closure", "bugId": 23, "problem": " private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n     Node current = left.getFirstChild();\n     Node elem = null;\n    for (int i = 0; current != null && i < intIndex; i++) {\n         elem = current;\n       current = current.getNext();\n     }", "fixed": " private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n     Node current = left.getFirstChild();\n     Node elem = null;\n    for (int i = 0; current != null; i++) {\n      if (i != intIndex) {\n        if (mayHaveSideEffects(current)) {\n          return n;\n        }\n      } else {\n         elem = current;\n      }\n       current = current.getNext();\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopCondChange", "mcAdd", "retBranchAdd"], "repairPatterns": ["expLogicReduce", "wrapsIfElse"]}
{"project": "Closure", "bugId": 70, "problem": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "fixed": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return isZero ? NaN : INF;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "fixed": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return NaN;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 18, "problem": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "fixed": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "observations": "Returns instantiated ArrayList<Object>", "repairActions": ["condBranIfAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 30, "problem": " boolean dependsOnOuterScopeVars(String name, Node useNode) {\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {", "fixed": " boolean dependsOnOuterScopeVars(String name, Node useNode) {\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    if (def.unknownDependencies) {\n      return true;\n    }\n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 1, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Chart", "bugId": 26, "problem": " else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n         }\r\n         return state;\r", "fixed": " else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n            if (owner != null) {\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n            }\r\n         }\r\n         return state;\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Lang", "bugId": 43, "problem": " private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;", "fixed": " private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Lang", "bugId": 11, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n        } else {\n            if (end <= start) {\n                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["condBranElseAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 75, "problem": " static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\ncase '\\u000B':\n        return TernaryValue.TRUE;\ncase ' ':\ncase '\\n':\ncase '\\r':", "fixed": " static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\ncase '\\u000B':\nreturn TernaryValue.UNKNOWN;\ncase ' ':\ncase '\\n':\ncase '\\r':", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd", "retExpChange", "varReplVar"], "repairPatterns": ["condBlockRetAdd", "constChange", "wrongVarRef"]}
{"project": "Math", "bugId": 94, "problem": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 78, "problem": " private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;", "fixed": " private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n           return null;\n         }\n         result = lval / rval;", "observations": "Removes error invocation call.", "repairActions": ["mcRem"], "repairPatterns": ["copyPaste"]}
{"project": "Chart", "bugId": 18, "problem": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n        if (index < this.keys.size()) {\n         rebuildIndex();\n        }\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n\t\t\treturn;\n         }\n         removeValue(index);\n     }\n     ", "fixed": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n         rebuildIndex();\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n            throw new UnknownKeyException(\"The key (\" + key \n                    + \") is not recognised.\");\n         }\n         removeValue(index);\n     }\n     ", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Lang", "bugId": 29, "problem": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static float toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "fixed": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static int toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "observations": "Changes return type of method.", "repairActions": ["mdRetTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Closure", "bugId": 111, "problem": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType;\n         }\n         @Override", "fixed": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n         }\n         @Override", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Chart", "bugId": 4, "problem": " public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r", "fixed": " public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                if (r != null) {\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Math", "bugId": 61, "problem": " public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));", "fixed": " public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));", "observations": "Replaces Exception Thrown. Changed the type of exception thrown. Changed the imported type.", "repairActions": ["mcRem", "objInstAdd"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Chart", "bugId": 25, "problem": " protected void drawHorizontalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "fixed": " protected void drawHorizontalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n        if (meanValue == null) {\r\n            return;\r\n        }\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Closure", "bugId": 40, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n          }\n         }\n       }\n     }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n         }\n       }\n     }", "observations": "Removed a null check, maintaining the branch code.", "repairActions": ["condBranRem", "mcParValChange"], "repairPatterns": ["constChange", "unwrapIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Map anyMap() {\n      * @return empty Map.\r\n      */\r\n     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\r\n        return reportMatcher(Any.ANY).returnMap();\r\n     }\r\n     /**\r", "fixed": " public static Map anyMap() {\n      * @return empty Map.\r\n      */\r\n     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\r\n        return anyMap();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 34, "problem": "      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n     }\n     /**", "fixed": "      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n        return m != null && m.containsKey(value);\n     }\n     /**", "observations": "", "repairActions": ["condBranRem", "mcRem", "retExpChange"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "unwrapIfElse"]}
{"project": "Mockito", "bugId": 19, "problem": " public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n     }\n }", "fixed": " public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n     }\n }", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n         }\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "fixed": "else if (lclip <= 0.0) {\n         }\r\n        Number n = dataset.getStdDevValue(row, column);\r\n        if (n != null) {\r\n            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Closure", "bugId": 20, "problem": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "fixed": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckP", "singleLine"]}
{"project": "Math", "bugId": 83, "problem": " private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n        int start = getNumObjectiveFunctions();\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;", "fixed": " private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Chart", "bugId": 21, "problem": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "fixed": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n        }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Closure", "bugId": 116, "problem": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\n     Node cArg = callNode.getFirstChild().getNext();", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\nboolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(\n            stmt.getFirstChild(), compiler);\n      }\n    }\n     Node cArg = callNode.getFirstChild().getNext();", "observations": "Strange... what is removed in 115 is added again in 116.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n        int iter = 0;\n         for (boolean converged = false; !converged;) {\n            ++iter;\n             PointVectorValuePair previous = current;", "fixed": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n         for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n             PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 52, "problem": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  if (c == 0) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "fixed": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "observations": "New variable is added with its initialization.", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];", "fixed": " protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n        double[] oldObj  = new double[rows];\n        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 93, "problem": " public static double factorialDouble(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }", "fixed": " public static double factorialDouble(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n        if (n < 21) {\n            return factorial(n);\n        }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 55, "problem": " public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n             stopTime = System.currentTimeMillis();\n         this.runningState = STATE_STOPPED;\n     }", "fixed": " public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n        }\n         this.runningState = STATE_STOPPED;\n     }", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(residuals);\n             for (int k = 0; k < solvedCols; ++k) {", "fixed": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(qtf);\n             for (int k = 0; k < solvedCols; ++k) {", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 89, "problem": " private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n     Node nameNode = NodeUtil.newName(", "fixed": " private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n    }\n     Node nameNode = NodeUtil.newName(", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missNullCheckN"]}
{"project": "Math", "bugId": 88, "problem": " protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));", "fixed": " protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopRem", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["blockRemove", "condBlockRem", "wrapsIfElse", "wrongComp"]}
{"project": "Lang", "bugId": 46, "problem": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "fixed": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n            boolean escapeForwardSlash) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Mockito", "bugId": 20, "problem": " public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"", "fixed": " public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"", "observations": "Instantiates an InstantiatonProvider object", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRepl", "objInstAdd", "varAdd", "varReplVar"], "repairPatterns": ["wrongVarRef"]}
{"project": "Closure", "bugId": 96, "problem": " private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n           parameters.hasNext()) {\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;", "fixed": " private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      if (parameters.hasNext()) {\n         parameter = parameters.next();\n      }\n       argument = arguments.next();\n       ordinal++;", "observations": "", "repairActions": ["condBranIfAdd", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "wrapsIf"]}
{"project": "Closure", "bugId": 54, "problem": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          if (!qVar.isTypeInferred()) {", "fixed": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.getType() == Token.OBJECTLIT) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Math", "bugId": 6, "problem": " protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n         evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n     }\n     /**", "fixed": " protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n         evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n     }\n     /**", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 25, "problem": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n     Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "fixed": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n     Node constructor = n.getFirstChild();\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcRem"], "repairPatterns": ["blockRemove", "notClassified"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isLabelName());\n    Preconditions.checkState(finallyBody.isLabelName());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "fixed": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 87, "problem": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                 row = i;\n                } else {\n                 return null;\n                }\n             }\n         }\n         return row;", "fixed": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                 return null;\n             }\n         }\n         return row;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse", "wrongComp"]}
{"project": "Chart", "bugId": 2, "problem": " public static Range iterateRangeBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                     double lvalue = ixyd.getStartYValue(series, item);\r\n                     double uvalue = ixyd.getEndYValue(series, item);\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "fixed": " public static Range iterateRangeBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                    double value = ixyd.getYValue(series, item);\r\n                     double lvalue = ixyd.getStartYValue(series, item);\r\n                     double uvalue = ixyd.getEndYValue(series, item);\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum = Math.min(minimum, value);\r\n                        maximum = Math.max(maximum, value);\r\n                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Closure", "bugId": 6, "problem": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n       mismatch(t, n, msg, rightType, leftType);\n      }\n       return false;\n     }\n     return true;", "fixed": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n       mismatch(t, n, msg, rightType, leftType);\n       return false;\n     }\n     return true;", "observations": "", "repairActions": ["condBranRem", "mcRem"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\nif (!stop) {\n                 if (checker != null) {\n                    stop = checker.converged(iter, previous, current);\n                 }\n             }\n             if (stop) {", "fixed": " protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\nif (!stop) {\n                 if (checker != null) {\n                    stop = checker.converged(getIterations(), previous, current);\n                 }\n             }\n             if (stop) {", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Chart", "bugId": 22, "problem": " public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n                rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r", "fixed": " public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n            int i = rowData.getIndex(columnKey);\r\n            if (i >= 0) {\r\n                rowData.removeValue(i);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 42, "problem": " Node processExpressionStatement(ExpressionStatement statementNode) {\n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),", "fixed": " Node processExpressionStatement(ExpressionStatement statementNode) {\n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n      if (loopNode.isForEach()) {\n        errorReporter.error(\n            \"unsupported language extension: for each\",\n            sourceName,\n            loopNode.getLineno(), \"\", 0);\n        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      }\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 99, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;", "observations": "Changed condition in expression, adds an extra computing in line 131.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "expLogicMod", "wrapsIf"]}
{"project": "Math", "bugId": 30, "problem": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final int n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "fixed": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final double n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Closure", "bugId": 7, "problem": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "fixed": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          return ctorType.getGreatestSubtype(type);\n        } else {\n          return type.isSubtype(ctorType) ? null : type;\n        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "mcRem", "retBranchAdd", "retRem"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "wrongComp"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n         }\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "fixed": "else if (lclip <= 0.0) {\n         }\r\n        Number n = dataset.getStdDevValue(row, column);\r\n        if (n != null) {\r\n            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 6, "problem": " protected PointVectorValuePair doOptimize() {\n         lmPar = 0;\n         boolean firstIteration = true;\n        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n            ++iter;\n             final PointVectorValuePair previous = current;", "fixed": " protected PointVectorValuePair doOptimize() {\n         lmPar = 0;\n         boolean firstIteration = true;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n            incrementIterationCount();\n             final PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 10, "problem": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "fixed": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "observations": "", "repairActions": ["assignRem", "condBranIfAdd", "mcRem", "varRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Lang", "bugId": 26, "problem": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "fixed": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "observations": "Adds a new parameter to constructor call (call overloaded constructor)", "repairActions": ["objInstMod"], "repairPatterns": ["initFix", "singleLine", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 4, "problem": " public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));", "fixed": " public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Math", "bugId": 75, "problem": " public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n     }\n     /**", "fixed": " public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n        return getPct((Comparable<?>) v);\n     }\n     /**", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Closure", "bugId": 57, "problem": " private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n          if (target != null) {\n             className = target.getString();\n           }\n         }", "fixed": " private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n          if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }", "observations": "Altought there is a null check in the conditional expression, the expression is expanded with an extra condition not related to null-check.", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 103, "problem": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n     }\n     /**", "fixed": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) {\n                return 0.0d;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1.0d;\n            } else {\n                throw ex;\n            }\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "retBranchAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "wrapsTryCatch", "wrongComp"]}
{"project": "Math", "bugId": 62, "problem": " public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, 0);\n     }\n     ", "fixed": " public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n     }\n     ", "observations": "Changes the way to compute \"optima[i]\", changing params for call to \"optimize\". Removed if-branch is in the form \"exp?a:b\".", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcAdd", "mcParAdd", "mcParValChange", "mcRem", "mcRepl", "retExpChange", "varAdd", "varRem"], "repairPatterns": ["expArithMod", "wrongComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 122, "problem": " private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,", "fixed": " private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n    if (p.matcher(comment.getValue()).find()) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,", "observations": "", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["expLogicMod", "wrongComp"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 8, "problem": " private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n           && !blacklistedVars.contains(var);\n     }\n   }\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {", "fixed": " private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n          && !isNamedParameter(var)\n           && !blacklistedVars.contains(var);\n     }\n   }\n  private boolean isNamedParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {", "observations": "Adds a new condition in expression and a new method invocated by this condition.", "repairActions": ["mcAdd", "mdAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Closure", "bugId": 37, "problem": " private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n     traverseBranch(body, n);\n     popScope();", "fixed": " private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n     traverseBranch(body, n);\n     popScope();", "observations": "Replaces method call by overloaded method with extra parameters.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["condBlockOthersAdd", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 21, "problem": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withOuterClass(cls);\n     }\n    private <T> T withOuterClass(Class<T> cls) {\n         try {\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "fixed": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withParams(cls, outerClassInstance);\n     }\n    private static <T> T withParams(Class<T> cls, Object... params) {\n         try {\n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return (T) constructor.newInstance(params);\n                }\n            }\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n        throw paramsException(cls, null);\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "observations": "Apply \"static\" modifier to withParams method", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "mcRepl", "mdAdd", "mdModChange", "mdParAdd", "mdRen", "retBranchAdd", "retExpChange", "retRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "wrongComp"]}
{"project": "Closure", "bugId": 10, "problem": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "fixed": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 35, "problem": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n        return reportMatcher(new Same(value)).<T>returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());\r\n     }\r\n     /**\r", "observations": "", "repairActions": ["mcAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Time", "bugId": 11, "problem": "     static Chronology cLenientISO;\n    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n    static {\n        cVerbose.set(Boolean.FALSE);\n    }\n     /**\n      * Gets a flag indicating that verbose logging is required.", "fixed": "     static Chronology cLenientISO;\n    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n        protected Boolean initialValue() {\n            return Boolean.FALSE;\n        }\n    };\n     /**\n      * Gets a flag indicating that verbose logging is required.", "observations": "Changed a static initialization for a method inline implementation.", "repairActions": ["mcRem", "mdAdd", "mdOverride", "objInstMod", "retBranchAdd"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Lang", "bugId": 58, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {", "observations": "", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n             if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;", "fixed": " public PointVectorValuePair doOptimize() {\n             if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 49, "problem": " public double doubleValue() {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;", "fixed": " public double doubleValue() {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;", "observations": "", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Closure", "bugId": 16, "problem": " private void fixTypeNode(Node typeNode) {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n         }\n       }", "fixed": " private void fixTypeNode(Node typeNode) {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n         }\n       }", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "objInstMod", "varAdd"], "repairPatterns": ["initFix", "wrapsMethod", "wrongComp"]}
{"project": "Math", "bugId": 15, "problem": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n     \n     private static final double F_1_3 = 1d / 3d;", "fixed": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n     \n     private static final double F_1_3 = 1d / 3d;", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Closure", "bugId": 63, "problem": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "fixed": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "observations": "Same as bug 62", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 79, "problem": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n   }\n   /**", "fixed": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n    compiler.reportCodeChange();\n   }\n   /**", "observations": "Calls overloaded method with extra parameters.", "repairActions": ["mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 79, "problem": " private void reportCodeChange(String changeDescription) {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverse(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);", "fixed": " private void reportCodeChange(String changeDescription) {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);", "observations": "Calls overloaded method with extra parameters.", "repairActions": ["mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 18, "problem": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                     return false;\n                 }\n                if (x[i] > 1.0) {\n                     return false;\n                 }\n             }", "fixed": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n            final double[] bLoEnc = encode(boundaries[0]);\n            final double[] bHiEnc = encode(boundaries[1]);\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < bLoEnc[i]) {\n                     return false;\n                 }\n                if (x[i] > bHiEnc[i]) {\n                     return false;\n                 }\n             }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Math", "bugId": 3, "problem": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "fixed": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = computeFollowing(n);\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Closure", "bugId": 64, "problem": " public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n    return toSource(n, null);\n   }\n   \n  private String toSource(Node n, SourceMap sourceMap) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);", "fixed": " public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n   }\n   \n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);", "observations": "New parameters are added in three method calls (call to overloaded methods). A logic expression passed to a method call is changed.", "repairActions": ["mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Mockito", "bugId": 6, "problem": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(new InstanceOf(Set.class)).returnSet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 120, "problem": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n           break;\n         } else if (block.isLoop) {\n           return false;", "fixed": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n           break;\n         } else if (block.isLoop) {\n           return false;", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 127, "problem": " private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);", "fixed": " private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n    private boolean inFinally(Node parent, Node child) {\n      if (parent == null || parent.isFunction()) {\n        return false;\n      } else if (NodeUtil.isTryFinallyNode(parent, child)) {\n        return true;\n      } else {\n        return inFinally(parent.getParent(), parent);\n      }\n    }\n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);", "observations": "", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcAdd", "mdAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand", "missComp", "missNullCheckP"]}
{"project": "Lang", "bugId": 65, "problem": " private static void modify(Calendar val, int field, boolean round) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }", "fixed": " private static void modify(Calendar val, int field, boolean round) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n        if (field == Calendar.MILLISECOND) {\n            return;\n        }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "wrapsIf"]}
{"project": "Closure", "bugId": 2, "problem": " private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {", "fixed": " private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd"], "repairPatterns": ["missNullCheckP", "wrapsIfElse"]}
{"project": "Closure", "bugId": 77, "problem": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "fixed": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "singleLine"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Math", "bugId": 13, "problem": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "Contains the patch of Math-13", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 93, "problem": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "fixed": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Math", "bugId": 6, "problem": " public int compare(final PointValuePair o1,\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n\t\t\t++iteration;\n         }\n     }", "fixed": " public int compare(final PointValuePair o1,\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n            incrementIterationCount();\n         }\n     }", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 22, "problem": " public class Equality {\r\n     public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r", "fixed": " public class Equality {\r\n     public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == o2 ) {\r\n            return true;\r\n\t} else if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r", "observations": "", "repairActions": ["condBranIfElseAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n           Node childVal = child.getFirstChild();", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n          validProperties.add(child.getString());\n           Node childVal = child.getFirstChild();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Chart", "bugId": 6, "problem": " public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n        return super.equals(obj);\n     }", "fixed": " public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n        ShapeList that = (ShapeList) obj;\n        int listSize = size();\n        for (int i = 0; i < listSize; i++) {\n           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n               return false;\n           }\n        }\n        return true;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "mcRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrongComp"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Lang", "bugId": 60, "problem": " public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }", "fixed": " public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }", "observations": "", "repairActions": ["loopCondChange", "varReplVar"], "repairPatterns": ["expLogicMod", "wrongVarRef"]}
{"project": "Mockito", "bugId": 27, "problem": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\r\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "fixed": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "observations": "", "repairActions": ["assignExpChange", "mcAdd", "mcRem", "objInstRem", "varRem"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Math", "bugId": 49, "problem": " public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));", "fixed": " public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Chart", "bugId": 16, "problem": " public void setCategoryKeys(Comparable[] categoryKeys) {\n         if (categoryKeys == null) {\r\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n         }\r\n        if (categoryKeys.length != this.startData[0].length) {\r\n             throw new IllegalArgumentException(\r\n                     \"The number of categories does not match the data.\");\r\n         }\r", "fixed": " public void setCategoryKeys(Comparable[] categoryKeys) {\n         if (categoryKeys == null) {\r\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n         }\r\n        if (categoryKeys.length != getCategoryCount()) {\r\n             throw new IllegalArgumentException(\r\n                     \"The number of categories does not match the data.\");\r\n         }\r", "observations": "Variable initialization in constructor + conditional expression change.", "repairActions": ["assignExpChange", "condExpMod", "mcAdd", "objInstAdd", "varReplMc"], "repairPatterns": ["expLogicMod", "initFix", "wrongVarRef"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                     }\n                 }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best;\n                     }\n                 }", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Time", "bugId": 3, "problem": " public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n             setMillis(getChronology().years().add(getMillis(), years));\n     }", "fixed": " public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n        if (years != 0) {\n             setMillis(getChronology().years().add(getMillis(), years));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Lang", "bugId": 8, "problem": " public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));", "fixed": " public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n            TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Closure", "bugId": 105, "problem": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n        if (sb.length() > 0) {\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);", "fixed": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n        if (sb != null) {\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = null;\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);", "observations": "Moves the instantiation of StringBuilder to another place.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "condExpMod", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "expLogicMod", "initFix"]}
{"project": "Chart", "bugId": 15, "problem": " public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r", "fixed": " public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n        if (this.dataset == null) {\r\n            return 0.0;\r\n        }\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "missNullCheckP", "wrapsIf"]}
{"project": "Closure", "bugId": 47, "problem": " public void addMapping(\n     generator.addMapping(\n         sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }", "fixed": " public void addMapping(\n    int lineBaseOffset = 1;\n    if (generator instanceof SourceMapGeneratorV1\n        || generator instanceof SourceMapGeneratorV2) {\n      lineBaseOffset = 0;\n    }\n     generator.addMapping(\n         sourceFile, originalName,\n        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcParValChange", "objInstMod", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "initFix"]}
{"project": "Closure", "bugId": 102, "problem": " private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }", "fixed": " private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }", "observations": "", "repairActions": ["mcMove"], "repairPatterns": ["codeMove", "singleLine"]}
{"project": "Math", "bugId": 90, "problem": " public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());", "fixed": " public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n        return reportMatcher(Any.ANY).returnMap();\r\n     }\r\n     /**\r", "fixed": " public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n        return reportMatcher(new InstanceOf(Map.class)).returnMap();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 14, "problem": " private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "missComp", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 37, "problem": " public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n     }\r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r", "fixed": " public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n        if (answer instanceof CallsRealMethods) {\r\n            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\r\n        }\r\n     }\r\n    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\r\n        if (invocation.getMethod().getDeclaringClass().isInterface()) {\r\n            reporter.cannotCallRealMethodOnInterface();\r\n        }\r\n    }\r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Lang", "bugId": 46, "problem": " public static String escapeJavaScript(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n        escapeJavaStyleString(out, str, true);\n     }\n     /**", "fixed": " public static String escapeJavaScript(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n        escapeJavaStyleString(out, str, true, true);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 49, "problem": " public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n     if (declarationRoot.getType() != Token.FUNCTION) {\n       findDeclaredNames(declarationRoot, null, renamer);", "fixed": " public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() != Token.FUNCTION) {\n       findDeclaredNames(declarationRoot, null, renamer);", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranCaseAdd", "condBranRem", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Math", "bugId": 31, "problem": " public double evaluate(double x, double epsilon, int maxIterations) {\n                 break;\n             }\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n             n++;\n         }", "fixed": " public double evaluate(double x, double epsilon, int maxIterations) {\n                 break;\n             }\n            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN;\n             n++;\n         }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranRem", "exThrowsRem", "loopRem", "mcAdd", "mcRem", "objInstRem", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "expArithMod", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 46, "problem": " public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false);\n     }\n     /**", "fixed": " public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false, false);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 84, "problem": " Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {", "fixed": " Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "mdAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Lang", "bugId": 7, "problem": " public static BigDecimal createBigDecimal(String str) {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         return new BigDecimal(str);\n     }", "fixed": " public static BigDecimal createBigDecimal(String str) {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n        if (str.trim().startsWith(\"--\")) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n         return new BigDecimal(str);\n     }", "observations": "In one of the chunks, removes a conditional block with return.", "repairActions": ["condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem"], "repairPatterns": ["blockRemove", "condBlockExcAdd", "condBlockRem"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n     return next;\n   }", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n    while (next != null && next.getType() == Token.BLOCK) {\n      if (next.hasChildren()) {\n        next = next.getFirstChild();\n      } else {\n        next = computeFollowing(next);\n      }\n    }\n     return next;\n   }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Math", "bugId": 77, "problem": " public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n         }\n         return max;\n     }", "fixed": " public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }", "observations": "Fix a assignment. Removes a method (aparently, unrelated changes).", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcRem", "mdOverride", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Closure", "bugId": 123, "problem": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "fixed": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "observations": "Changes value in assignment from constant to method call.", "repairActions": ["assignExpChange", "mcAdd", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n     }", "fixed": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 19, "problem": " public OngoingInjecter filterCandidate(Collection<Object> mocks,\n \t\t\t\t\tmockNameMatches.add(mock);\n \t\t\t\t}\n \t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field,\n \t\t\t\t\tfieldInstance);\n \t\t\t/*\n \t\t\t * In this case we have to check whether we have conflicting naming", "fixed": " public OngoingInjecter filterCandidate(Collection<Object> mocks,\n \t\t\t\t\tmockNameMatches.add(mock);\n \t\t\t\t}\n \t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field, fields,\n \t\t\t\t\tfieldInstance);\n \t\t\t/*\n \t\t\t * In this case we have to check whether we have conflicting naming", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Closure", "bugId": 104, "problem": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "fixed": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "observations": "A Null-Check was removed and replaced by another condition.", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 4, "problem": " public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector3D v1D = line.intersection(subLine.line);\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));", "fixed": " public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector3D v1D = line.intersection(subLine.line);\n        if (v1D == null) {\n            return null;\n        }\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));", "observations": "Almost a copy, the only difference is in involved variable.", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 32, "problem": " public void process(Class<?> context, Object testClass) {\n                         Mockito.reset(instance);\r\n                     } else {\r\n                        field.set(testClass, Mockito.spy(instance));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r", "fixed": " public void process(Class<?> context, Object testClass) {\n                         Mockito.reset(instance);\r\n                     } else {\r\n                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\r\n                                .spiedInstance(instance)\r\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\r\n                                .name(field.getName())));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r", "observations": "", "repairActions": ["mcParValChange", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 10, "problem": " public void atan2(final double[] y, final int yOffset,\n         }\n     }", "fixed": " public void atan2(final double[] y, final int yOffset,\n         }\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n     }", "observations": "", "repairActions": ["assignAdd", "mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Closure", "bugId": 17, "problem": " private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();", "fixed": " private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();", "observations": "Transform If structure in Wrap-with IfElse.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN"]}
{"project": "Math", "bugId": 99, "problem": " public static int gcd(final int p, final int q) {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static int gcd(final int p, final int q) {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        new Object[] { p, q });\n            }\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "Instantiates a vector object as part of the exception creation.", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Math", "bugId": 42, "problem": " protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n          if (basicRows.contains(basicRow)) {\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);", "fixed": " protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);", "observations": "", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckN", "wrapsIfElse", "wrongComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Map anyMap() {\n      * @return empty Collection.\r\n      */\r\n     public static Collection anyCollection() {\r\n        return reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static Map anyMap() {\n      * @return empty Collection.\r\n      */\r\n     public static Collection anyCollection() {\r\n        return reportMatcher(new InstanceOf(Collection.class)).returnList();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 7, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\nint hexDigits = str.length() - 2;\nif (str.startsWith(\"-\")) {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\nint hexDigits = str.length() - 2;\nif (str.startsWith(\"-\")) {", "observations": "In one of the chunks, removes a conditional block with return.", "repairActions": ["condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem"], "repairPatterns": ["blockRemove", "condBlockExcAdd", "condBlockRem"]}
{"project": "Closure", "bugId": 32, "problem": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n           ignoreStar = true;\n           token = next();\n           continue;", "fixed": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n           ignoreStar = true;\n          lineStartChar = 0;\n           token = next();\n           continue;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "fixed": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 9, "problem": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "fixed": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n    filename = filename.replace(\"\\\\\", \"/\");\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Chart", "bugId": 24, "problem": " public double getUpperBound() {\n     public Paint getPaint(double value) {\r\n         double v = Math.max(value, this.lowerBound);\r\n         v = Math.min(v, this.upperBound);\r\n        int g = (int) ((value - this.lowerBound) / (this.upperBound \r\n                 - this.lowerBound) * 255.0);\r\n         return new Color(g, g, g);\r\n     }\r", "fixed": " public double getUpperBound() {\n     public Paint getPaint(double value) {\r\n         double v = Math.max(value, this.lowerBound);\r\n         v = Math.min(v, this.upperBound);\r\n        int g = (int) ((v - this.lowerBound) / (this.upperBound \r\n                 - this.lowerBound) * 255.0);\r\n         return new Color(g, g, g);\r\n     }\r", "observations": "Replaces variable in an assignment expression.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["expArithMod", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 45, "problem": " private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;", "fixed": " private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n          boolean maybeEscaped = false;\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condExpExpand", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "initFix", "wrongMethodRef"]}
{"project": "Chart", "bugId": 18, "problem": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n                 rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "fixed": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n    \tif (columnKey == null) {\r\n    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\r\n    \t}\r\n    \tif (!this.columnKeys.contains(columnKey)) {\r\n    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\r\n    \t}\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n            int index = rowData.getIndex(columnKey);\r\n            if (index >= 0) {\r\n                 rowData.removeValue(columnKey);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Lang", "bugId": 4, "problem": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "fixed": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<String, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Lang", "bugId": 14, "problem": " public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n             return cs1.equals(cs2);\n     }\n     /**", "fixed": " public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n        if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Lang", "bugId": 45, "problem": " public static String abbreviate(String str, int lower, int upper, String appendT\n         if (upper == -1 || upper > str.length()) {", "fixed": " public static String abbreviate(String str, int lower, int upper, String appendT\n        if (lower > str.length()) {\n            lower = str.length();    \n        }\n         if (upper == -1 || upper > str.length()) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 52, "problem": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n    if (c == 0) {\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n      if (c == 0) {\n         q0 = 1.0;", "fixed": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n      if (c <= 0) {\n         q0 = 1.0;", "observations": "New variable is added with its initialization.", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Closure", "bugId": 108, "problem": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();", "fixed": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n    private final Set<Node> injectedDecls = Sets.newHashSet();", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Closure", "bugId": 71, "problem": " private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n      boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;", "fixed": " private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n      boolean isOverride = parent.getJSDocInfo() != null &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;", "observations": "The null-check is done in a boolean expression assigned to a variable and not to a conditional test.", "repairActions": ["assignExpChange", "mcAdd", "mcRem"], "repairPatterns": ["expLogicMod", "missNullCheckN", "singleLine"]}
{"project": "Lang", "bugId": 16, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 50, "problem": " private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();", "fixed": " private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n    if (right != null && right.getType() == Token.STRING\n        && \",\".equals(right.getString())) {\n      n.removeChild(right);\n      reportCodeChange();\n    }\n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n        int iter = 0;\n         while (true) {\n            ++iter;\n             double fX = fVal;\n             double fX2 = 0;", "fixed": " protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n         while (true) {\n            incrementIterationCount();\n             double fX = fVal;\n             double fX2 = 0;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 61, "problem": " static boolean functionCallHasSideEffects(\n       }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "fixed": " static boolean functionCallHasSideEffects(\n       }\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "fixed": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 60, "problem": " static TernaryValue getImpureBooleanValue(Node n) {\n         return TernaryValue.TRUE;\n       default:\n         return getPureBooleanValue(n);", "fixed": " static TernaryValue getImpureBooleanValue(Node n) {\n         return TernaryValue.TRUE;\n      case Token.VOID:\n        return TernaryValue.FALSE;\n       default:\n         return getPureBooleanValue(n);", "observations": "", "repairActions": ["condBranCaseAdd", "condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIf"]}
{"project": "Math", "bugId": 84, "problem": " public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n         while (true) {\n             incrementIterationsCounter();", "fixed": " public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n             incrementIterationsCounter();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 66, "problem": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "fixed": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 62, "problem": " public void unescape(Writer writer, String string) throws IOException {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n                             } catch (NumberFormatException e) {\n                             }\n                         }\n} else {", "fixed": " public void unescape(Writer writer, String string) throws IOException {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n                                        break;\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n                                if (entityValue > 0xFFFF) {\n                                    entityValue = -1;\n                                }\n                             } catch (NumberFormatException e) {\n                                entityValue = -1;\n                             }\n                         }\n} else {", "observations": "Added a \"break\" in \"case\" branch.", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Math", "bugId": 62, "problem": " public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         for (int i = 0; i < starts; ++i) {\n             try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {", "fixed": " public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         for (int i = 0; i < starts; ++i) {\n             try {\n                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, min, max, s);\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {", "observations": "Changes the way to compute \"optima[i]\", changing params for call to \"optimize\". Removed if-branch is in the form \"exp?a:b\".", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcAdd", "mcParAdd", "mcParValChange", "mcRem", "mcRepl", "retExpChange", "varAdd", "varRem"], "repairPatterns": ["expArithMod", "wrongComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 48, "problem": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                     break;\n                 default:", "fixed": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                     break;\n                 default:", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Math", "bugId": 106, "problem": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         int startIndex = pos.getIndex();\r", "fixed": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n        if (num.intValue() < 0) {\r\n            pos.setIndex(initialIndex);\r\n            return null;\r\n        }\r\n         int startIndex = pos.getIndex();\r", "observations": "Only one variable is different between the two blocks of code in patch.", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste"]}
{"project": "Mockito", "bugId": 19, "problem": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "fixed": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 57, "problem": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "fixed": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "observations": "Just changed the declared type of a primitive variable.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Math", "bugId": 51, "problem": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 default:\n                 }\n             }", "fixed": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                 default:\n                    throw new MathInternalError();\n                 }\n             }", "observations": "Adds an exception throw in default clause of switch-case.", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Math", "bugId": 54, "problem": " public double toDouble() {\n         Dfp y = this;\n         boolean negate = false;\n        if (lessThan(getZero())) {\n             y = negate();\n             negate = true;\n         }", "fixed": " public double toDouble() {\n         Dfp y = this;\n         boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n             y = negate();\n             negate = true;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "wrapsIfElse"]}
{"project": "Math", "bugId": 68, "problem": " public LevenbergMarquardtOptimizer() {\n         setMaxIterations(1000);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);", "fixed": " public LevenbergMarquardtOptimizer() {\n         setMaxIterations(1000);\n        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Math", "bugId": 86, "problem": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "fixed": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "observations": "The condition to throw the exception is moved from one place to another.", "repairActions": ["condBranIfAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "objInstAdd", "objInstRem"], "repairPatterns": ["codeMove"]}
{"project": "Chart", "bugId": 20, "problem": " public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        super(paint, stroke, paint, stroke, alpha);\r\n         this.value = value;\r\n     }\r", "fixed": " public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\r\n         this.value = value;\r\n     }\r", "observations": "Replaces params value passed to constructor.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n                 }\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n                        return new VectorialPointValuePair(point, objective);\n                     }", "fixed": " protected VectorialPointValuePair doOptimize()\n                 }\n                if (checker != null) {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;                        \n                    }\n                } else {\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                     }\n                }", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 53, "problem": " private void replaceAssignmentExpression(Var v, Reference ref,\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);", "fixed": " private void replaceAssignmentExpression(Var v, Reference ref,\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n      }\n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Chart", "bugId": 22, "problem": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n        if (row >= 0) {\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n         }\r\n         else {\r\n             return null;\r", "fixed": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n        int index = rowData.getIndex(columnKey);\r\n        if (index >= 0) {\r\n            return rowData.getObject(index);\r\n         }\r\n         else {\r\n             return null;\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n             final RealMatrix arz = randn1(dimension, lambda);", "fixed": " protected PointValuePair doOptimize() {\n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n            incrementIterationCount();\n             final RealMatrix arz = randn1(dimension, lambda);", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 9, "problem": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "fixed": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n    \t}\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 36, "problem": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n         return result;\n     }", "fixed": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n        if (Double.isNaN(result)) {\n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n            result = numerator.shiftRight(shift).floatValue() /\n                denominator.shiftRight(shift).floatValue();\n        }\n         return result;\n     }", "observations": "The change is almost the same in two different places. The only difference between changes is the use of the call \"doubleValue()\" in place of \"floatValue()\" in correspondent methods.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Math", "bugId": 53, "problem": " public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }", "fixed": " public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 44, "problem": " void add(String newcode) {\n       append(\" \");\n     }\n     append(newcode);", "fixed": " void add(String newcode) {\n       append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      append(\" \");\n     }\n     append(newcode);", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Time", "bugId": 19, "problem": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);", "fixed": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);", "observations": "", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 41, "problem": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }", "fixed": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }", "observations": "The changes were made only inside the for loop.", "repairActions": ["assignExpChange", "loopCondChange", "loopInitChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Lang", "bugId": 23, "problem": "  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";", "fixed": "  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n    private static final int HASH_SEED = 31;\n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";", "observations": "Implements equals and hascode to work with hash structures of Collections", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mdAdd", "mdOverride", "varAdd"], "repairPatterns": ["condBlockRetAdd", "fixAPI", "wrongComp"]}
{"project": "Lang", "bugId": 34, "problem": "      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n     }\n     /**", "fixed": "      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n        return REGISTRY.get();\n     }\n     /**", "observations": "", "repairActions": ["condBranRem", "mcRem", "retExpChange"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 16, "problem": "  */\n public class FastMath {\n     \n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "fixed": "  */\n public class FastMath {\n     \n    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Closure", "bugId": 113, "problem": " private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n      if (provided != null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }", "fixed": " private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n      if (provided != null || requiresLevel.isOn()) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }", "observations": "Again, an existent condition with Null-Check was expanded with other condition.", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 89, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n             addValue((Comparable<?>) v);            \n     }\n     /**", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n        } else {\n            throw new IllegalArgumentException(\"Object must implement Comparable\");\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Lang", "bugId": 62, "problem": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "fixed": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                            if (entityValue > 0xFFFF) {\n                                entityValue = -1;\n                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "observations": "Added a \"break\" in \"case\" branch.", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Lang", "bugId": 38, "problem": " public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }", "fixed": " public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\ncalendar.getTime();\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Closure", "bugId": 108, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         JSDocInfo info = n.getJSDocInfo();\n        if (info != null && !injectedDecls.contains(n)) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
