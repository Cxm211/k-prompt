{"id": "keras_41", "problem": " class GeneratorEnqueuer(SequenceEnqueuer):\n                 else:\n                     thread.join(timeout)\n        if self._use_multiprocessing:\n            if self.queue is not None:\n                self.queue.close()\n         self._threads = []\n         self._stop_event = None", "fixed": " class GeneratorEnqueuer(SequenceEnqueuer):\n                 else:\n                     thread.join(timeout)\n        if self._manager:\n            self._manager.shutdown()\n         self._threads = []\n         self._stop_event = None"}
{"id": "pandas_99", "problem": " def _convert_listlike_datetimes(\n     elif unit is not None:\n         if format is not None:\n             raise ValueError(\"cannot specify both format and unit\")\n        arg = getattr(arg, \"values\", arg)\n        result, tz_parsed = tslib.array_with_unit_to_datetime(arg, unit, errors=errors)\n         if errors == \"ignore\":\n             from pandas import Index", "fixed": " def _convert_listlike_datetimes(\n     elif unit is not None:\n         if format is not None:\n             raise ValueError(\"cannot specify both format and unit\")\n        arg = getattr(arg, \"_values\", arg)\n        if isinstance(arg, IntegerArray):\n            mask = arg.isna()\n            arg = arg._ndarray_values\n        else:\n            mask = None\n        result, tz_parsed = tslib.array_with_unit_to_datetime(\n            arg, mask, unit, errors=errors\n        )\n         if errors == \"ignore\":\n             from pandas import Index"}
{"id": "black_15", "problem": " class DebugVisitor(Visitor[T]):\n             out(f\" {node.value!r}\", fg=\"blue\", bold=False)\n     @classmethod\n    def show(cls, code: str) -> None:\n         v: DebugVisitor[None] = DebugVisitor()\n        list(v.visit(lib2to3_parse(code)))\n KEYWORDS = set(keyword.kwlist)", "fixed": " class DebugVisitor(Visitor[T]):\n             out(f\" {node.value!r}\", fg=\"blue\", bold=False)\n     @classmethod\n    def show(cls, code: Union[str, Leaf, Node]) -> None:\n         v: DebugVisitor[None] = DebugVisitor()\n        if isinstance(code, str):\n            code = lib2to3_parse(code)\n        list(v.visit(code))\n KEYWORDS = set(keyword.kwlist)"}
{"id": "pandas_59", "problem": " class _Rolling_and_Expanding(_Rolling):\n             pairwise = True if pairwise is None else pairwise\n         other = self._shallow_copy(other)\n        window = self._get_window(other)\n         def _get_corr(a, b):\n             a = a.rolling(", "fixed": " class _Rolling_and_Expanding(_Rolling):\n             pairwise = True if pairwise is None else pairwise\n         other = self._shallow_copy(other)\n        window = self._get_window(other) if not self.is_freq_type else self.win_freq\n         def _get_corr(a, b):\n             a = a.rolling("}
{"id": "PySnooper_3", "problem": " def get_write_function(output):\n             stderr.write(s)\n     elif isinstance(output, (pycompat.PathLike, str)):\n         def write(s):\n            with open(output_path, 'a') as output_file:\n                 output_file.write(s)\n     else:\n         assert isinstance(output, utils.WritableStream)", "fixed": " def get_write_function(output):\n             stderr.write(s)\n     elif isinstance(output, (pycompat.PathLike, str)):\n         def write(s):\n            with open(output, 'a') as output_file:\n                 output_file.write(s)\n     else:\n         assert isinstance(output, utils.WritableStream)"}
{"id": "keras_2", "problem": " def l2_normalize(x, axis=-1):\n     return x / np.sqrt(y)\n def binary_crossentropy(target, output, from_logits=False):\n     if not from_logits:\n         output = np.clip(output, 1e-7, 1 - 1e-7)", "fixed": " def l2_normalize(x, axis=-1):\n     return x / np.sqrt(y)\ndef in_top_k(predictions, targets, k):\n    top_k = np.argsort(-predictions)[:, :k]\n    targets = targets.reshape(-1, 1)\n    return np.any(targets == top_k, axis=-1)\n def binary_crossentropy(target, output, from_logits=False):\n     if not from_logits:\n         output = np.clip(output, 1e-7, 1 - 1e-7)"}
{"id": "tornado_3", "problem": " class AsyncHTTPClient(Configurable):\n             return\n         self._closed = True\n         if self._instance_cache is not None:\n            if self._instance_cache.get(self.io_loop) is not self:\n                 raise RuntimeError(\"inconsistent AsyncHTTPClient cache\")\n            del self._instance_cache[self.io_loop]\n     def fetch(\n         self,", "fixed": " class AsyncHTTPClient(Configurable):\n             return\n         self._closed = True\n         if self._instance_cache is not None:\n            cached_val = self._instance_cache.pop(self.io_loop, None)\n            if cached_val is not None and cached_val is not self:\n                 raise RuntimeError(\"inconsistent AsyncHTTPClient cache\")\n     def fetch(\n         self,"}
{"id": "spacy_8", "problem": " class Errors(object):\n\"details: https:\n     E174 = (\"Architecture '{name}' not found in registry. Available \"\n             \"names: {names}\")\n @add_codes", "fixed": " class Errors(object):\n\"details: https:\n     E174 = (\"Architecture '{name}' not found in registry. Available \"\n             \"names: {names}\")\n    E175 = (\"Can't remove rule for unknown match pattern ID: {key}\")\n @add_codes"}
{"id": "keras_11", "problem": " from __future__ import print_function\n import warnings\n import numpy as np\n from .training_utils import iter_sequence_infinite\n from .. import backend as K\n from ..utils.data_utils import Sequence", "fixed": " from __future__ import print_function\n import warnings\n import numpy as np\nfrom .training_utils import is_sequence\n from .training_utils import iter_sequence_infinite\n from .. import backend as K\n from ..utils.data_utils import Sequence"}
{"id": "matplotlib_19", "problem": " class RadialLocator(mticker.Locator):\n         return self.base.refresh()\n     def view_limits(self, vmin, vmax):\n         vmin, vmax = self.base.view_limits(vmin, vmax)\n         if vmax > vmin:", "fixed": " class RadialLocator(mticker.Locator):\n         return self.base.refresh()\n    def nonsingular(self, vmin, vmax):\n        return ((0, 1) if (vmin, vmax) == (-np.inf, np.inf)\n                else self.base.nonsingular(vmin, vmax))\n     def view_limits(self, vmin, vmax):\n         vmin, vmax = self.base.view_limits(vmin, vmax)\n         if vmax > vmin:"}
{"id": "pandas_66", "problem": " class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):\n                 new_index = self.index[loc]\n         if is_scalar(loc):\n            new_values = self._data.fast_xs(loc)\n            if not is_list_like(new_values) or self.ndim == 1:\n                return com.maybe_box_datetimelike(new_values)\n             result = self._constructor_sliced(\n                 new_values,", "fixed": " class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):\n                 new_index = self.index[loc]\n         if is_scalar(loc):\n            if self.ndim == 1:\n                return self._values[loc]\n            new_values = self._data.fast_xs(loc)\n             result = self._constructor_sliced(\n                 new_values,"}
{"id": "pandas_151", "problem": " class PandasArray(ExtensionArray, ExtensionOpsMixin, NDArrayOperatorsMixin):\n         if not lib.is_scalar(value):\n             value = np.asarray(value)\n        values = self._ndarray\n        t = np.result_type(value, values)\n        if t != self._ndarray.dtype:\n            values = values.astype(t, casting=\"safe\")\n            values[key] = value\n            self._dtype = PandasDtype(t)\n            self._ndarray = values\n        else:\n            self._ndarray[key] = value\n     def __len__(self) -> int:\n         return len(self._ndarray)", "fixed": " class PandasArray(ExtensionArray, ExtensionOpsMixin, NDArrayOperatorsMixin):\n         if not lib.is_scalar(value):\n             value = np.asarray(value)\n        value = np.asarray(value, dtype=self._ndarray.dtype)\n        self._ndarray[key] = value\n     def __len__(self) -> int:\n         return len(self._ndarray)"}
{"id": "black_22", "problem": " class Line:\n             self.bracket_tracker.mark(leaf)\n             self.maybe_remove_trailing_comma(leaf)\n             self.maybe_increment_for_loop_variable(leaf)\n            if self.maybe_adapt_standalone_comment(leaf):\n                return\n         if not self.append_comment(leaf):\n             self.leaves.append(leaf)\n     @property\n     def is_comment(self) -> bool:", "fixed": " class Line:\n             self.bracket_tracker.mark(leaf)\n             self.maybe_remove_trailing_comma(leaf)\n             self.maybe_increment_for_loop_variable(leaf)\n         if not self.append_comment(leaf):\n             self.leaves.append(leaf)\n    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n        if self.bracket_tracker.depth == 0:\n            if self.is_comment:\n                raise ValueError(\"cannot append to standalone comments\")\n            if self.leaves and leaf.type == STANDALONE_COMMENT:\n                raise ValueError(\n                    \"cannot append standalone comments to a populated line\"\n                )\n        self.append(leaf, preformatted=preformatted)\n     @property\n     def is_comment(self) -> bool:"}
{"id": "pandas_73", "problem": " class DataFrame(NDFrame):\n    def _combine_frame(self, other, func, fill_value=None, level=None):\n         if fill_value is None:", "fixed": " class DataFrame(NDFrame):\n    def _combine_frame(self, other: \"DataFrame\", func, fill_value=None):\n         if fill_value is None:"}
{"id": "pandas_44", "problem": " import numpy as np\n from pandas._libs import NaT, Period, Timestamp, index as libindex, lib, tslib as libts\n from pandas._libs.tslibs import fields, parsing, timezones\nfrom pandas._typing import Label\n from pandas.util._decorators import cache_readonly\nfrom pandas.core.dtypes.common import _NS_DTYPE, is_float, is_integer, is_scalar\n from pandas.core.dtypes.missing import is_valid_nat_for_dtype\n from pandas.core.arrays.datetimes import DatetimeArray, tz_to_dtype", "fixed": " import numpy as np\n from pandas._libs import NaT, Period, Timestamp, index as libindex, lib, tslib as libts\n from pandas._libs.tslibs import fields, parsing, timezones\nfrom pandas._typing import DtypeObj, Label\n from pandas.util._decorators import cache_readonly\nfrom pandas.core.dtypes.common import (\n    _NS_DTYPE,\n    is_datetime64_any_dtype,\n    is_datetime64_dtype,\n    is_datetime64tz_dtype,\n    is_float,\n    is_integer,\n    is_scalar,\n)\n from pandas.core.dtypes.missing import is_valid_nat_for_dtype\n from pandas.core.arrays.datetimes import DatetimeArray, tz_to_dtype"}
{"id": "pandas_41", "problem": " class IntBlock(NumericBlock):\n             )\n         return is_integer(element)\n    def should_store(self, value) -> bool:\n         return is_integer_dtype(value) and value.dtype == self.dtype", "fixed": " class IntBlock(NumericBlock):\n             )\n         return is_integer(element)\n    def should_store(self, value: ArrayLike) -> bool:\n         return is_integer_dtype(value) and value.dtype == self.dtype"}
