{"project": "Lang", "bugId": 62, "problem": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "fixed": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                            if (entityValue > 0xFFFF) {\n                                entityValue = -1;\n                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "observations": "Added a \"break\" in \"case\" branch.", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Lang", "bugId": 55, "problem": " public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n             stopTime = System.currentTimeMillis();\n         this.runningState = STATE_STOPPED;\n     }", "fixed": " public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n        }\n         this.runningState = STATE_STOPPED;\n     }", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i];\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Math", "bugId": 57, "problem": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "fixed": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "observations": "Just changed the declared type of a primitive variable.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Time", "bugId": 3, "problem": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n     }", "fixed": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 9, "problem": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 24, "problem": " public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                return foundDigit && !hasExp;\n             }\n             return false;", "fixed": " public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             return false;", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return isZero ? NaN : INF;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "fixed": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return NaN;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Mockito", "bugId": 9, "problem": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "fixed": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n    \t}\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 83, "problem": " private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n        int start = getNumObjectiveFunctions();\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;", "fixed": " private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Chart", "bugId": 12, "problem": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        this.dataset = dataset;\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "fixed": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        setDataset(dataset);\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "observations": "It involves a \"wrap with method\", but the real change is converting from a class attribute assignment to a \"set\" method call.", "repairActions": ["assignRem", "mcAdd", "varReplMc"], "repairPatterns": ["singleLine", "wrapsMethod", "wrongVarRef"]}
{"project": "Mockito", "bugId": 14, "problem": " public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n        mockingProgress.verificationStarted(mode);\r\n         return mock;\r\n     }\r", "fixed": " public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\r\n         return mock;\r\n     }\r", "observations": "An existing parameter (\"mode\") was wrapped by a constructor call, instantiating MockAwareVerificationMode object", "repairActions": ["condBranIfAdd", "mcAdd", "mcParValChange", "objInstAdd"], "repairPatterns": ["wrapsIf", "wrapsMethod"]}
{"project": "Mockito", "bugId": 23, "problem": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "fixed": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n\t\t        .serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Mockito", "bugId": 13, "problem": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n             }\r\n         }\r", "fixed": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n            } else {\r\n                mockingProgress.verificationStarted(verificationMode);\r\n             }\r\n         }\r", "observations": "", "repairActions": ["condBranElseAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {", "fixed": " private void findAliases(NodeTraversal t) {\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 89, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n             addValue((Comparable<?>) v);            \n     }\n     /**", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n        } else {\n            throw new IllegalArgumentException(\"Object must implement Comparable\");\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Closure", "bugId": 68, "problem": " private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n     return reportGenericTypeSyntaxWarning();\n   }", "fixed": " private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }", "observations": "An assignment was moved outside a branch.", "repairActions": ["mcAdd"], "repairPatterns": ["codeMove", "copyPaste", "missComp", "unwrapIfElse"]}
{"project": "Math", "bugId": 90, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n     /**\n      * Adds 1 to the frequency count for v.", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        addValue((Comparable<?>) v);\n    }\n     /**\n      * Adds 1 to the frequency count for v.", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }", "fixed": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                     fu = -fu;\n                 }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Mockito", "bugId": 18, "problem": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "fixed": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "observations": "Returns instantiated ArrayList<Object>", "repairActions": ["condBranIfAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 10, "problem": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "fixed": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 66, "problem": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "fixed": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Mockito", "bugId": 23, "problem": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return mock;\r\n     }\r\n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\r", "fixed": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return mock;\r\n     }\r\n\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\r\n\t}\r\n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 123, "problem": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "fixed": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "observations": "Changes value in assignment from constant to method call.", "repairActions": ["assignExpChange", "mcAdd", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 10, "problem": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "fixed": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "observations": "", "repairActions": ["assignRem", "condBranIfAdd", "mcRem", "varRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Mockito", "bugId": 15, "problem": " public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r", "fixed": " public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n                        }\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r", "observations": "Instantiated a BeanPropertySetter object", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 3, "problem": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "fixed": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 101, "problem": " public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n        if (\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {", "fixed": " public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 79, "problem": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "fixed": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["notClassified"]}
{"project": "Chart", "bugId": 18, "problem": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n        if (index < this.keys.size()) {\n         rebuildIndex();\n        }\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n\t\t\treturn;\n         }\n         removeValue(index);\n     }\n     ", "fixed": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n         rebuildIndex();\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n            throw new UnknownKeyException(\"The key (\" + key \n                    + \") is not recognised.\");\n         }\n         removeValue(index);\n     }\n     ", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Math", "bugId": 81, "problem": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "fixed": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 3) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Closure", "bugId": 30, "problem": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n   @Override", "fixed": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n   @Override", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 86, "problem": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "fixed": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "observations": "The condition to throw the exception is moved from one place to another.", "repairActions": ["condBranIfAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "objInstAdd", "objInstRem"], "repairPatterns": ["codeMove"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n         }\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "fixed": "else if (lclip <= 0.0) {\n         }\r\n        Number n = dataset.getStdDevValue(row, column);\r\n        if (n != null) {\r\n            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 61, "problem": " public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));", "fixed": " public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));", "observations": "Replaces Exception Thrown. Changed the type of exception thrown. Changed the imported type.", "repairActions": ["mcRem", "objInstAdd"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Math", "bugId": 22, "problem": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return false;\n     }\n     /**", "fixed": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return true;\n     }\n     /**", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Mockito", "bugId": 6, "problem": " public static long anyLong() {\n      * @return <code>0</code>.\r\n      */\r\n     public static float anyFloat() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static long anyLong() {\n      * @return <code>0</code>.\r\n      */\r\n     public static float anyFloat() {\r\n        return reportMatcher(new InstanceOf(Float.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 57, "problem": " public static Set availableLocaleSet() {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n     }", "fixed": " public static Set availableLocaleSet() {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n     }", "observations": "Changes direct acces of an object to method call.", "repairActions": ["mcAdd", "retExpChange", "varReplMc"], "repairPatterns": ["singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 106, "problem": " boolean canCollapseUnannotatedChildNames() {\n       if (isClassOrEnum) {\n         return true;", "fixed": " boolean canCollapseUnannotatedChildNames() {\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n       if (isClassOrEnum) {\n         return true;", "observations": "", "repairActions": ["condBranIfAdd", "condBranRem", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "unwrapIfElse"]}
{"project": "Closure", "bugId": 24, "problem": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n        }\n       }\n     }", "fixed": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n        } else if (parent.getType() == Token.LP) {\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n       }\n     }", "observations": "Again, a kind of Wrap-with-IfElse where some conditionals were missing.", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Mockito", "bugId": 19, "problem": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "fixed": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Time", "bugId": 23, "problem": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "fixed": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "observations": "Changes entries in a key-value map.", "repairActions": ["mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Mockito", "bugId": 23, "problem": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "fixed": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n    private synchronized void instantiateMockitoCoreIfNeeded() {\r\n        if (mockitoCore == null) {\r\n            mockitoCore = new MockitoCore();\r\n        }\r\n    }\r\n    private synchronized void instantiateDelegateIfNeeded() {\r\n        if (delegate == null) {\r\n            delegate = new ReturnsEmptyValues();\r\n        }\r\n    }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Closure", "bugId": 54, "problem": " public void setPrototypeBasedOn(ObjectType baseType) {\n     if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {", "fixed": " public void setPrototypeBasedOn(ObjectType baseType) {\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 76, "problem": " private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {", "fixed": " private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\nif (ControlFlowGraph.isEnteringNewCfgNode(n)) {\n      return VariableLiveness.MAYBE_LIVE;\n    }\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 5, "problem": " public Complex reciprocal() {\n         }\n         if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n         }\n         if (isInfinite) {", "fixed": " public Complex reciprocal() {\n         }\n         if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n         }\n         if (isInfinite) {", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange", "expArithMod", "singleLine"]}
{"project": "Math", "bugId": 29, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n         }\n         return res;\n     }", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n        final int n = getDimension();\n        for (int i = 0; i < n; i++) {\n            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n         }\n         return res;\n     }", "observations": "Changed a while loop to a for lor loop.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrongComp"]}
{"project": "Math", "bugId": 94, "problem": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Mockito", "bugId": 20, "problem": " public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));", "fixed": " public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n         T mockInstance = null;\n         try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));", "observations": "Instantiates an InstantiatonProvider object", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRepl", "objInstAdd", "varAdd", "varReplVar"], "repairPatterns": ["wrongVarRef"]}
{"project": "Closure", "bugId": 2, "problem": " private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {", "fixed": " private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd"], "repairPatterns": ["missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 93, "problem": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "fixed": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Closure", "bugId": 97, "problem": " private Node tryFoldShift(Node n, Node left, Node right) {\n          result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +", "fixed": " private Node tryFoldShift(Node n, Node left, Node right) {\n          long lvalLong = lvalInt & 0xffffffffL;\n          result = lvalLong >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "varAdd"], "repairPatterns": ["expArithMod", "missComp", "singleLine"]}
{"project": "Lang", "bugId": 26, "problem": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "fixed": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "observations": "Adds a new parameter to constructor call (call overloaded constructor)", "repairActions": ["objInstMod"], "repairPatterns": ["initFix", "singleLine", "wrongMethodRef"]}
{"project": "Closure", "bugId": 41, "problem": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "fixed": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Closure", "bugId": 103, "problem": " private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n         return true;\n       case Token.FUNCTION:\n         return false;", "fixed": " private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n      case Token.INSTANCEOF:\n         return true;\n       case Token.FUNCTION:\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN", "missNullCheckP"]}
{"project": "Closure", "bugId": 9, "problem": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "fixed": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n    filename = filename.replace(\"\\\\\", \"/\");\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Math", "bugId": 39, "problem": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n         for (int k = 1; k < stages; ++k) {", "fixed": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n         for (int k = 1; k < stages; ++k) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 41, "problem": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }", "fixed": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }", "observations": "The changes were made only inside the for loop.", "repairActions": ["assignExpChange", "loopCondChange", "loopInitChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 104, "problem": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "fixed": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "observations": "A Null-Check was removed and replaced by another condition.", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 124, "problem": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n       node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "fixed": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n    while (node.isGetProp()) {\n       node = node.getFirstChild();\n    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "observations": "", "repairActions": ["loopAdd", "mcAdd"], "repairPatterns": ["missComp", "wrapsLoop"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {", "fixed": " private void findAliases(NodeTraversal t) {\n          if (isFunctionDecl) {\n            Node existingName = v.getNameNode();", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;", "fixed": " public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Math", "bugId": 52, "problem": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  if (c == 0) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "fixed": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "observations": "New variable is added with its initialization.", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 62, "problem": " public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         for (int i = 0; i < starts; ++i) {\n             try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {", "fixed": " public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         for (int i = 0; i < starts; ++i) {\n             try {\n                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, min, max, s);\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {", "observations": "Changes the way to compute \"optima[i]\", changing params for call to \"optimize\". Removed if-branch is in the form \"exp?a:b\".", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcAdd", "mcParAdd", "mcParValChange", "mcRem", "mcRepl", "retExpChange", "varAdd", "varRem"], "repairPatterns": ["expArithMod", "wrongComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 84, "problem": " public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n         while (true) {\n             incrementIterationsCounter();", "fixed": " public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n             incrementIterationsCounter();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 78, "problem": " private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;", "fixed": " private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n           return null;\n         }\n         result = lval / rval;", "observations": "Removes error invocation call.", "repairActions": ["mcRem"], "repairPatterns": ["copyPaste"]}
{"project": "Closure", "bugId": 14, "problem": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "fixed": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "observations": "Parameter value change.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["constChange", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 12, "problem": " ReachingUses flowThrough(Node n, ReachingUses input) {\n   }\n   private boolean hasExceptionHandler(Node cfgNode) {\n     return false;\n   }", "fixed": " ReachingUses flowThrough(Node n, ReachingUses input) {\n   }\n   private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n     return false;\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isInlinableObject(List<Reference> refs) {\n           continue;\n         }", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n           continue;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static float anyFloat() {\n      * @return <code>0</code>.\r\n      */\r\n     public static double anyDouble() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static float anyFloat() {\n      * @return <code>0</code>.\r\n      */\r\n     public static double anyDouble() {\r\n        return reportMatcher(new InstanceOf(Double.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 18, "problem": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                     rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\ncase 'M':", "fixed": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen == 2) {\n                     rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                 }\n                 break;\ncase 'M':", "observations": "An existent if-else structure is removed and a new one is placed in an action that resembles a wrap-with replacement. An aditional wrap-with-IfElse is present in IfElse-CondExp form.", "repairActions": ["condBranIfElseAdd", "condExpMod", "mcParValChange"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Lang", "bugId": 4, "problem": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "fixed": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<String, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Lang", "bugId": 16, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Chart", "bugId": 19, "problem": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "fixed": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "copyPaste", "missNullCheckP"]}
{"project": "Lang", "bugId": 35, "problem": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            return (T[]) new Object[] { null };\n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "fixed": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "observations": "Changes return of a null object to throw an Exception. The only statement of an existent \"else block\" is replaced by an exception throw.", "repairActions": ["assignRem", "exThrowsAdd", "objInstAdd", "retRem"], "repairPatterns": ["notClassified"]}
{"project": "Math", "bugId": 48, "problem": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                     break;\n                 default:", "fixed": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                     break;\n                 default:", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Math", "bugId": 16, "problem": "  */\n public class FastMath {\n     \n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "fixed": "  */\n public class FastMath {\n     \n    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Closure", "bugId": 72, "problem": " private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n      if (li.referenced) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {", "fixed": " private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n      if (li.referenced || !removeUnused) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {", "observations": "Instantiates an anonymous object and make a method call on it.", "repairActions": ["condExpExpand", "mcAdd", "objInstAdd"], "repairPatterns": ["expLogicExpand", "missComp"]}
{"project": "Closure", "bugId": 13, "problem": " private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n        traverse(c);\n         Node next = c.getNext();\n         c = next;\n       }", "fixed": " private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         Node next = c.getNext();\n        traverse(c);\n         c = next;\n       }", "observations": "Only one line of code was moved.", "repairActions": ["mcMove"], "repairPatterns": ["codeMove", "singleLine"]}
{"project": "Closure", "bugId": 111, "problem": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType;\n         }\n         @Override", "fixed": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n         }\n         @Override", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Math", "bugId": 66, "problem": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "fixed": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 6, "problem": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(Any.ANY).returnFalse();\r\n     }\r\n     /**\r", "fixed": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 77, "problem": " public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from", "fixed": " public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from", "observations": "Fix a assignment. Removes a method (aparently, unrelated changes).", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcRem", "mdOverride", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Math", "bugId": 81, "problem": " private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             work[i + 2]  = -sigma;", "fixed": " private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             work[i + 2]  = -sigma;", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Chart", "bugId": 18, "problem": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n                 rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "fixed": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n    \tif (columnKey == null) {\r\n    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\r\n    \t}\r\n    \tif (!this.columnKeys.contains(columnKey)) {\r\n    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\r\n    \t}\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n            int index = rowData.getIndex(columnKey);\r\n            if (index >= 0) {\r\n                 rowData.removeValue(columnKey);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Time", "bugId": 3, "problem": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n     }", "fixed": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 56, "problem": " public String getLine(int lineNumber) {\n         return null;\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }", "fixed": " public String getLine(int lineNumber) {\n      if (pos >= js.length()) {\n         return null;\n      } else {\n        return js.substring(pos, js.length());\n      }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 93, "problem": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "fixed": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Closure", "bugId": 129, "problem": " private void annotateCalls(Node n) {\n       Node first = n.getFirstChild();\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);", "fixed": " private void annotateCalls(Node n) {\n       Node first = n.getFirstChild();\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);", "observations": "Adds a loop to iterate over child of nodes.", "repairActions": ["assignAdd", "loopAdd", "mcAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Math", "bugId": 105, "problem": " public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n     }\n     /**", "fixed": " public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n     }\n     /**", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsMethod"]}
{"project": "Lang", "bugId": 47, "problem": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 21, "problem": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withOuterClass(cls);\n     }\n    private <T> T withOuterClass(Class<T> cls) {\n         try {\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "fixed": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withParams(cls, outerClassInstance);\n     }\n    private static <T> T withParams(Class<T> cls, Object... params) {\n         try {\n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return (T) constructor.newInstance(params);\n                }\n            }\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n        throw paramsException(cls, null);\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "observations": "Apply \"static\" modifier to withParams method", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "mcRepl", "mdAdd", "mdModChange", "mdParAdd", "mdRen", "retBranchAdd", "retExpChange", "retRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "wrongComp"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
