{"project": "Mockito", "bugId": 19, "problem": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "fixed": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                 return current;\n             }", "fixed": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n            \tupdateResidualsAndCost();\n            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 4, "problem": " public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));", "fixed": " public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Lang", "bugId": 31, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n \t\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t}", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n \t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}", "observations": "Partially the same as Lang 30", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp", "wrapsIfElse"]}
{"project": "Lang", "bugId": 44, "problem": " public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n         if (val.startsWith(\"--\")) {", "fixed": " public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n         if (val.startsWith(\"--\")) {", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Closure", "bugId": 133, "problem": " private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n     return result;\n   }", "fixed": " private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n     return result;\n   }", "observations": "It seems that the variable is reseted by method.", "repairActions": ["assignAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Closure", "bugId": 110, "problem": " public Node getChildBefore(Node child) {\n       return null;\n     }\n     Node n = first;\n     while (n.next != child) {\n       n = n.next;", "fixed": " public Node getChildBefore(Node child) {\n       return null;\n     }\n     Node n = first;\n    if (n == null) {\n      throw new RuntimeException(\"node is not a child\");\n    }\n     while (n.next != child) {\n       n = n.next;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 90, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n     /**\n      * Adds 1 to the frequency count for v.", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        addValue((Comparable<?>) v);\n    }\n     /**\n      * Adds 1 to the frequency count for v.", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 6, "problem": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, Node owner, String propName) {\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {", "fixed": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, Node owner, String propName) {\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {", "observations": "", "repairActions": ["condBranRem", "mcRem"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n         int searchLen = searchChars.length;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                         return i;\n                 }\n             }\n         }", "fixed": " public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                         return i;\n                    }\n                 }\n             }\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Math", "bugId": 70, "problem": " public double solve(double min, double max)\n     \n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n     }\n     ", "fixed": " public double solve(double min, double max)\n     \n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n     }\n     ", "observations": "Call overloaded method without one parameter.", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 16, "problem": " public static double cosh(double x) {\n       if (x > 20) {\n               return 0.5 * exp(x);\n           }\n      if (x < -20) {\n               return 0.5 * exp(-x);\n       }\n       final double hiPrec[] = new double[2];", "fixed": " public static double cosh(double x) {\n       if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n               return 0.5 * exp(x);\n           }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              final double t = exp(-0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n               return 0.5 * exp(-x);\n          }\n       }\n       final double hiPrec[] = new double[2];", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Lang", "bugId": 20, "problem": " public static String join(Object[] array, char separator, int startIndex, int en\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "fixed": " public static String join(Object[] array, char separator, int startIndex, int en\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "observations": "Null-Check is removed from \"buf\" initialization.", "repairActions": ["assignExpChange", "condBranRem", "mcRem", "objInstMod"], "repairPatterns": ["condBlockRem", "copyPaste", "initFix"]}
{"project": "Mockito", "bugId": 6, "problem": " public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n        return reportMatcher(new InstanceOf(Long.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 75, "problem": " static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\ncase '\\u000B':\n        return TernaryValue.TRUE;\ncase ' ':\ncase '\\n':\ncase '\\r':", "fixed": " static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\ncase '\\u000B':\nreturn TernaryValue.UNKNOWN;\ncase ' ':\ncase '\\n':\ncase '\\r':", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd", "retExpChange", "varReplVar"], "repairPatterns": ["condBlockRetAdd", "constChange", "wrongVarRef"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n     return next;\n   }", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n    while (next != null && next.getType() == Token.BLOCK) {\n      if (next.hasChildren()) {\n        next = next.getFirstChild();\n      } else {\n        next = computeFollowing(next);\n      }\n    }\n     return next;\n   }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Math", "bugId": 98, "problem": " public double getTrace() throws IllegalArgumentException {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n        final double[] out = new double[v.length];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;", "fixed": " public double getTrace() throws IllegalArgumentException {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;", "observations": "Changes dimension of two vectors.", "repairActions": ["varReplVar"], "repairPatterns": ["copyPaste", "initFix", "wrongVarRef"]}
{"project": "Lang", "bugId": 47, "problem": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 107, "problem": " protected CompilerOptions createOptions() {\n       options.messageBundle = new EmptyMessageBundle();\n     }\n     return options;", "fixed": " protected CompilerOptions createOptions() {\n       options.messageBundle = new EmptyMessageBundle();\n      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n     }\n     return options;", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Time", "bugId": 20, "problem": " public int estimateParsedLength() {\n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                 }\n             }\n             return ~position;\n         }\n     }", "fixed": " public int estimateParsedLength() {\n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n            String best = null;\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                 }\n             }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n             return ~position;\n         }\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missNullCheckN", "missNullCheckP"]}
{"project": "Mockito", "bugId": 20, "problem": " public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));", "fixed": " public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n         T mockInstance = null;\n         try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));", "observations": "Instantiates an InstantiatonProvider object", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRepl", "objInstAdd", "varAdd", "varReplVar"], "repairPatterns": ["wrongVarRef"]}
{"project": "Math", "bugId": 94, "problem": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 49, "problem": " public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));", "fixed": " public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Chart", "bugId": 15, "problem": " public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r", "fixed": " public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n        if (this.dataset == null) {\r\n            return 0.0;\r\n        }\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "missNullCheckP", "wrapsIf"]}
{"project": "Lang", "bugId": 32, "problem": " public static int reflectionHashCode(Object object, String[] excludeFields) {\n      *            The object to register.\n      */\n     static void register(Object value) {\n         getRegistry().add(new IDKey(value));\n     }", "fixed": " public static int reflectionHashCode(Object object, String[] excludeFields) {\n      *            The object to register.\n      */\n     static void register(Object value) {\n        synchronized (HashCodeBuilder.class) {\n            if (getRegistry() == null) {\n                REGISTRY.set(new HashSet<IDKey>());\n            }\n        }\n         getRegistry().add(new IDKey(value));\n     }", "observations": "Applies null check using synchronized block with object lock (HashCodeBuilder.class)", "repairActions": ["condBranIfAdd", "mcAdd", "mdOverride", "mdRem", "objInstMod", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP"]}
{"project": "Lang", "bugId": 41, "problem": " public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n        return out;\n     }", "fixed": " public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n        return out + arrayPrefix;\n     }", "observations": "Existent condittional expression with null-check is expanded.", "repairActions": ["assignAdd", "condBranIfAdd", "condExpExpand", "loopAdd", "mcAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                 }", "fixed": " protected VectorialPointValuePair doOptimize()\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                 }", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 21, "problem": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withOuterClass(cls);\n     }\n    private <T> T withOuterClass(Class<T> cls) {\n         try {\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "fixed": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withParams(cls, outerClassInstance);\n     }\n    private static <T> T withParams(Class<T> cls, Object... params) {\n         try {\n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return (T) constructor.newInstance(params);\n                }\n            }\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n        throw paramsException(cls, null);\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "observations": "Apply \"static\" modifier to withParams method", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "mcRepl", "mdAdd", "mdModChange", "mdParAdd", "mdRen", "retBranchAdd", "retExpChange", "retRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "wrongComp"]}
{"project": "Math", "bugId": 67, "problem": " public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n     \n     public double getFunctionValue() {\n        return optimizer.getFunctionValue();\n     }\n     \n     public double getResult() {\n        return optimizer.getResult();\n     }\n     ", "fixed": " public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n     \n     public double getFunctionValue() {\n        return optimaValues[0];\n     }\n     \n     public double getResult() {\n        return optima[0];\n     }\n     ", "observations": "A direct access to a vector was added in place of a value returned from a call to an object method. The change was similar in structure in two different places.", "repairActions": ["mcRem", "retExpChange"], "repairPatterns": ["wrongMethodRef"]}
{"project": "Mockito", "bugId": 15, "problem": " public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r", "fixed": " public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n                        }\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r", "observations": "Instantiated a BeanPropertySetter object", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 81, "problem": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "fixed": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 3) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Math", "bugId": 75, "problem": " public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n     }\n     /**", "fixed": " public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n        return getPct((Comparable<?>) v);\n     }\n     /**", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Closure", "bugId": 30, "problem": "   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n     Definition(Node node) {\n       this.node = node;", "fixed": "   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n    private boolean unknownDependencies = false;\n     Definition(Node node) {\n       this.node = node;", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 36, "problem": " public int getArgumentsCount() {\n     }\n     public Object callRealMethod() throws Throwable {\n         return realMethod.invoke(mock, rawArguments);\n     }", "fixed": " public int getArgumentsCount() {\n     }\n     public Object callRealMethod() throws Throwable {\n        if (this.getMethod().getDeclaringClass().isInterface()) {\n            new Reporter().cannotCallRealMethodOnInterface();\n        }\n         return realMethod.invoke(mock, rawArguments);\n     }", "observations": "Instantiates an Reporter object", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 30, "problem": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final int n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "fixed": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final double n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Time", "bugId": 3, "problem": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n     }", "fixed": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 35, "problem": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n        return reportMatcher(new Same(value)).<T>returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());\r\n     }\r\n     /**\r", "observations": "", "repairActions": ["mcAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n             setMillis(getChronology().years().add(getMillis(), years));\n     }", "fixed": " public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n        if (years != 0) {\n             setMillis(getChronology().years().add(getMillis(), years));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Lang", "bugId": 18, "problem": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                     rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\ncase 'M':", "fixed": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen == 2) {\n                     rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                 }\n                 break;\ncase 'M':", "observations": "An existent if-else structure is removed and a new one is placed in an action that resembles a wrap-with replacement. An aditional wrap-with-IfElse is present in IfElse-CondExp form.", "repairActions": ["condBranIfElseAdd", "condExpMod", "mcParValChange"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 1, "problem": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +", "fixed": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                if (loopUnitField.isSupported() == false) {\n                    if (lastUnitField.isSupported()) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                        types[i - 1].getName() + \" < \" + loopType.getName());\n                    } else {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +", "observations": "", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "exThrowsAdd", "mcAdd", "objInstAdd", "retRem"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRem", "expLogicExpand"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Chart", "bugId": 20, "problem": " public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        super(paint, stroke, paint, stroke, alpha);\r\n         this.value = value;\r\n     }\r", "fixed": " public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\r\n         this.value = value;\r\n     }\r", "observations": "Replaces params value passed to constructor.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Lang", "bugId": 46, "problem": " public static void escapeJavaScript(Writer out, String str) throws IOException {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n             return writer.toString();\n         } catch (IOException ioe) {", "fixed": " public static void escapeJavaScript(Writer out, String str) throws IOException {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n             return writer.toString();\n         } catch (IOException ioe) {", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i];\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Math", "bugId": 5, "problem": " public Complex reciprocal() {\n         }\n         if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n         }\n         if (isInfinite) {", "fixed": " public Complex reciprocal() {\n         }\n         if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n         }\n         if (isInfinite) {", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange", "expArithMod", "singleLine"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {", "fixed": " private void findAliases(NodeTraversal t) {\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Closure", "bugId": 116, "problem": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }", "observations": "Strange... what is removed in 115 is added again in 116.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Mockito", "bugId": 11, "problem": " public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n             return method.equals(o);\n     }\n     @Override\n     public int hashCode() {\n        return 1;\n     }\n }\n\\ No newline at end of file", "fixed": " public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o instanceof DelegatingMethod) {\n            DelegatingMethod that = (DelegatingMethod) o;\n            return method.equals(that.method);\n        } else {\n             return method.equals(o);\n        }\n     }\n     @Override\n     public int hashCode() {\n        return method.hashCode();\n     }\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIfElse"]}
{"project": "Chart", "bugId": 18, "problem": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n        if (index < this.keys.size()) {\n         rebuildIndex();\n        }\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n\t\t\treturn;\n         }\n         removeValue(index);\n     }\n     ", "fixed": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n         rebuildIndex();\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n            throw new UnknownKeyException(\"The key (\" + key \n                    + \") is not recognised.\");\n         }\n         removeValue(index);\n     }\n     ", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Mockito", "bugId": 6, "problem": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(Any.ANY).returnFalse();\r\n     }\r\n     /**\r", "fixed": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Closure", "bugId": 60, "problem": " static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n       case Token.VOID:\n           return TernaryValue.FALSE;\n       case Token.NAME:\n         String name = n.getString();", "fixed": " static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n       case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n           return TernaryValue.FALSE;\n        }\n        break;\n       case Token.NAME:\n         String name = n.getString();", "observations": "", "repairActions": ["condBranCaseAdd", "condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIf"]}
{"project": "Closure", "bugId": 105, "problem": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n    if (sb.length() > 0) {\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));", "fixed": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n    if (sb != null) {\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));", "observations": "Moves the instantiation of StringBuilder to another place.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "condExpMod", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "expLogicMod", "initFix"]}
{"project": "Time", "bugId": 14, "problem": " public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {", "fixed": " public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Lang", "bugId": 38, "problem": " public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }", "fixed": " public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\ncalendar.getTime();\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Closure", "bugId": 97, "problem": " private Node tryFoldShift(Node n, Node left, Node right) {\n          result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +", "fixed": " private Node tryFoldShift(Node n, Node left, Node right) {\n          long lvalLong = lvalInt & 0xffffffffL;\n          result = lvalLong >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "varAdd"], "repairPatterns": ["expArithMod", "missComp", "singleLine"]}
{"project": "Closure", "bugId": 58, "problem": " private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             lhs = lhs.getLastChild();\n           }\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;", "fixed": " private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             lhs = lhs.getLastChild();\n           }\n          if (NodeUtil.isName(lhs)) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n          } else {\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 77, "problem": " public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n         }\n         return max;\n     }", "fixed": " public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }", "observations": "Fix a assignment. Removes a method (aparently, unrelated changes).", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcRem", "mdOverride", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Lang", "bugId": 50, "problem": " public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti\n             key = new Pair(key, timeZone);\n         }\n        if (locale != null) {\n            key = new Pair(key, locale);\n         }\n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();", "fixed": " public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti\n             key = new Pair(key, timeZone);\n         }\n        if (locale == null) {\n            locale = Locale.getDefault();\n         }\n        key = new Pair(key, locale);\n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();", "observations": "Replaces some existent Null-Chek, inverting postive by negative.", "repairActions": ["assignAdd", "assignRem", "condBranRem", "condExpMod", "mcAdd", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockRem", "copyPaste", "expLogicMod", "unwrapIfElse", "wrongComp"]}
{"project": "Math", "bugId": 3, "problem": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "fixed": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Lang", "bugId": 36, "problem": " public static boolean isNumber(String str) {\n                 return false;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'", "fixed": " public static boolean isNumber(String str) {\n                 return false;\n             }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    return false;\n                }\n                return foundDigit;\n            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand"]}
{"project": "Math", "bugId": 52, "problem": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  if (c == 0) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "fixed": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "observations": "New variable is added with its initialization.", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 15, "problem": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n     \n     private static final double F_1_3 = 1d / 3d;", "fixed": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n     \n     private static final double F_1_3 = 1d / 3d;", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Chart", "bugId": 21, "problem": " public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r", "fixed": " public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n        else {\r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Time", "bugId": 16, "problem": " public int parseInto(ReadWritableInstant instant, String text, int position) {\n         chrono = selectChronology(chrono);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {", "fixed": " public int parseInto(ReadWritableInstant instant, String text, int position) {\n         chrono = selectChronology(chrono);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {", "observations": "Changes parameter for constructor call.", "repairActions": ["mcAdd", "mcParValChange", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n                     }\n                 }\n} else {\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                 return x;\n             }\n            ++count;\n         }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }", "fixed": " private double localMin(boolean isMinim,\n                     }\n                 }\n} else {\n                setFunctionValue(isMinim ? fx : -fx);\n                 return x;\n             }\n            incrementIterationsCounter();\n         }\n     }\n }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 106, "problem": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         int startIndex = pos.getIndex();\r", "fixed": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n        if (num.intValue() < 0) {\r\n            pos.setIndex(initialIndex);\r\n            return null;\r\n        }\r\n         int startIndex = pos.getIndex();\r", "observations": "Only one variable is different between the two blocks of code in patch.", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste"]}
{"project": "Closure", "bugId": 33, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n    if (hasReferenceName()) {\n      return;\n    }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Lang", "bugId": 65, "problem": " private static void modify(Calendar val, int field, boolean round) {\n                 roundUp = offset > ((max - min) / 2);\n             }\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");", "fixed": " private static void modify(Calendar val, int field, boolean round) {\n                 roundUp = offset > ((max - min) / 2);\n             }\n            if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "wrapsIf"]}
{"project": "Lang", "bugId": 46, "problem": " public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n        return escapeJavaStyleString(str, true);\n     }\n     /**", "fixed": " public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n        return escapeJavaStyleString(str, true, true);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 20, "problem": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "fixed": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckP", "singleLine"]}
{"project": "Lang", "bugId": 29, "problem": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static float toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "fixed": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static int toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "observations": "Changes return type of method.", "repairActions": ["mdRetTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Chart", "bugId": 13, "problem": " protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n         h[3] = h[2];\r\n         if (this.rightBlock != null) {\r\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                     LengthConstraintType.RANGE, h[2], null,\r\n                     LengthConstraintType.FIXED);\r\n             Size2D size = this.rightBlock.arrange(g2, c4);\r", "fixed": " protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n         h[3] = h[2];\r\n         if (this.rightBlock != null) {\r\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\r\n                     LengthConstraintType.RANGE, h[2], null,\r\n                     LengthConstraintType.FIXED);\r\n             Size2D size = this.rightBlock.arrange(g2, c4);\r", "observations": "", "repairActions": ["assignExpChange", "mcAdd", "mcParAdd", "mcParValChange", "mcRepl", "objInstMod"], "repairPatterns": ["initFix", "missComp", "singleLine", "wrapsMethod", "wrongMethodRef"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Time", "bugId": 24, "problem": " public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');", "fixed": " public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Chart", "bugId": 5, "problem": " public XYDataItem addOrUpdate(Number x, Number y) {\n         if (x == null) {\r\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n         }\r\n         XYDataItem overwritten = null;\r\n         int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n             XYDataItem existing = (XYDataItem) this.data.get(index);\r\n             try {\r\n                 overwritten = (XYDataItem) existing.clone();\r", "fixed": " public XYDataItem addOrUpdate(Number x, Number y) {\n         if (x == null) {\r\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n         }\r\n        if (this.allowDuplicateXValues) {\r\n            add(x, y);\r\n            return null;\r\n        }\r\n         XYDataItem overwritten = null;\r\n         int index = indexOf(x);\r\n        if (index >= 0) {\r\n             XYDataItem existing = (XYDataItem) this.data.get(index);\r\n             try {\r\n                 overwritten = (XYDataItem) existing.clone();\r", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce"]}
{"project": "Closure", "bugId": 64, "problem": " public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n    return toSource(n, null);\n   }\n   \n  private String toSource(Node n, SourceMap sourceMap) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);", "fixed": " public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n   }\n   \n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);", "observations": "New parameters are added in three method calls (call to overloaded methods). A logic expression passed to a method call is changed.", "repairActions": ["mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "fixed": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Closure", "bugId": 41, "problem": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "fixed": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Math", "bugId": 48, "problem": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                     break;\n                 default:", "fixed": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                     break;\n                 default:", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Math", "bugId": 10, "problem": " public void atan2(final double[] y, final int yOffset,\n         }\n     }", "fixed": " public void atan2(final double[] y, final int yOffset,\n         }\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n     }", "observations": "", "repairActions": ["assignAdd", "mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n         }\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "fixed": "else if (lclip <= 0.0) {\n         }\r\n        Number n = dataset.getStdDevValue(row, column);\r\n        if (n != null) {\r\n            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 88, "problem": " protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));", "fixed": " protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopRem", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["blockRemove", "condBlockRem", "wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 92, "problem": " void replace() {\n         } else {\n          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "fixed": " void replace() {\n         } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "observations": "", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 103, "problem": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n     }\n     /**", "fixed": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) {\n                return 0.0d;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1.0d;\n            } else {\n                throw ex;\n            }\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "retBranchAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "wrapsTryCatch", "wrongComp"]}
{"project": "Closure", "bugId": 95, "problem": " void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n       Scope scopeToDeclareIn = scope;\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {", "fixed": " void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n       Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Lang", "bugId": 41, "problem": " public static String getPackageName(Class<?> cls) {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n        if (className == null) {\n             return StringUtils.EMPTY;\n         }\n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {", "fixed": " public static String getPackageName(Class<?> cls) {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n        if (className == null || className.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {", "observations": "Existent condittional expression with null-check is expanded.", "repairActions": ["assignAdd", "condBranIfAdd", "condExpExpand", "loopAdd", "mcAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Closure", "bugId": 26, "problem": " private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n      if (!modulesWithExports.contains(moduleName)) {\n        return;\n      }\n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 104, "problem": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "fixed": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "observations": "A Null-Check was removed and replaced by another condition.", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            if (searchChars.indexOf(ch) < 0) {\n                     return i;\n             }\n         }\n         return INDEX_NOT_FOUND;", "fixed": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                     return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n             }\n         }\n         return INDEX_NOT_FOUND;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 115, "problem": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "condBlockRem"]}
{"project": "Lang", "bugId": 26, "problem": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "fixed": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "observations": "Adds a new parameter to constructor call (call overloaded constructor)", "repairActions": ["objInstMod"], "repairPatterns": ["initFix", "singleLine", "wrongMethodRef"]}
{"project": "Time", "bugId": 10, "problem": " protected static int between(ReadablePartial start, ReadablePartial end, Readabl\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n         return values[0];\n     }", "fixed": " protected static int between(ReadablePartial start, ReadablePartial end, Readabl\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n         return values[0];\n     }", "observations": "Adds new variable and its initialization.", "repairActions": ["assignAdd", "mcParValChange", "varAdd"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n            if (iter % n == 0 ||\n                 beta < 0) {\n                 searchDirection = steepestDescent.clone();", "fixed": " protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n            if (getIterations() % n == 0 ||\n                 beta < 0) {\n                 searchDirection = steepestDescent.clone();", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Chart", "bugId": 22, "problem": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n        if (row >= 0) {\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n         }\r\n         else {\r\n             return null;\r", "fixed": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n        int index = rowData.getIndex(columnKey);\r\n        if (index >= 0) {\r\n            return rowData.getObject(index);\r\n         }\r\n         else {\r\n             return null;\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Chart", "bugId": 19, "problem": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "fixed": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 14, "problem": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n         }\r\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r", "fixed": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n            }\r\n         }\r\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r", "observations": "An existing parameter (\"mode\") was wrapped by a constructor call, instantiating MockAwareVerificationMode object", "repairActions": ["condBranIfAdd", "mcAdd", "mcParValChange", "objInstAdd"], "repairPatterns": ["wrapsIf", "wrapsMethod"]}
{"project": "Closure", "bugId": 10, "problem": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "fixed": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "fixed": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Lang", "bugId": 60, "problem": " public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }", "fixed": " public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }", "observations": "", "repairActions": ["loopCondChange", "varReplVar"], "repairPatterns": ["expLogicMod", "wrongVarRef"]}
{"project": "Closure", "bugId": 91, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 30, "problem": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n   @Override", "fixed": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n   @Override", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Chart", "bugId": 25, "problem": " protected void drawVerticalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "fixed": " protected void drawVerticalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n        if (meanValue == null) {\r\n            return;\r\n        }\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 36, "problem": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n         return result;\n     }", "fixed": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n        if (Double.isNaN(result)) {\n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n            result = numerator.shiftRight(shift).floatValue() /\n                denominator.shiftRight(shift).floatValue();\n        }\n         return result;\n     }", "observations": "The change is almost the same in two different places. The only difference between changes is the use of the call \"doubleValue()\" in place of \"floatValue()\" in correspondent methods.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Closure", "bugId": 105, "problem": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n        if (sb.length() > 0) {\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);", "fixed": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n        if (sb != null) {\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = null;\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);", "observations": "Moves the instantiation of StringBuilder to another place.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "condExpMod", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "expLogicMod", "initFix"]}
{"project": "Lang", "bugId": 24, "problem": " public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                return foundDigit && !hasExp;\n             }\n             return false;", "fixed": " public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             return false;", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 99, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;", "observations": "Changed condition in expression, adds an extra computing in line 131.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "expLogicMod", "wrapsIf"]}
{"project": "Mockito", "bugId": 32, "problem": " public void process(Class<?> context, Object testClass) {\n                         Mockito.reset(instance);\r\n                     } else {\r\n                        field.set(testClass, Mockito.spy(instance));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r", "fixed": " public void process(Class<?> context, Object testClass) {\n                         Mockito.reset(instance);\r\n                     } else {\r\n                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\r\n                                .spiedInstance(instance)\r\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\r\n                                .name(field.getName())));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r", "observations": "", "repairActions": ["mcParValChange", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Lang", "bugId": 37, "problem": " public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n     }", "fixed": " public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n            }\nthrow ase;\n        }\n         return joinedArray;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "exTryCatchAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "wrapsTryCatch"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n        int iter = 0;\n         for (boolean converged = false; !converged;) {\n            ++iter;\n             PointVectorValuePair previous = current;", "fixed": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n         for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n             PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 61, "problem": " static boolean functionCallHasSideEffects(\n       }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "fixed": " static boolean functionCallHasSideEffects(\n       }\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Mockito", "bugId": 10, "problem": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n                withSettingsUsing(returnTypeGenericMetadata)\r\n         );\r\n     }\r\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n        return mockSettings.serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r", "fixed": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\r\n        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\r\n         );\r\n     }\r\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n        return propagateSerializationSettings(mockSettings, parentMockSettings)\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\r\n        return mockSettings.serializable(parentMockSettings.getSerializableMode());\r\n    }\r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r", "observations": "Changes signature of existent methods, adding new params.", "repairActions": ["mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Chart", "bugId": 12, "problem": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        this.dataset = dataset;\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "fixed": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        setDataset(dataset);\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "observations": "It involves a \"wrap with method\", but the real change is converting from a class attribute assignment to a \"set\" method call.", "repairActions": ["assignRem", "mcAdd", "varReplMc"], "repairPatterns": ["singleLine", "wrapsMethod", "wrongVarRef"]}
{"project": "Lang", "bugId": 4, "problem": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "fixed": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<String, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 114, "problem": " private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n        } else {", "fixed": " private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["singleLine", "wrapsIf"]}
{"project": "Lang", "bugId": 19, "problem": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n             }\n             int end = start;\n            while(input.charAt(end) != ';') \n             {\n                 end++;\n             }", "fixed": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n                if(start == seqEnd) {\n                    return 0;\n                }\n             }\n             int end = start;\n            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n             {\n                 end++;\n             }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Math", "bugId": 53, "problem": " public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }", "fixed": " public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Time", "bugId": 26, "problem": " public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }", "fixed": " public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 76, "problem": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\nif (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n      }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "fixed": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 92, "problem": " public static double binomialCoefficientLog(final int n, final int k) {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n         \n         /*\n          * Sum logs for values that could overflow", "fixed": " public static double binomialCoefficientLog(final int n, final int k) {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n        if (n < 67) {  \n            return Math.log(binomialCoefficient(n,k));\n        }\n         \n        if (n < 1030) { \n            return Math.log(binomialCoefficientDouble(n, k));\n        } \n         /*\n          * Sum logs for values that could overflow", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "loopAdd", "mcAdd", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "condBlockExcAdd", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missComp", "wrongMethodRef"]}
{"project": "Lang", "bugId": 34, "problem": "      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n     }\n     /**", "fixed": "      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n        return REGISTRY.get();\n     }\n     /**", "observations": "", "repairActions": ["condBranRem", "mcRem", "retExpChange"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "unwrapIfElse"]}
{"project": "Lang", "bugId": 30, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 106, "problem": " boolean canCollapseUnannotatedChildNames() {\n       if (isClassOrEnum) {\n         return true;", "fixed": " boolean canCollapseUnannotatedChildNames() {\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n       if (isClassOrEnum) {\n         return true;", "observations": "", "repairActions": ["condBranIfAdd", "condBranRem", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "unwrapIfElse"]}
{"project": "Closure", "bugId": 108, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         JSDocInfo info = n.getJSDocInfo();\n        if (info != null && !injectedDecls.contains(n)) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Lang", "bugId": 8, "problem": " public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));", "fixed": " public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n            TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Math", "bugId": 83, "problem": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "fixed": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Closure", "bugId": 84, "problem": " Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {", "fixed": " Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "mdAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Lang", "bugId": 19, "problem": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 out.write(entityValue);\n             }\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n     }", "fixed": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 out.write(entityValue);\n             }\n            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n         }\n         return 0;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Closure", "bugId": 9, "problem": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "fixed": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n    filename = filename.replace(\"\\\\\", \"/\");\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Closure", "bugId": 14, "problem": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "fixed": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "observations": "Parameter value change.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["constChange", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 50, "problem": " private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();", "fixed": " private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n    if (right != null && right.getType() == Token.STRING\n        && \",\".equals(right.getString())) {\n      n.removeChild(right);\n      reportCodeChange();\n    }\n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Time", "bugId": 25, "problem": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n         }\n         return offsetAdjusted;\n     }", "fixed": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n         }\n         return offsetAdjusted;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 38, "problem": " void addNumber(double x) {\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n       add(\" \");\n     }", "fixed": " void addNumber(double x) {\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n       add(\" \");\n     }", "observations": "Parentesis added has no effect on expression evaluation, so a conditional expression expansion was considered only.", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Time", "bugId": 26, "problem": " public long set(long instant, String text, Locale locale) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false);\n         }\n         public int getDifference(long minuendInstant, long subtrahendInstant) {", "fixed": " public long set(long instant, String text, Locale locale) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false, instant);\n         }\n         public int getDifference(long minuendInstant, long subtrahendInstant) {", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Lang", "bugId": 60, "problem": " public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }", "fixed": " public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }", "observations": "", "repairActions": ["loopCondChange", "varReplVar"], "repairPatterns": ["expLogicMod", "wrongVarRef"]}
{"project": "Mockito", "bugId": 31, "problem": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \t\tprivate String formatMethodCall() {\r\n\t\t\treturn invocation.getMethod().getName() + \"()\";\r\n \t\t}\r\n     }\r", "fixed": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \t\tprivate String formatMethodCall() {\r\n\t\t\tString args = Arrays.toString(invocation.getArguments());\r\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\r\n \t\t}\r\n     }\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 3, "problem": " private Node getDefCfgNode() {\n       return defMetadata.node;\n     }\n    private boolean canInline() {\n       if (getDefCfgNode().isFunction()) {\n         return false;", "fixed": " private Node getDefCfgNode() {\n       return defMetadata.node;\n     }\n    private boolean canInline(final Scope scope) {\n       if (getDefCfgNode().isFunction()) {\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "condExpMod", "mcAdd", "mcParAdd", "mcRepl", "mdParAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Chart", "bugId": 9, "problem": " public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\nendIndex = -(endIndex + 1);\nendIndex = endIndex - 1;\n         }\r\n        if (endIndex < 0) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r", "fixed": " public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\nendIndex = -(endIndex + 1);\nendIndex = endIndex - 1;\n         }\r\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 49, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n       case Token.FUNCTION:\n         nameStack.pop();\n         break;\n       case Token.CATCH:", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n       case Token.FUNCTION:\n        nameStack.pop();\n         nameStack.pop();\n         break;\n      case Token.LP:\n        break;\n       case Token.CATCH:", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranCaseAdd", "condBranRem", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Lang", "bugId": 52, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                     default :\n                         out.write(ch);\n                         break;", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                     default :\n                         out.write(ch);\n                         break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Chart", "bugId": 2, "problem": " public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "fixed": " public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                    double value = intervalXYData.getXValue(series, item);\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum = Math.min(minimum, value);\r\n                        maximum = Math.max(maximum, value);\r\n                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                     }\n                 }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best;\n                     }\n                 }", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n        return reportMatcher(Any.ANY).returnString();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n        return reportMatcher(new InstanceOf(String.class)).returnString();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Mockito", "bugId": 18, "problem": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "fixed": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "observations": "Returns instantiated ArrayList<Object>", "repairActions": ["condBranIfAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 72, "problem": " public double solve(final UnivariateRealFunction f,\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n             return result;\n         }", "fixed": " public double solve(final UnivariateRealFunction f,\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n             return result;\n         }", "observations": "Similar changes in two different places, the same melhod is targeted, the same argument is changed, only the new values applied are different.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 46, "problem": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "fixed": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n            boolean escapeForwardSlash) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Lang", "bugId": 47, "problem": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 29, "problem": " public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n        description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }", "fixed": " public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }", "observations": "Wrapping implicit in \"exp?x:y\" format", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckP", "singleLine", "wrapsIfElse"]}
{"project": "Lang", "bugId": 12, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n         if (start == 0 && end == 0) {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n         if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Lang", "bugId": 34, "problem": "      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n     }\n     /**", "fixed": "      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n        return m != null && m.containsKey(value);\n     }\n     /**", "observations": "", "repairActions": ["condBranRem", "mcRem", "retExpChange"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 66, "problem": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n     }\n     /**", "fixed": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(1000);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1e-11);\n        setRelativeAccuracy(1e-9);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 124, "problem": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n       node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "fixed": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n    while (node.isGetProp()) {\n       node = node.getFirstChild();\n    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "observations": "", "repairActions": ["loopAdd", "mcAdd"], "repairPatterns": ["missComp", "wrapsLoop"]}
{"project": "Math", "bugId": 16, "problem": "  */\n public class FastMath {\n     \n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "fixed": "  */\n public class FastMath {\n     \n    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(residuals);\n             for (int k = 0; k < solvedCols; ++k) {", "fixed": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(qtf);\n             for (int k = 0; k < solvedCols; ++k) {", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 101, "problem": " protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n    if (flags.process_closure_primitives) {\n      options.closurePass = true;\n    }\n     initOptionsFromFlags(options);\n     return options;\n   }", "fixed": " protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n    options.closurePass = flags.process_closure_primitives;\n     initOptionsFromFlags(options);\n     return options;\n   }", "observations": "", "repairActions": ["assignExpChange", "condBranRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Chart", "bugId": 25, "problem": " protected void drawHorizontalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "fixed": " protected void drawHorizontalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n        if (meanValue == null) {\r\n            return;\r\n        }\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 98, "problem": " public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[v.length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {", "fixed": " public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {", "observations": "Changes dimension of two vectors.", "repairActions": ["varReplVar"], "repairPatterns": ["copyPaste", "initFix", "wrongVarRef"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n         int iter = 0;\n         while (true) {", "fixed": " protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        UnivariatePointValuePair best = current;\n         int iter = 0;\n         while (true) {", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Math", "bugId": 39, "problem": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n         for (int k = 1; k < stages; ++k) {", "fixed": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n         for (int k = 1; k < stages; ++k) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n             final RealMatrix arz = randn1(dimension, lambda);", "fixed": " protected PointValuePair doOptimize() {\n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n            incrementIterationCount();\n             final RealMatrix arz = randn1(dimension, lambda);", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(new InstanceOf(Set.class)).returnSet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 43, "problem": " private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;", "fixed": " private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Lang", "bugId": 16, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 7, "problem": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "fixed": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          return ctorType.getGreatestSubtype(type);\n        } else {\n          return type.isSubtype(ctorType) ? null : type;\n        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "mcRem", "retBranchAdd", "retRem"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "wrongComp"]}
{"project": "Lang", "bugId": 11, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n        } else {\n            if (end <= start) {\n                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["condBranElseAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd"]}
{"project": "Closure", "bugId": 123, "problem": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "fixed": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "observations": "Changes value in assignment from constant to method call.", "repairActions": ["assignExpChange", "mcAdd", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "fixed": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 34, "problem": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "fixed": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Lang", "bugId": 46, "problem": " public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false);\n     }\n     /**", "fixed": " public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false, false);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 93, "problem": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "fixed": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Closure", "bugId": 111, "problem": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType;\n         }\n         @Override", "fixed": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n         }\n         @Override", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Closure", "bugId": 8, "problem": " private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n           && !blacklistedVars.contains(var);\n     }\n   }\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {", "fixed": " private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n          && !isNamedParameter(var)\n           && !blacklistedVars.contains(var);\n     }\n   }\n  private boolean isNamedParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {", "observations": "Adds a new condition in expression and a new method invocated by this condition.", "repairActions": ["mcAdd", "mdAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Math", "bugId": 36, "problem": " public BigFraction divide(final BigFraction fraction) {\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n         return result;\n     }", "fixed": " public BigFraction divide(final BigFraction fraction) {\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n        if (Double.isNaN(result)) {\n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n            result = numerator.shiftRight(shift).doubleValue() /\n                denominator.shiftRight(shift).doubleValue();\n        }\n         return result;\n     }", "observations": "The change is almost the same in two different places. The only difference between changes is the use of the call \"doubleValue()\" in place of \"floatValue()\" in correspondent methods.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Closure", "bugId": 72, "problem": " private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n                 \"inline_\",\n                 isCallInLoop)));\n   }\n   static class LabelNameSupplier implements Supplier<String> {", "fixed": " private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n                 \"inline_\",\n                 isCallInLoop)));\n    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n        .process(null, fnNode);\n   }\n   static class LabelNameSupplier implements Supplier<String> {", "observations": "Instantiates an anonymous object and make a method call on it.", "repairActions": ["condExpExpand", "mcAdd", "objInstAdd"], "repairPatterns": ["expLogicExpand", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n        return (T) anyObject();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Mockito", "bugId": 35, "problem": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T eq(T value) {\r\n        return reportMatcher(new Equals(value)).<T>returnNull();\r\n     }  \r\n     /**\r", "fixed": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T eq(T value) {\r\n        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());\r\n     }  \r\n     /**\r", "observations": "", "repairActions": ["mcAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 25, "problem": " private FlowScope traverseNew(Node n, FlowScope scope) {\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n         }\n       }\n     }\n     n.setJSType(type);\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n     return scope;\n   }", "fixed": " private FlowScope traverseNew(Node n, FlowScope scope) {\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n          backwardsInferenceFromCallSite(n, ct);\n         }\n       }\n     }\n     n.setJSType(type);\n     return scope;\n   }", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcRem"], "repairPatterns": ["blockRemove", "notClassified"]}
{"project": "Mockito", "bugId": 17, "problem": "     private Object spiedInstance;\r\n     private Answer<Object> defaultAnswer;\r\n     private MockName mockName;\r\n     public MockSettings serializable() {\r\n        return this.extraInterfaces(java.io.Serializable.class);\r\n     }\r\n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\r", "fixed": "     private Object spiedInstance;\r\n     private Answer<Object> defaultAnswer;\r\n     private MockName mockName;\r\n    private boolean serializable;\r\n     public MockSettings serializable() {\r\n        this.serializable = true;\r\n        return this;\r\n     }\r\n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Math", "bugId": 34, "problem": " public String toString() {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n     }\n }", "fixed": " public String toString() {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n        return getChromosomes().iterator();\n     }\n }", "observations": "A direct class attribute access was replaced by a method call that gives indirect access to the object.", "repairActions": ["mcAdd", "varReplMc"], "repairPatterns": ["missComp", "singleLine", "wrongVarRef"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );", "fixed": " public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 120, "problem": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n           break;\n         } else if (block.isLoop) {\n           return false;", "fixed": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n           break;\n         } else if (block.isLoop) {\n           return false;", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Lang", "bugId": 50, "problem": " public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n        if (locale != null) {\n            key = new Pair(key, locale);\n         }\n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);", "fixed": " public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n        if (locale == null) {\n            locale = Locale.getDefault();\n         }\n        key = new Pair(key, locale);\n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);", "observations": "Replaces some existent Null-Chek, inverting postive by negative.", "repairActions": ["assignAdd", "assignRem", "condBranRem", "condExpMod", "mcAdd", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockRem", "copyPaste", "expLogicMod", "unwrapIfElse", "wrongComp"]}
{"project": "Math", "bugId": 41, "problem": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }", "fixed": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }", "observations": "The changes were made only inside the for loop.", "repairActions": ["assignExpChange", "loopCondChange", "loopInitChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 99, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n             return false;\n           }\n       }\n     }", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n        if (NodeUtil.isGet(lhs)) {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n        }\n       }\n     }", "observations": "Changed condition in expression, adds an extra computing in line 131.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "expLogicMod", "wrapsIf"]}
{"project": "Math", "bugId": 72, "problem": " public double solve(final UnivariateRealFunction f,\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n             return result;\n         }", "fixed": " public double solve(final UnivariateRealFunction f,\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n             return result;\n         }", "observations": "Similar changes in two different places, the same melhod is targeted, the same argument is changed, only the new values applied are different.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 42, "problem": " protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n          if (basicRows.contains(basicRow)) {\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);", "fixed": " protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);", "observations": "", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckN", "wrapsIfElse", "wrongComp"]}
{"project": "Lang", "bugId": 15, "problem": " private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n             return typeVarAssigns;\n         }", "fixed": " private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        if (toClass.equals(cls)) {\n             return typeVarAssigns;\n         }", "observations": "Change local var type.", "repairActions": ["assignExpChange", "condExpRed", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicReduce", "wrongMethodRef"]}
{"project": "Closure", "bugId": 108, "problem": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();", "fixed": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n    private final Set<Node> injectedDecls = Sets.newHashSet();", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Math", "bugId": 55, "problem": " public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n   }", "fixed": " public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParValChange", "objInstMod", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expArithMod", "initFix", "wrongComp"]}
{"project": "Math", "bugId": 22, "problem": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return false;\n     }\n     /**", "fixed": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return true;\n     }\n     /**", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Lang", "bugId": 19, "problem": "     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '\n             int start = index + 2;\n             boolean isHex = false;", "fixed": "     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '\n             int start = index + 2;\n             boolean isHex = false;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 4, "problem": " public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n     private String exceptionCauseMessageIfAvailable(Exception details) {\n         return details.getCause().getMessage();\n     }", "fixed": " public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n     private String exceptionCauseMessageIfAvailable(Exception details) {\n        if (details.getCause() == null) {\n            return details.getMessage();\n        }\n         return details.getCause().getMessage();\n     }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return \"{...}\";\n     }\n   }", "fixed": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n     }\n   }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 51, "problem": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 default:\n                 }\n             }", "fixed": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                 default:\n                    throw new MathInternalError();\n                 }\n             }", "observations": "Adds an exception throw in default clause of switch-case.", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 93, "problem": " void replace() {\n         } else {\n          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "fixed": " void replace() {\n         } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "observations": "Same change/commit as #92.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 74, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale = new double[y0.length];\n           if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n             } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "observations": "A vector/object was instantiated.The way to initialize values was changed.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "mcRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Lang", "bugId": 64, "problem": " public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n         return iValue - ((ValuedEnum) other).iValue;\n     }", "fixed": " public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n        if (other == this) {\n            return 0;\n        }\n        if (other.getClass() != this.getClass()) {\n            if (other.getClass().getName().equals(this.getClass().getName())) {\n                return iValue - getValueInOtherClassLoader(other);\n            }\n            throw new ClassCastException(\n                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n        }\n         return iValue - ((ValuedEnum) other).iValue;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "exTryCatchAdd", "mcAdd", "mdAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Time", "bugId": 3, "problem": " public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n     }", "fixed": " public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n        if (amount != 0) {\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 89, "problem": " private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n     Node nameNode = NodeUtil.newName(", "fixed": " private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n    }\n     Node nameNode = NodeUtil.newName(", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missNullCheckN"]}
{"project": "Closure", "bugId": 102, "problem": " private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }", "fixed": " private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }", "observations": "", "repairActions": ["mcMove"], "repairPatterns": ["codeMove", "singleLine"]}
{"project": "Math", "bugId": 9, "problem": " public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n         return reverted;\n     }", "fixed": " public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n        final Line reverted = new Line(this);\n        reverted.direction = reverted.direction.negate();\n         return reverted;\n     }", "observations": "Replaced constructor by overloaded version. Changes object attribute value by direct assignment.", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "objInstMod"], "repairPatterns": ["initFix", "wrongMethodRef"]}
{"project": "Closure", "bugId": 122, "problem": " private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,", "fixed": " private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n    if (p.matcher(comment.getValue()).find()) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,", "observations": "", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["expLogicMod", "wrongComp"]}
{"project": "Lang", "bugId": 14, "problem": " public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n             return cs1.equals(cs2);\n     }\n     /**", "fixed": " public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n        if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Mockito", "bugId": 2, "problem": "     private long startTime = -1;\n     public Timer(long durationMillis) {\n         this.durationMillis = durationMillis;\n     }", "fixed": "     private long startTime = -1;\n     public Timer(long durationMillis) {\n        validateInput(durationMillis);\n         this.durationMillis = durationMillis;\n     }", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                     }\n                 }\n                 return minRow;\n         }\n         return minRatioPositions.get(0);\n     }", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                     }\n                 }\n                 return minRow;\n            }\n         }\n         return minRatioPositions.get(0);\n     }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 86, "problem": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "fixed": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "observations": "The condition to throw the exception is moved from one place to another.", "repairActions": ["condBranIfAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "objInstAdd", "objInstRem"], "repairPatterns": ["codeMove"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar) {\n           Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n               null;\n          Node varNode = parent;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "fixed": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n           Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n               null;\n          Node varNode = null;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Time", "bugId": 3, "problem": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n     }", "fixed": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 2, "problem": " public void start() {\n         startTime = System.currentTimeMillis();\n     }\n }", "fixed": " public void start() {\n         startTime = System.currentTimeMillis();\n     }\n    private void validateInput(long durationMillis) {\n        if (durationMillis < 0) {\n            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n        }\n    }\n }", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Closure", "bugId": 57, "problem": " private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n          if (target != null) {\n             className = target.getString();\n           }\n         }", "fixed": " private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n          if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }", "observations": "Altought there is a null check in the conditional expression, the expression is expanded with an extra condition not related to null-check.", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 37, "problem": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "fixed": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Closure", "bugId": 6, "problem": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n       mismatch(t, n, msg, rightType, leftType);\n      }\n       return false;\n     }\n     return true;", "fixed": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n       mismatch(t, n, msg, rightType, leftType);\n       return false;\n     }\n     return true;", "observations": "", "repairActions": ["condBranRem", "mcRem"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Closure", "bugId": 108, "problem": " private void findAliases(NodeTraversal t) {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n           }", "fixed": " private void findAliases(NodeTraversal t) {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n            injectedDecls.add(newDecl.getFirstChild());\n           }", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Lang", "bugId": 45, "problem": " public static String abbreviate(String str, int lower, int upper, String appendT\n         if (upper == -1 || upper > str.length()) {", "fixed": " public static String abbreviate(String str, int lower, int upper, String appendT\n        if (lower > str.length()) {\n            lower = str.length();    \n        }\n         if (upper == -1 || upper > str.length()) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Closure", "bugId": 56, "problem": " public String getLine(int lineNumber) {\n         return null;\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }", "fixed": " public String getLine(int lineNumber) {\n      if (pos >= js.length()) {\n         return null;\n      } else {\n        return js.substring(pos, js.length());\n      }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 57, "problem": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "fixed": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "observations": "Just changed the declared type of a primitive variable.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Chart", "bugId": 4, "problem": " public Range getDataRange(ValueAxis axis) {\n                             includedAnnotations.add(a);\r\n                         }\r\n                     }\r\n             }\r\n         }\r", "fixed": " public Range getDataRange(ValueAxis axis) {\n                             includedAnnotations.add(a);\r\n                         }\r\n                     }\r\n                }\r\n             }\r\n         }\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Math", "bugId": 54, "problem": " public double toDouble() {\n         Dfp y = this;\n         boolean negate = false;\n        if (lessThan(getZero())) {\n             y = negate();\n             negate = true;\n         }", "fixed": " public double toDouble() {\n         Dfp y = this;\n         boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n             y = negate();\n             negate = true;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "wrapsIfElse"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node block(Node ... stmts) {\n     return block;\n   }\n   public static Node script(Node ... stmts) {", "fixed": " public static Node block(Node ... stmts) {\n     return block;\n   }\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n   public static Node script(Node ... stmts) {", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 47, "problem": " public void addMapping(\n     generator.addMapping(\n         sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }", "fixed": " public void addMapping(\n    int lineBaseOffset = 1;\n    if (generator instanceof SourceMapGeneratorV1\n        || generator instanceof SourceMapGeneratorV2) {\n      lineBaseOffset = 0;\n    }\n     generator.addMapping(\n         sourceFile, originalName,\n        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcParValChange", "objInstMod", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "initFix"]}
{"project": "Lang", "bugId": 4, "problem": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "fixed": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq.toString());\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n             setMillis(getChronology().days().add(getMillis(), days));\n     }", "fixed": " public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n        if (days != 0) {\n             setMillis(getChronology().days().add(getMillis(), days));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Math", "bugId": 69, "problem": " public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }", "fixed": " public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         }", "observations": "Fix assignment operation.", "repairActions": ["assignExpChange", "mcParValChange"], "repairPatterns": ["expArithMod", "singleLine", "wrongComp"]}
{"project": "Mockito", "bugId": 20, "problem": " public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"", "fixed": " public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"", "observations": "Instantiates an InstantiatonProvider object", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRepl", "objInstAdd", "varAdd", "varReplVar"], "repairPatterns": ["wrongVarRef"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 4, "problem": " public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector3D v1D = line.intersection(subLine.line);\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));", "fixed": " public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector3D v1D = line.intersection(subLine.line);\n        if (v1D == null) {\n            return null;\n        }\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));", "observations": "Almost a copy, the only difference is in involved variable.", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 58, "problem": " public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n     }\n     /**", "fixed": " public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n     }\n     /**", "observations": "Call overloaded method without one parameter.", "repairActions": ["mcParRem", "mcRepl", "objInstRem", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Chart", "bugId": 26, "problem": " else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n         }\r\n         return state;\r", "fixed": " else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n            if (owner != null) {\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n            }\r\n         }\r\n         return state;\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Closure", "bugId": 31, "problem": " Node parseInputs() {\n       if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {", "fixed": " Node parseInputs() {\n       if (options.dependencyOptions.needsManagement() &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {", "observations": "", "repairActions": ["condExpRed"], "repairPatterns": ["expLogicReduce", "singleLine"]}
{"project": "Closure", "bugId": 79, "problem": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n   }\n   /**", "fixed": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n    compiler.reportCodeChange();\n   }\n   /**", "observations": "Calls overloaded method with extra parameters.", "repairActions": ["mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Chart", "bugId": 7, "problem": " private void updateBounds(TimePeriod period, int index) {\n         }\r\n         if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                 .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                 .getTime();\r\n             long maxMiddle = s + (e - s) / 2;\r\n             if (middle > maxMiddle) {\r", "fixed": " private void updateBounds(TimePeriod period, int index) {\n         }\r\n         if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\r\n                 .getTime();\r\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\r\n                 .getTime();\r\n             long maxMiddle = s + (e - s) / 2;\r\n             if (middle > maxMiddle) {\r", "observations": "", "repairActions": ["assignExpChange", "mcParValChange", "varReplVar"], "repairPatterns": ["copyPaste", "expArithMod", "wrongVarRef"]}
{"project": "Closure", "bugId": 25, "problem": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n     Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "fixed": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n     Node constructor = n.getFirstChild();\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcRem"], "repairPatterns": ["blockRemove", "notClassified"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];", "fixed": " protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n        double[] oldObj  = new double[rows];\n        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return isZero ? NaN : INF;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "fixed": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return NaN;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Chart", "bugId": 18, "problem": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n                 rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "fixed": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n    \tif (columnKey == null) {\r\n    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\r\n    \t}\r\n    \tif (!this.columnKeys.contains(columnKey)) {\r\n    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\r\n    \t}\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n            int index = rowData.getIndex(columnKey);\r\n            if (index >= 0) {\r\n                 rowData.removeValue(columnKey);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Math", "bugId": 22, "problem": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return true;\n     }\n     ", "fixed": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return false;\n     }\n     ", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Closure", "bugId": 15, "problem": " public boolean apply(Node n) {\n           return true;\n         }\n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {", "fixed": " public boolean apply(Node n) {\n           return true;\n         }\n        if (n.isDelProp()) {\n          return true;\n        }\n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Lang", "bugId": 35, "problem": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            return (T[]) new Object[] { null };\n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "fixed": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "observations": "Changes return of a null object to throw an Exception. The only statement of an existent \"else block\" is replaced by an exception throw.", "repairActions": ["assignRem", "exThrowsAdd", "objInstAdd", "retRem"], "repairPatterns": ["notClassified"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n         sb.append(property);\n         sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n         ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }", "fixed": " String toStringHelper(boolean forAnnotations) {\n         sb.append(property);\n         sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n         ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setWeekyear(final int weekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n     }", "fixed": " public void setWeekyear(final int weekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n        if (weekyears != 0) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 19, "problem": " public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n     }\n }", "fixed": " public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n     }\n }", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Closure", "bugId": 51, "problem": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "fixed": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x && !isNegativeZero(x)) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 1, "problem": " private void removeUnreferencedFunctionArgs(Scope fnScope) {\n     Node function = fnScope.getRootNode();", "fixed": " private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    if (!removeGlobals) {\n      return;\n    }\n     Node function = fnScope.getRootNode();", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 81, "problem": " Node processFunctionNode(FunctionNode functionNode) {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;", "fixed": " Node processFunctionNode(FunctionNode functionNode) {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 59, "problem": " public void initOptions(CompilerOptions options) {\n           CheckLevel.OFF);\n     }\n    if (options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);", "fixed": " public void initOptions(CompilerOptions options) {\n           CheckLevel.OFF);\n     }\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Closure", "bugId": 43, "problem": " private void identifyNameNode(\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n     \n     final Scope scope;\n     private final List<DeferredSetType> deferredSetTypes =\n         Lists.newArrayList();\n     \n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n     \n     \n     private final List<StubDeclaration> stubDeclarations =\n         Lists.newArrayList();\n     \n     private String sourceName = null;\n     \n     private InputId inputId;", "fixed": " private void identifyNameNode(\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n     \n     final Scope scope;\n     private final List<DeferredSetType> deferredSetTypes =\n         Lists.newArrayList();\n     \n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n     \n    private List<Node> lentObjectLiterals = null;\n     \n     private final List<StubDeclaration> stubDeclarations =\n         Lists.newArrayList();\n     \n     private String sourceName = null;\n     \n     private InputId inputId;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Closure", "bugId": 40, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n          }\n         }\n       }\n     }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n         }\n       }\n     }", "observations": "Removed a null check, maintaining the branch code.", "repairActions": ["condBranRem", "mcParValChange"], "repairPatterns": ["constChange", "unwrapIfElse"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n            zone = timeZone;\n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n        return (Set) reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n        return anySet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 4, "problem": "      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n        lookupMap = new HashMap<CharSequence, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0], seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;", "fixed": "      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n        lookupMap = new HashMap<String, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0].toString(), seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Lang", "bugId": 30, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Math", "bugId": 17, "problem": " public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n             return multiplyFast(x);\n     }\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.", "fixed": " public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n        if (x >= 0 && x < RADIX) {\n             return multiplyFast(x);\n        } else {\n            return multiply(newInstance(x));\n        }\n     }\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Closure", "bugId": 9, "problem": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Closure", "bugId": 52, "problem": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0;\n   }\n   static double getSimpleNumber(String s) {", "fixed": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0 && s.charAt(0) != '0';\n   }\n   static double getSimpleNumber(String s) {", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 64, "problem": " public Void call() throws Exception {\n        String code = toSource(root, sourceMap);\n         if (!code.isEmpty()) {\n           cb.append(code);", "fixed": " public Void call() throws Exception {\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n         if (!code.isEmpty()) {\n           cb.append(code);", "observations": "New parameters are added in three method calls (call to overloaded methods). A logic expression passed to a method call is changed.", "repairActions": ["mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Mockito", "bugId": 6, "problem": " public static List anyList() {\n      * @return empty List.\r\n      */\r\n     public static <T> List<T> anyListOf(Class<T> clazz) {\r\n        return (List) reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static List anyList() {\n      * @return empty List.\r\n      */\r\n     public static <T> List<T> anyListOf(Class<T> clazz) {\r\n        return anyList();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 45, "problem": "      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);", "fixed": "      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n        long lRow = (long) rowDimension;\n        long lCol = (long) columnDimension;\n        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Lang", "bugId": 17, "problem": " public final void translate(CharSequence input, Writer out) throws IOException {\n             return;\n         }\n         int pos = 0;\n        int len = Character.codePointCount(input, 0, input.length());\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n             }\n            else {\n             for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n             }\n            pos++;\n         }\n     }", "fixed": " public final void translate(CharSequence input, Writer out) throws IOException {\n             return;\n         }\n         int pos = 0;\n        int len = input.length();\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n                pos+= c.length;\n                continue;\n             }\n             for (int pt = 0; pt < consumed; pt++) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }", "observations": "Unwraps input.length() from \"Character.codePointCount()\" method. Unwraps \"for loop\" from else branch. Unwraps \"pos += ...\" from if-else branch.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcRem"], "repairPatterns": ["initFix", "missComp", "unwrapIfElse", "unwrapMethod"]}
{"project": "Math", "bugId": 85, "problem": " public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +", "fixed": " public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +", "observations": "Changes operator in condition.", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 25, "problem": " private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);", "fixed": " private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n                if (c2 == 0) {\n                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n                }\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Closure", "bugId": 37, "problem": " Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n       Node bodyNode = transform(functionNode.getBody());\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;", "fixed": " Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n       Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;", "observations": "Replaces method call by overloaded method with extra parameters.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["condBlockOthersAdd", "wrongMethodRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setMonthOfYear(final int monthOfYear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n             setMillis(getChronology().months().add(getMillis(), months));\n     }", "fixed": " public void setMonthOfYear(final int monthOfYear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n        if (months != 0) {\n             setMillis(getChronology().months().add(getMillis(), months));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isLabelName());\n    Preconditions.checkState(finallyBody.isLabelName());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "fixed": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 87, "problem": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                 row = i;\n                } else {\n                 return null;\n                }\n             }\n         }\n         return row;", "fixed": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                 return null;\n             }\n         }\n         return row;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 90, "problem": " public boolean apply(JSType type) {\n      if (!type.isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;", "fixed": " public boolean apply(JSType type) {\n      if (!type.restrictByNotNullOrUndefined().isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condExpMod", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Closure", "bugId": 24, "problem": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n        }\n       }\n     }", "fixed": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n        } else if (parent.getType() == Token.LP) {\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n       }\n     }", "observations": "Again, a kind of Wrap-with-IfElse where some conditionals were missing.", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Lang", "bugId": 62, "problem": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "fixed": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                            if (entityValue > 0xFFFF) {\n                                entityValue = -1;\n                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "observations": "Added a \"break\" in \"case\" branch.", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 18, "problem": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                     return false;\n                 }\n                if (x[i] > 1.0) {\n                     return false;\n                 }\n             }", "fixed": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n            final double[] bLoEnc = encode(boundaries[0]);\n            final double[] bHiEnc = encode(boundaries[1]);\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < bLoEnc[i]) {\n                     return false;\n                 }\n                if (x[i] > bHiEnc[i]) {\n                     return false;\n                 }\n             }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Math", "bugId": 38, "problem": " private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\nthrow new PathIsExploredException();\n             }\n         } while (getEvaluations() < npt);\n}", "fixed": " private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n             }\n         } while (getEvaluations() < npt);\n}", "observations": "Removes Exception Thrown. The throws line is commented in code... maybe the change isn't a final one.", "repairActions": ["assignExpChange", "exThrowsRem", "objInstRem"], "repairPatterns": ["copyPaste", "expArithMod", "initFix", "wrongComp"]}
{"project": "Math", "bugId": 77, "problem": " public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from", "fixed": " public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from", "observations": "Fix a assignment. Removes a method (aparently, unrelated changes).", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcRem", "mdOverride", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Math", "bugId": 80, "problem": " private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];", "fixed": " private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];", "observations": "Fix expression in assignment (added parathesis).", "repairActions": ["assignExpChange"], "repairPatterns": ["expArithMod", "singleLine"]}
{"project": "Chart", "bugId": 21, "problem": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "fixed": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n        }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Closure", "bugId": 32, "problem": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n           ignoreStar = true;\n           token = next();\n           continue;", "fixed": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n           ignoreStar = true;\n          lineStartChar = 0;\n           token = next();\n           continue;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Closure", "bugId": 45, "problem": " private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;", "fixed": " private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n          boolean maybeEscaped = false;\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condExpExpand", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "initFix", "wrongMethodRef"]}
{"project": "Closure", "bugId": 37, "problem": " private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n     traverseBranch(body, n);\n     popScope();", "fixed": " private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n     traverseBranch(body, n);\n     popScope();", "observations": "Replaces method call by overloaded method with extra parameters.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["condBlockOthersAdd", "wrongMethodRef"]}
{"project": "Closure", "bugId": 53, "problem": " private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n       Node replacement;\n         nodes.add(new Node(Token.TRUE));", "fixed": " private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n       Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = new Node(Token.TRUE);\n      } else {\n         nodes.add(new Node(Token.TRUE));", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }", "fixed": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                     fu = -fu;\n                 }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Collection anyCollection() {\n      * @return empty Collection.\r\n      */\r\n     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\r\n        return (Collection) reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static Collection anyCollection() {\n      * @return empty Collection.\r\n      */\r\n     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\r\n        return anyCollection();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = x[i] / diff;\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Mockito", "bugId": 27, "problem": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\r\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "fixed": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "observations": "", "repairActions": ["assignExpChange", "mcAdd", "mcRem", "objInstRem", "varRem"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Mockito", "bugId": 24, "problem": " public Object answer(InvocationOnMock invocation) {\n            return 1;\n         }\n         Class<?> returnType = invocation.getMethod().getReturnType();", "fixed": " public Object answer(InvocationOnMock invocation) {\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n         }\n         Class<?> returnType = invocation.getMethod().getReturnType();", "observations": "If-Else implicit in \"exp?x:y\" format", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
