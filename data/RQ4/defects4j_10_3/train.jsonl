{"project": "Closure", "bugId": 93, "problem": " void replace() {\n         } else {\n          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "fixed": " void replace() {\n         } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "observations": "Same change/commit as #92.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Closure", "bugId": 69, "problem": " private void visitCall(NodeTraversal t, Node n) {\n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());", "fixed": " private void visitCall(NodeTraversal t, Node n) {\n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !functionType.getTypeOfThis().isNativeObjectType() &&\n          !(child.getType() == Token.GETELEM ||\n            child.getType() == Token.GETPROP)) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Chart", "bugId": 19, "problem": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "fixed": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "copyPaste", "missNullCheckP"]}
{"project": "Lang", "bugId": 2, "problem": " public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "fixed": " public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n        if (str.contains(\"\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Closure", "bugId": 96, "problem": " private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n           parameters.hasNext()) {\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;", "fixed": " private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      if (parameters.hasNext()) {\n         parameter = parameters.next();\n      }\n       argument = arguments.next();\n       ordinal++;", "observations": "", "repairActions": ["condBranIfAdd", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "wrapsIf"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node block(Node ... stmts) {\n     return block;\n   }\n   public static Node script(Node ... stmts) {", "fixed": " public static Node block(Node ... stmts) {\n     return block;\n   }\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n   public static Node script(Node ... stmts) {", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 120, "problem": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n           break;\n         } else if (block.isLoop) {\n           return false;", "fixed": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n           break;\n         } else if (block.isLoop) {\n           return false;", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 96, "problem": " public boolean equals(Object other) {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {", "fixed": " public boolean equals(Object other) {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                 }\n             } catch (ClassCastException ex) {", "observations": "Changes logical expression in assignment", "repairActions": ["assignExpChange", "mcRem"], "repairPatterns": ["expLogicMod", "singleLine", "unwrapMethod"]}
{"project": "Closure", "bugId": 41, "problem": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "fixed": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
