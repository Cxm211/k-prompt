{"fixCommitSHA1": "8c5369562390bee531eb35c00744821b0c4821e3", "projectName": "xetorthio.jedis", "bugType": "Change Identifier Used", "problem": "       final int offset, final int count) {\n     checkIsInMultiOrPipeline();\n     client.zrangeByScoreWithScores(key, min, max, offset, count);\n    return getBinaryTupledSet();\n   }\n   @Override", "fixed": "       final int offset, final int count) {\n     checkIsInMultiOrPipeline();\n     client.zrangeByScoreWithScores(key, min, max, offset, count);\n    return getTupledSet();\n   }\n   @Override", "sourceBeforeFix": "getBinaryTupledSet()", "sourceAfterFix": "getTupledSet()"}
{"fixCommitSHA1": "fedfad854b134ea5428c592ea711c59b377a71fa", "projectName": "wildfly.wildfly", "bugType": "Change Numeric Literal", "problem": "      *\n      * @return a message for the error.\n      */\n    @Message(id = 15830, value = \"Registration of remote hosts is not supported on slave host controllers\")\n     String slaveControllerCannotAcceptOtherSlaves();\n     /**", "fixed": "      *\n      * @return a message for the error.\n      */\n    @Message(id = 10830, value = \"Registration of remote hosts is not supported on slave host controllers\")\n     String slaveControllerCannotAcceptOtherSlaves();\n     /**", "sourceBeforeFix": "id=15833", "sourceAfterFix": "id=10833"}
{"fixCommitSHA1": "d251856fc9062d7abcdb5b4e48e7385d8e978b9b", "projectName": "libgdx.libgdx", "bugType": "Change Identifier Used", "problem": " \tpublic long getLong (String key) {\r\n \t\tNSNumber value = (NSNumber)nsDictionary.get(convertKey(key));\r\n \t\tif (value == null) return 0L;\r\n\t\treturn value.longValue();\r\n \t}\r\n \t@Override\r", "fixed": " \tpublic long getLong (String key) {\r\n \t\tNSNumber value = (NSNumber)nsDictionary.get(convertKey(key));\r\n \t\tif (value == null) return 0L;\r\n\t\treturn value.longLongValue();\r\n \t}\r\n \t@Override\r", "sourceBeforeFix": "pool.dealloc()", "sourceAfterFix": "pool.drain()"}
{"fixCommitSHA1": "55ed50c4975cf694828d46ee9ca32ce72a9ef913", "projectName": "clojure.clojure", "bugType": "Wrong Function Name", "problem": " \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, args.rest());\r\n \t\tcase 15:\r\n\t\t\treturn invoke(args.first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r", "fixed": " \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, args.rest());\r\n \t\tcase 15:\r\n\t\t\treturn doInvoke(args.first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r", "sourceBeforeFix": "invoke(args.first(),(args=args.rest()).first(),args.rest())", "sourceAfterFix": "doInvoke(args.first(),(args=args.rest()).first(),args.rest())"}
{"fixCommitSHA1": "cc3afab8cec819419e52eb1fdc990625e0afd688", "projectName": "Alluxio.alluxio", "bugType": "Change Operand ", "problem": "   public static void createFiles() throws IOException {\n     long startTimeMs = CommonUtils.getCurrentMs();\n    for (int k = 0; k < THREADS; k ++) {\n       int fileId = MTC.createFile(FILE_NAME + (k + BASE_FILE_NUMBER));\n       CommonUtils.printTimeTakenMs(startTimeMs, LOG, \"user_createFiles with fileId \" + fileId);\n     }", "fixed": "   public static void createFiles() throws IOException {\n     long startTimeMs = CommonUtils.getCurrentMs();\n    for (int k = 0; k < FILES; k++) {\n       int fileId = MTC.createFile(FILE_NAME + (k + BASE_FILE_NUMBER));\n       CommonUtils.printTimeTakenMs(startTimeMs, LOG, \"user_createFiles with fileId \" + fileId);\n     }", "sourceBeforeFix": "mWorkerId + BASE_FILE_NUMBER", "sourceAfterFix": "times + BASE_FILE_NUMBER"}
{"fixCommitSHA1": "b9c0d31c3c2d6d6e91791308db92fd6a1cb5db43", "projectName": "wildfly.wildfly", "bugType": "Change Identifier Used", "problem": "             Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());\n             Assert.assertEquals(2, Integer.parseInt(response.getFirstHeader(\"value\").getValue()));\n            Assert.assertFalse(Boolean.valueOf(response.getFirstHeader(\"serialized\").getValue()));\n             response.getEntity().getContent().close();\n         } finally {\n             client.getConnectionManager().shutdown();", "fixed": "             Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatusLine().getStatusCode());\n             Assert.assertEquals(2, Integer.parseInt(response.getFirstHeader(\"value\").getValue()));\n            Assert.assertTrue(Boolean.valueOf(response.getFirstHeader(\"serialized\").getValue()));\n             response.getEntity().getContent().close();\n         } finally {\n             client.getConnectionManager().shutdown();", "sourceBeforeFix": "Assert.assertFalse(Boolean.valueOf(response.getFirstHeader(\"serialized\").getValue()))", "sourceAfterFix": "Assert.assertTrue(Boolean.valueOf(response.getFirstHeader(\"serialized\").getValue()))"}
{"fixCommitSHA1": "8afc77b3acd1616a19c58863c71febaf702cf7bf", "projectName": "yusuke.twitter4j", "bugType": "Change Identifier Used", "problem": "* @see <a href=\"http:\n      */\n     public List<Trends> getWeeklyTrends(Date date, boolean excludeHashTags) throws TwitterException {\n        return Trends.constructTrendsList(get(getSearchBaseURL()\n                 + \"trends/weekly.json?date=\" + toDateStr(date)\n                 + (excludeHashTags ? \"&exclude=hashtags\" : \"\"), false));\n     }", "fixed": "* @see <a href=\"http:\n      */\n     public List<Trends> getWeeklyTrends(Date date, boolean excludeHashTags) throws TwitterException {\n        return Trends.createTrendsList(get(getSearchBaseURL()\n                 + \"trends/weekly.json?date=\" + toDateStr(date)\n                 + (excludeHashTags ? \"&exclude=hashtags\" : \"\"), false));\n     }", "sourceBeforeFix": "Status.constructStatuses(get(getBaseURL() + \"statuses/retweeted_to_me.json\",null,true))", "sourceAfterFix": "Status.createStatuseList(get(getBaseURL() + \"statuses/retweeted_to_me.json\",null,true))"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory invertContextualRenaming =\n       new PassFactory(\"invertNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory invertContextualRenaming =\n       new PassFactory(\"invertNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "38eb6222bddaf49c3c9ae73ddef0cfe4ff5efa48", "projectName": "alibaba.dubbo", "bugType": "Change Numeric Literal", "problem": "         assertNull(url.getUsername());\r\n         assertNull(url.getPassword());\r\n         assertNull(url.getHost());\r\n        assertEquals(12, url.getPort());\r\n         assertEquals(\"context/path\", url.getPath());\r\n         assertEquals(2, url.getParameters().size());\r\n         assertEquals(\"1.0.0\", url.getParameter(\"version\"));\r", "fixed": "         assertNull(url.getUsername());\r\n         assertNull(url.getPassword());\r\n         assertNull(url.getHost());\r\n        assertEquals(0, url.getPort());\r\n         assertEquals(\"context/path\", url.getPath());\r\n         assertEquals(2, url.getParameters().size());\r\n         assertEquals(\"1.0.0\", url.getParameter(\"version\"));\r", "sourceBeforeFix": "assertEquals(12,url.getPort())", "sourceAfterFix": "assertEquals(0,url.getPort())"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory denormalize =\n       new PassFactory(\"denormalize\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory denormalize =\n       new PassFactory(\"denormalize\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "eb71c8999ff29f7dc3fe8dcdba81084f7f6a5fac", "projectName": "NanoHttpd.nanohttpd", "bugType": "Same Function More Args", "problem": "                     while (line != null && line.trim().length() > 0) {\n                         int p = line.indexOf(':');\n                         if (p >= 0)\n                            headers.put(line.substring(0, p).trim().toLowerCase(), line.substring(p + 1).trim());\n                         line = in.readLine();\n                     }\n                 }", "fixed": "                     while (line != null && line.trim().length() > 0) {\n                         int p = line.indexOf(':');\n                         if (p >= 0)\n                            headers.put(line.substring(0, p).trim().toLowerCase(Locale.US), line.substring(p + 1).trim());\n                         line = in.readLine();\n                     }\n                 }", "sourceBeforeFix": "line.substring(0,p).trim().toLowerCase()", "sourceAfterFix": "line.substring(0,p).trim().toLowerCase(Locale.US)"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory inlineFunctions =\n       new PassFactory(\"inlineFunctions\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory inlineFunctions =\n       new PassFactory(\"inlineFunctions\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "    * Alias string literals with global variables, to avoid creating lots of\n    * transient objects.\n    */\n  private final PassFactory aliasStrings =\n       new PassFactory(\"aliasStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "    * Alias string literals with global variables, to avoid creating lots of\n    * transient objects.\n    */\n  final PassFactory aliasStrings =\n       new PassFactory(\"aliasStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "8fdd403b6c8331d56890de3165b7a0e77a0eaa42", "projectName": "apache.flink", "bugType": "Change Modifier", "problem": " \t * \n \t * @return True, if the data type supports the creation of a normalized key for comparison, false otherwise.\n \t */\n\tpublic boolean supportsNormalizedKey();\n \t/**\n \t * Check whether this comparator supports to serialize the record in a format that replaces its keys by a normalized", "fixed": " \t * \n \t * @return True, if the data type supports the creation of a normalized key for comparison, false otherwise.\n \t */\n\tpublic abstract boolean supportsNormalizedKey();\n \t/**\n \t * Check whether this comparator supports to serialize the record in a format that replaces its keys by a normalized", "sourceBeforeFix": "1", "sourceAfterFix": "1025"}
{"fixCommitSHA1": "24cf9587db23679d74680f32beade181791bf88c", "projectName": "Atmosphere.atmosphere", "bugType": "Change Identifier Used", "problem": "             asyncWriteFuture = new Future<?>[threads];\n             for (int i = 0; i < threads; i++) {\n                 notifierFuture[i] = bc.getExecutorService().submit(getBroadcastHandler());\n                asyncWriteFuture[i] = bc.getExecutorService().submit(getAsyncWriteHandler(uniqueWriteQueue));\n             }\n         } else {\n             notifierFuture[0] = bc.getExecutorService().submit(getBroadcastHandler());", "fixed": "             asyncWriteFuture = new Future<?>[threads];\n             for (int i = 0; i < threads; i++) {\n                 notifierFuture[i] = bc.getExecutorService().submit(getBroadcastHandler());\n                asyncWriteFuture[i] = bc.getAsyncWriteService().submit(getAsyncWriteHandler(uniqueWriteQueue));\n             }\n         } else {\n             notifierFuture[0] = bc.getExecutorService().submit(getBroadcastHandler());", "sourceBeforeFix": "bc.getExecutorService()", "sourceAfterFix": "bc.getAsyncWriteService()"}
{"fixCommitSHA1": "ec6f0cffe68e0736c04783b61f980f1271064dd9", "projectName": "google.guava", "bugType": "Change Modifier", "problem": "   }\n   @Override\n  public boolean equals(@Nullable Object obj) {\n     if (obj == this) {\n       return true;\n     }", "fixed": "   }\n   @Override\n  public final boolean equals(@Nullable Object obj) {\n     if (obj == this) {\n       return true;\n     }", "sourceBeforeFix": "1", "sourceAfterFix": "17"}
