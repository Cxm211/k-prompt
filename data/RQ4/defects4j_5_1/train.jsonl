{"project": "Lang", "bugId": 52, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                     default :\n                         out.write(ch);\n                         break;", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                     default :\n                         out.write(ch);\n                         break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Lang", "bugId": 20, "problem": " public static String join(Object[] array, String separator, int startIndex, int\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "fixed": " public static String join(Object[] array, String separator, int startIndex, int\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "observations": "Null-Check is removed from \"buf\" initialization.", "repairActions": ["assignExpChange", "condBranRem", "mcRem", "objInstMod"], "repairPatterns": ["condBlockRem", "copyPaste", "initFix"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Closure", "bugId": 44, "problem": " void add(String newcode) {\n       append(\" \");\n     }\n     append(newcode);", "fixed": " void add(String newcode) {\n       append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      append(\" \");\n     }\n     append(newcode);", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 54, "problem": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          if (!qVar.isTypeInferred()) {", "fixed": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.getType() == Token.OBJECTLIT) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
