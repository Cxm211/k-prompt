{"project": "Mockito", "bugId": 2, "problem": " public void start() {\n         startTime = System.currentTimeMillis();\n     }\n }", "fixed": " public void start() {\n         startTime = System.currentTimeMillis();\n     }\n    private void validateInput(long durationMillis) {\n        if (durationMillis < 0) {\n            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n        }\n    }\n }", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Lang", "bugId": 12, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n         if (start == 0 && end == 0) {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n         if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar) {\n           Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n               null;\n          Node varNode = parent;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "fixed": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n           Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n               null;\n          Node varNode = null;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 66, "problem": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "fixed": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 65, "problem": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "fixed": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\000\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Math", "bugId": 106, "problem": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r", "fixed": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n        if (den.intValue() < 0) {\r\n            pos.setIndex(initialIndex);\r\n            return null;\r\n        }\r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r", "observations": "Only one variable is different between the two blocks of code in patch.", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n        return (Set) reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n        return anySet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 64, "problem": " public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n         return iValue - ((ValuedEnum) other).iValue;\n     }", "fixed": " public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n        if (other == this) {\n            return 0;\n        }\n        if (other.getClass() != this.getClass()) {\n            if (other.getClass().getName().equals(this.getClass().getName())) {\n                return iValue - getValueInOtherClassLoader(other);\n            }\n            throw new ClassCastException(\n                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n        }\n         return iValue - ((ValuedEnum) other).iValue;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "exTryCatchAdd", "mcAdd", "mdAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 115, "problem": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "condBlockRem"]}
{"project": "Mockito", "bugId": 36, "problem": " public int getArgumentsCount() {\n     }\n     public Object callRealMethod() throws Throwable {\n         return realMethod.invoke(mock, rawArguments);\n     }", "fixed": " public int getArgumentsCount() {\n     }\n     public Object callRealMethod() throws Throwable {\n        if (this.getMethod().getDeclaringClass().isInterface()) {\n            new Reporter().cannotCallRealMethodOnInterface();\n        }\n         return realMethod.invoke(mock, rawArguments);\n     }", "observations": "Instantiates an Reporter object", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 81, "problem": " private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             work[i + 2]  = -sigma;", "fixed": " private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             work[i + 2]  = -sigma;", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Math", "bugId": 6, "problem": " protected PointVectorValuePair doOptimize() {\n         lmPar = 0;\n         boolean firstIteration = true;\n        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n            ++iter;\n             final PointVectorValuePair previous = current;", "fixed": " protected PointVectorValuePair doOptimize() {\n         lmPar = 0;\n         boolean firstIteration = true;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n            incrementIterationCount();\n             final PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 103, "problem": " public JSTypeSystem(AbstractCompiler compiler) {\n       }\n       return foundType;\n     }", "fixed": " public JSTypeSystem(AbstractCompiler compiler) {\n       }\n      if (foundType == null) {\n        ObjectType maybeType = ObjectType.cast(\n            registry.getGreatestSubtypeWithProperty(type, field));\n        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n          foundType = maybeType;\n        }\n      }\n       return foundType;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN", "missNullCheckP"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            if (searchChars.indexOf(ch) < 0) {\n                     return i;\n             }\n         }\n         return INDEX_NOT_FOUND;", "fixed": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                     return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n             }\n         }\n         return INDEX_NOT_FOUND;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 44, "problem": " void add(String newcode) {\n       append(\" \");\n     }\n     append(newcode);", "fixed": " void add(String newcode) {\n       append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      append(\" \");\n     }\n     append(newcode);", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 91, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return isZero ? NaN : INF;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "fixed": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return NaN;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Math", "bugId": 105, "problem": " public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n     }\n     /**", "fixed": " public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n     }\n     /**", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsMethod"]}
{"project": "Lang", "bugId": 18, "problem": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                     rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\ncase 'M':", "fixed": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen == 2) {\n                     rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                 }\n                 break;\ncase 'M':", "observations": "An existent if-else structure is removed and a new one is placed in an action that resembles a wrap-with replacement. An aditional wrap-with-IfElse is present in IfElse-CondExp form.", "repairActions": ["condBranIfElseAdd", "condExpMod", "mcParValChange"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node block(Node ... stmts) {\n     return block;\n   }\n   public static Node script(Node ... stmts) {", "fixed": " public static Node block(Node ... stmts) {\n     return block;\n   }\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n   public static Node script(Node ... stmts) {", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 30, "problem": "   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n     Definition(Node node) {\n       this.node = node;", "fixed": "   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n    private boolean unknownDependencies = false;\n     Definition(Node node) {\n       this.node = node;", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 30, "problem": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n   @Override", "fixed": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n   @Override", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Lang", "bugId": 51, "problem": " public static boolean toBoolean(String str) {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n             }\n             case 4: {\n                 char ch = str.charAt(0);", "fixed": " public static boolean toBoolean(String str) {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);", "observations": "Adds a return statement that does the role of an \"else\" branch.", "repairActions": ["retBranchAdd"], "repairPatterns": ["singleLine"]}
{"project": "Time", "bugId": 2, "problem": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n         return 0;\n     }", "fixed": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n         return 0;\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Closure", "bugId": 9, "problem": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Closure", "bugId": 24, "problem": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n        }\n       }\n     }", "fixed": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n        } else if (parent.getType() == Token.LP) {\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n       }\n     }", "observations": "Again, a kind of Wrap-with-IfElse where some conditionals were missing.", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Mockito", "bugId": 34, "problem": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "fixed": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n           Node childVal = child.getFirstChild();", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n          validProperties.add(child.getString());\n           Node childVal = child.getFirstChild();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Lang", "bugId": 4, "problem": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "fixed": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<String, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 40, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n          }\n         }\n       }\n     }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n         }\n       }\n     }", "observations": "Removed a null check, maintaining the branch code.", "repairActions": ["condBranRem", "mcParValChange"], "repairPatterns": ["constChange", "unwrapIfElse"]}
{"project": "Math", "bugId": 76, "problem": " public RealMatrix getV()\n                 final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n                }\n                         for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }", "fixed": " public RealMatrix getV()\n                 final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n                    } else {\n                         for (int j = 0; j < p; ++j) {\n                            wi[j] = mi * ei0[j] / singularValues[j];\n                         }\n                    }\n                }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }", "observations": "The structure of the changes are similar and applied in two different methods.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "loopCondChange", "mcParValChange", "varReplVar"], "repairPatterns": ["copyPaste", "expArithMod", "expLogicMod", "wrapsIfElse", "wrongVarRef"]}
{"project": "Mockito", "bugId": 30, "problem": " public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n    public void smartNullPointerException(Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"", "fixed": " public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n    public void smartNullPointerException(Object obj, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n                obj,\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"", "observations": "Adds new parameter to method signature, ajust code.", "repairActions": ["mcParAdd", "mcRepl", "mdParAdd", "objInstMod"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Math", "bugId": 93, "problem": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "fixed": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Math", "bugId": 51, "problem": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 default:\n                 }\n             }", "fixed": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                 default:\n                    throw new MathInternalError();\n                 }\n             }", "observations": "Adds an exception throw in default clause of switch-case.", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 49, "problem": " public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n     if (declarationRoot.getType() != Token.FUNCTION) {\n       findDeclaredNames(declarationRoot, null, renamer);", "fixed": " public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() != Token.FUNCTION) {\n       findDeclaredNames(declarationRoot, null, renamer);", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranCaseAdd", "condBranRem", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Mockito", "bugId": 11, "problem": " public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n             return method.equals(o);\n     }\n     @Override\n     public int hashCode() {\n        return 1;\n     }\n }\n\\ No newline at end of file", "fixed": " public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o instanceof DelegatingMethod) {\n            DelegatingMethod that = (DelegatingMethod) o;\n            return method.equals(that.method);\n        } else {\n             return method.equals(o);\n        }\n     }\n     @Override\n     public int hashCode() {\n        return method.hashCode();\n     }\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIfElse"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );", "fixed": " public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 76, "problem": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\nif (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n      }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "fixed": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "fixed": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 23, "problem": " private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n     Node current = left.getFirstChild();\n     Node elem = null;\n    for (int i = 0; current != null && i < intIndex; i++) {\n         elem = current;\n       current = current.getNext();\n     }", "fixed": " private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n     Node current = left.getFirstChild();\n     Node elem = null;\n    for (int i = 0; current != null; i++) {\n      if (i != intIndex) {\n        if (mayHaveSideEffects(current)) {\n          return n;\n        }\n      } else {\n         elem = current;\n      }\n       current = current.getNext();\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopCondChange", "mcAdd", "retBranchAdd"], "repairPatterns": ["expLogicReduce", "wrapsIfElse"]}
{"project": "Math", "bugId": 24, "problem": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return current;\n             }\n             ++iter;\n         }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["copyPaste", "wrapsMethod"]}
{"project": "Math", "bugId": 7, "problem": " public int compare(EventState es0, EventState es1) {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n                 for (final StepHandler handler : stepHandlers) {", "fixed": " public int compare(EventState es0, EventState es1) {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || state.stop();\n                }\n                 for (final StepHandler handler : stepHandlers) {", "observations": "Changes involving adding and removing of many loops.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "loopRem", "mcRem", "varReplVar"], "repairPatterns": ["copyPaste", "wrapsLoop", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 11, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n        } else {\n            if (end <= start) {\n                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["condBranElseAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Math", "bugId": 22, "problem": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return false;\n     }\n     /**", "fixed": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return true;\n     }\n     /**", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n        int iter = 0;\n         for (boolean converged = false; !converged;) {\n            ++iter;\n             PointVectorValuePair previous = current;", "fixed": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n         for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n             PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 66, "problem": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n     }\n     /**", "fixed": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(1000);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1e-11);\n        setRelativeAccuracy(1e-9);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 74, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale = new double[y0.length];\n           if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n             } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "observations": "A vector/object was instantiated.The way to initialize values was changed.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "mcRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Closure", "bugId": 106, "problem": " public void markName(String name, int lineno, int charno) {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n    if (parseDocumentation) {\n     populated = true;\n    }\n     return currentInfo.documentBlock(description);\n   }", "fixed": " public void markName(String name, int lineno, int charno) {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n     populated = true;\n     return currentInfo.documentBlock(description);\n   }", "observations": "", "repairActions": ["condBranIfAdd", "condBranRem", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 47, "problem": " public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n     }\n     ", "fixed": " public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n        isZero = real == 0 && imaginary == 0;\n     }\n     ", "observations": "The \"WrapWith\" condition is in the form \"exp?a:b\". The added variable is a class attribute.", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "retExpChange", "varAdd"], "repairPatterns": ["copyPaste", "expLogicMod", "wrapsIfElse", "wrongComp"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         }\n         PointValuePair current = null;\n        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n            ++iter;\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }", "fixed": " protected PointValuePair doOptimize() {\n         }\n         PointValuePair current = null;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n            incrementIterationCount();\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                     return current;\n                 }", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 38, "problem": " private void prelim(double[] lowerBound,\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\nthrow new PathIsExploredException();\n                 }\n                final int iptMinus1 = ipt;\n                final int jptMinus1 = jpt;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }", "fixed": " private void prelim(double[] lowerBound,\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n                 }\n                final int iptMinus1 = ipt - 1;\n                final int jptMinus1 = jpt - 1;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }", "observations": "Removes Exception Thrown. The throws line is commented in code... maybe the change isn't a final one.", "repairActions": ["assignExpChange", "exThrowsRem", "objInstRem"], "repairPatterns": ["copyPaste", "expArithMod", "initFix", "wrongComp"]}
{"project": "Closure", "bugId": 17, "problem": " private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();", "fixed": " private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();", "observations": "Transform If structure in Wrap-with IfElse.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN"]}
{"project": "Time", "bugId": 23, "problem": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "fixed": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "observations": "Changes entries in a key-value map.", "repairActions": ["mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Mockito", "bugId": 12, "problem": " public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n                 return (Class) actual;\r\n         }\r\n         return Object.class;\r", "fixed": " public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n            if (actual instanceof Class) {\r\n                 return (Class) actual;\r\n            } else if (actual instanceof ParameterizedType) {\r\n                return (Class) ((ParameterizedType) actual).getRawType();\r\n            }\r\n         }\r\n         return Object.class;\r", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Closure", "bugId": 108, "problem": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();", "fixed": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n    private final Set<Node> injectedDecls = Sets.newHashSet();", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 133, "problem": " private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n     return result;\n   }", "fixed": " private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n     return result;\n   }", "observations": "It seems that the variable is reseted by method.", "repairActions": ["assignAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Math", "bugId": 79, "problem": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "fixed": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["notClassified"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "fixed": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return \"{...}\";\n     }\n   }", "fixed": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n     }\n   }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 5, "problem": " public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }", "fixed": " public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n            catch (AssertionError e) {\n                 error = handleVerifyException(e);\n             }\n         }", "observations": "Change parameter type in catch command.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Time", "bugId": 3, "problem": " public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n             setMillis(getChronology().days().add(getMillis(), days));\n     }", "fixed": " public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n        if (days != 0) {\n             setMillis(getChronology().days().add(getMillis(), days));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 104, "problem": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "fixed": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "observations": "A Null-Check was removed and replaced by another condition.", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 87, "problem": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                 row = i;\n                } else {\n                 return null;\n                }\n             }\n         }\n         return row;", "fixed": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                 return null;\n             }\n         }\n         return row;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 20, "problem": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "fixed": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckP", "singleLine"]}
{"project": "Lang", "bugId": 46, "problem": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "fixed": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n            boolean escapeForwardSlash) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 123, "problem": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "fixed": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "observations": "Changes value in assignment from constant to method call.", "repairActions": ["assignExpChange", "mcAdd", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 22, "problem": " public class Equality {\r\n     public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r", "fixed": " public class Equality {\r\n     public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == o2 ) {\r\n            return true;\r\n\t} else if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r", "observations": "", "repairActions": ["condBranIfElseAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 18, "problem": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                     return false;\n                 }\n                if (x[i] > 1.0) {\n                     return false;\n                 }\n             }", "fixed": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n            final double[] bLoEnc = encode(boundaries[0]);\n            final double[] bHiEnc = encode(boundaries[1]);\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < bLoEnc[i]) {\n                     return false;\n                 }\n                if (x[i] > bHiEnc[i]) {\n                     return false;\n                 }\n             }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 62, "problem": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "fixed": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "observations": "Just changed the operator in \"if\" condition", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 36, "problem": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n         return result;\n     }", "fixed": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n        if (Double.isNaN(result)) {\n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n            result = numerator.shiftRight(shift).floatValue() /\n                denominator.shiftRight(shift).floatValue();\n        }\n         return result;\n     }", "observations": "The change is almost the same in two different places. The only difference between changes is the use of the call \"doubleValue()\" in place of \"floatValue()\" in correspondent methods.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Lang", "bugId": 19, "problem": "     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '\n             int start = index + 2;\n             boolean isHex = false;", "fixed": "     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '\n             int start = index + 2;\n             boolean isHex = false;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 23, "problem": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "fixed": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n\t\t        .serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Lang", "bugId": 37, "problem": " public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n     }", "fixed": " public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n            }\nthrow ase;\n        }\n         return joinedArray;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "exTryCatchAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "wrapsTryCatch"]}
{"project": "Closure", "bugId": 93, "problem": " void replace() {\n         } else {\n          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "fixed": " void replace() {\n         } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "observations": "Same change/commit as #92.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n        return reportMatcher(Any.ANY).returnMap();\r\n     }\r\n     /**\r", "fixed": " public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n        return reportMatcher(new InstanceOf(Map.class)).returnMap();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 91, "problem": " public Fraction abs() {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }", "fixed": " public Fraction abs() {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }", "observations": "The value of a class attribute is accessed in place of a method to do the assignment.", "repairActions": ["assignExpChange", "mcRem", "varTyChange"], "repairPatterns": ["expArithMod", "initFix", "wrongComp"]}
{"project": "Lang", "bugId": 36, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n        if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand"]}
{"project": "Chart", "bugId": 6, "problem": " public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n        return super.equals(obj);\n     }", "fixed": " public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n        ShapeList that = (ShapeList) obj;\n        int listSize = size();\n        for (int i = 0; i < listSize; i++) {\n           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n               return false;\n           }\n        }\n        return true;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "mcRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrongComp"]}
{"project": "Math", "bugId": 67, "problem": " public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n     \n     public double getFunctionValue() {\n        return optimizer.getFunctionValue();\n     }\n     \n     public double getResult() {\n        return optimizer.getResult();\n     }\n     ", "fixed": " public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n     \n     public double getFunctionValue() {\n        return optimaValues[0];\n     }\n     \n     public double getResult() {\n        return optima[0];\n     }\n     ", "observations": "A direct access to a vector was added in place of a value returned from a call to an object method. The change was similar in structure in two different places.", "repairActions": ["mcRem", "retExpChange"], "repairPatterns": ["wrongMethodRef"]}
{"project": "Lang", "bugId": 30, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 37, "problem": " public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n     }\r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r", "fixed": " public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n        if (answer instanceof CallsRealMethods) {\r\n            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\r\n        }\r\n     }\r\n    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\r\n        if (invocation.getMethod().getDeclaringClass().isInterface()) {\r\n            reporter.cannotCallRealMethodOnInterface();\r\n        }\r\n    }\r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 6, "problem": " public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n            if (iteration > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];", "fixed": " public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n            if (getIterations() > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 54, "problem": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          if (!qVar.isTypeInferred()) {", "fixed": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.getType() == Token.OBJECTLIT) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 54, "problem": " public void setPrototypeBasedOn(ObjectType baseType) {\n     if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {", "fixed": " public void setPrototypeBasedOn(ObjectType baseType) {\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Math", "bugId": 100, "problem": " public double getChiSquare(EstimationProblem problem) {\n         final int rows = problem.getMeasurements().length;\n        final int cols = problem.getAllParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {", "fixed": " public double getChiSquare(EstimationProblem problem) {\n         final int rows = problem.getMeasurements().length;\n        final int cols = problem.getUnboundParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {", "observations": "Apply the same replace of methods in three different places.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = x[i] / diff;\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 70, "problem": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "fixed": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Math", "bugId": 13, "problem": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "Contains the patch of Math-13", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["missComp", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(new InstanceOf(Set.class)).returnSet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 35, "problem": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            return (T[]) new Object[] { null };\n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "fixed": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "observations": "Changes return of a null object to throw an Exception. The only statement of an existent \"else block\" is replaced by an exception throw.", "repairActions": ["assignRem", "exThrowsAdd", "objInstAdd", "retRem"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 52, "problem": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0;\n   }\n   static double getSimpleNumber(String s) {", "fixed": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0 && s.charAt(0) != '0';\n   }\n   static double getSimpleNumber(String s) {", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Time", "bugId": 13, "problem": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }", "fixed": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n                        buf.insert(bufLen, '-');\n                    }\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expArithMod", "wrapsIfElse"]}
{"project": "Math", "bugId": 15, "problem": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }", "fixed": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
