{"project": "Closure", "bugId": 67, "problem": " private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n          ) {\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;", "fixed": " private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n          && assign.getParent().getType() == Token.EXPR_RESULT) {\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }", "fixed": " protected VectorialPointValuePair doOptimize()\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * qtf[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 90, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n     if (maybeTypeOfThis instanceof ObjectType) {\n       typeOfThis = (ObjectType) maybeTypeOfThis;\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n     if (maybeTypeOfThis instanceof ObjectType) {\n       typeOfThis = (ObjectType) maybeTypeOfThis;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condExpMod", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Mockito", "bugId": 23, "problem": " protected GenericMetadataSupport actualParameterizedType(Object mock) {\n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\r\n        container.addAnswer(new Answer<Object>() {\r\n             public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                 return mock;\r\n             }\r", "fixed": " protected GenericMetadataSupport actualParameterizedType(Object mock) {\n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\r\n        container.addAnswer(new SerializableAnswer() {\r\n             public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                 return mock;\r\n             }\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Lang", "bugId": 6, "problem": " public final void translate(CharSequence input, Writer out) throws IOException {\n             for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }", "fixed": " public final void translate(CharSequence input, Writer out) throws IOException {\n             for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }", "observations": "", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["expArithMod", "singleLine", "wrongVarRef"]}
{"project": "Time", "bugId": 13, "problem": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iPrefix != null) {\n                 iPrefix.printTo(buf, value);\n             }\n             int minDigits = iMinPrintedDigits;\n             if (minDigits <= 1) {\n                 FormatUtils.appendUnpaddedInteger(buf, value);", "fixed": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iPrefix != null) {\n                 iPrefix.printTo(buf, value);\n             }\n            int bufLen = buf.length();\n             int minDigits = iMinPrintedDigits;\n             if (minDigits <= 1) {\n                 FormatUtils.appendUnpaddedInteger(buf, value);", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expArithMod", "wrapsIfElse"]}
{"project": "Closure", "bugId": 84, "problem": " Node processArrayLiteral(ArrayLiteral literalNode) {\n     @Override\n     Node processAssignment(Assignment assignmentNode) {\n       Node assign = processInfixExpression(assignmentNode);\n       return assign;\n     }", "fixed": " Node processArrayLiteral(ArrayLiteral literalNode) {\n     @Override\n     Node processAssignment(Assignment assignmentNode) {\n       Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          target.getLineno(), \"\", 0);\n      }\n       return assign;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "mdAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 33, "problem": " protected void dropPhase1Objective() {\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }", "fixed": " protected void dropPhase1Objective() {\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }", "observations": "A variable used in a method call is replaced by another one.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["expLogicMod", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 28, "problem": " void addIdentifier(String identifier) {\n      * Constants (true, false, null) are considered basically free,\n      * because it's likely that they will get folded when we're done.\n      */\n   }\n }", "fixed": " void addIdentifier(String identifier) {\n      * Constants (true, false, null) are considered basically free,\n      * because it's likely that they will get folded when we're done.\n      */\n    @Override\n    void addConstant(String newcode) {\n      add(\"0\");\n    }\n   }\n }", "observations": "Overrides the addConstant method. Replaces method calls.", "repairActions": ["mcAdd", "mdAdd", "mdOverride"], "repairPatterns": ["notClassified", "wrongComp"]}
{"project": "Time", "bugId": 3, "problem": " public void setWeekOfWeekyear(final int weekOfWeekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeeks(final int weeks) {\n             setMillis(getChronology().weeks().add(getMillis(), weeks));\n     }", "fixed": " public void setWeekOfWeekyear(final int weekOfWeekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeeks(final int weeks) {\n        if (weeks != 0) {\n             setMillis(getChronology().weeks().add(getMillis(), weeks));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Lang", "bugId": 22, "problem": " public Fraction pow(int power) {\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             return 1;\n         }", "fixed": " public Fraction pow(int power) {\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n             return 1;\n         }", "observations": "", "repairActions": ["condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp"]}
{"project": "Closure", "bugId": 121, "problem": " private void inlineNonConstants(\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 ; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNode();", "fixed": " private void inlineNonConstants(\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime() &&\n          (isInlineableDeclaredConstant(v, referenceInfo) ||\n           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 ; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNode();", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 40, "problem": " protected double doSolve() {\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                targetY = -REDUCTION_FACTOR * yB;\n             } else if (agingB >= MAXIMAL_AGING) {\n                targetY = -REDUCTION_FACTOR * yA;\n             } else {\n                 targetY = 0;", "fixed": " protected double doSolve() {\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                final int p = agingA - MAXIMAL_AGING;\n                final double weightA = (1 << p) - 1;\n                final double weightB = p + 1;\n                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n             } else if (agingB >= MAXIMAL_AGING) {\n                final int p = agingB - MAXIMAL_AGING;\n                final double weightA = p + 1;\n                final double weightB = (1 << p) - 1;\n                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n             } else {\n                 targetY = 0;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "varAdd"], "repairPatterns": ["copyPaste", "expArithMod", "wrongComp"]}
{"project": "Closure", "bugId": 16, "problem": " public void applyAlias() {\n   private class AliasedTypeNode implements AliasUsage {\n     private final Node typeReference;\n     private final String aliasName;\n    AliasedTypeNode(Node typeReference,\n         String aliasName) {\n       this.typeReference = typeReference;\n       this.aliasName = aliasName;\n     }\n     @Override\n     public void applyAlias() {\n      typeReference.setString(aliasName);\n     }\n   }", "fixed": " public void applyAlias() {\n   private class AliasedTypeNode implements AliasUsage {\n     private final Node typeReference;\n    private final Node aliasDefinition;\n     private final String aliasName;\n    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n         String aliasName) {\n       this.typeReference = typeReference;\n      this.aliasDefinition = aliasDefinition;\n       this.aliasName = aliasName;\n     }\n     @Override\n     public void applyAlias() {\n      String typeName = typeReference.getString();\n      String aliasExpanded =\n          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n      Preconditions.checkState(typeName.startsWith(aliasName));\n      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n     }\n   }", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "objInstMod", "varAdd"], "repairPatterns": ["initFix", "wrapsMethod", "wrongComp"]}
{"project": "Math", "bugId": 43, "problem": " public void addValue(double value) {\n         secondMoment.increment(value);\n        if (!(meanImpl instanceof Mean)) {\n             meanImpl.increment(value);\n         }\n        if (!(varianceImpl instanceof Variance)) {\n             varianceImpl.increment(value);\n         }\n        if (!(geoMeanImpl instanceof GeometricMean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;", "fixed": " public void addValue(double value) {\n         secondMoment.increment(value);\n        if (meanImpl != mean) {\n             meanImpl.increment(value);\n         }\n        if (varianceImpl != variance) {\n             varianceImpl.increment(value);\n         }\n        if (geoMeanImpl != geoMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;", "observations": "", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod"]}
{"project": "Chart", "bugId": 8, "problem": " public Week(Date time) {\n      */\r\n     public Week(Date time, TimeZone zone) {\r\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\r\n     }\r\n     /**\r", "fixed": " public Week(Date time) {\n      */\r\n     public Week(Date time, TimeZone zone) {\r\n        this(time, zone, Locale.getDefault());\r\n     }\r\n     /**\r", "observations": "Changes params passed to constructor.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 47, "problem": " public Complex conjugate() {\n     public Complex divide(Complex divisor)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(divisor);\n         if (isNaN || divisor.isNaN) {\n             return NaN;\n         }\n        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\n            return NaN;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n         final double c = divisor.getReal();\n         final double d = divisor.getImaginary();\n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n             return createComplex((real * q + imaginary) / denominator,\n                 (imaginary * q - real) / denominator);\n         } else {\n             double q = d / c;\n             double denominator = d * q + c;\n             return createComplex((imaginary * q + real) / denominator,\n                 (imaginary - real * q) / denominator);\n         }\n     }\n     \n     public Complex divide(double divisor) {\n         if (isNaN || Double.isNaN(divisor)) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n         }\n         return createComplex(real / divisor,\n                              imaginary  / divisor);\n     }\n     /**\n      * Test for the equality of two Complex objects.\n      * If both the real and imaginary parts of two complex numbers\n      * are exactly the same, and neither is {@code Double.NaN}, the two\n      * Complex objects are considered to be equal.\n      * All {@code NaN} values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal", "fixed": " public Complex conjugate() {\n     public Complex divide(Complex divisor)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(divisor);\n         if (isNaN || divisor.isNaN) {\n             return NaN;\n         }\n        if (divisor.isZero) {\n            return isZero ? NaN : INF;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n         final double c = divisor.getReal();\n         final double d = divisor.getImaginary();\n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n             return createComplex((real * q + imaginary) / denominator,\n                 (imaginary * q - real) / denominator);\n         } else {\n             double q = d / c;\n             double denominator = d * q + c;\n             return createComplex((imaginary * q + real) / denominator,\n                 (imaginary - real * q) / denominator);\n         }\n     }\n     \n     public Complex divide(double divisor) {\n         if (isNaN || Double.isNaN(divisor)) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n         }\n         return createComplex(real / divisor,\n                              imaginary  / divisor);\n     }\n     /**\n      * Test for the equality of two Complex objects.\n      * If both the real and imaginary parts of two complex numbers\n      * are exactly the same, and neither is {@code Double.NaN}, the two\n      * Complex objects are considered to be equal.\n      * All {@code NaN} values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal", "observations": "The \"WrapWith\" condition is in the form \"exp?a:b\". The added variable is a class attribute.", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "retExpChange", "varAdd"], "repairPatterns": ["copyPaste", "expLogicMod", "wrapsIfElse", "wrongComp"]}
{"project": "Mockito", "bugId": 30, "problem": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n                 return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\r\n             }\r\n            new Reporter().smartNullPointerException(location);\r\n             return null;\r\n         }\r", "fixed": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n                 return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\r\n             }\r\n            new Reporter().smartNullPointerException(obj, location);\r\n             return null;\r\n         }\r", "observations": "Adds new parameter to method signature, ajust code.", "repairActions": ["mcParAdd", "mcRepl", "mdParAdd", "objInstMod"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Lang", "bugId": 28, "problem": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 return 0;\n             }\n                 out.write(entityValue);\n             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;", "fixed": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 return 0;\n             }\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                 out.write(entityValue);\n            }\n             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "varAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Lang", "bugId": 63, "problem": " public static String formatPeriod(long startMillis, long endMillis, String forma\n             days -= 1;\n         }\n         while (days < 0) {\n            days += 31;\n             months -= 1;\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);", "fixed": " public static String formatPeriod(long startMillis, long endMillis, String forma\n             days -= 1;\n         }\n         while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n             months -= 1;\n            end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }", "observations": "", "repairActions": ["assignExpChange", "assignRem", "condBranRem", "mcAdd", "mcRem", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "fixAPI", "wrongComp"]}
{"project": "Closure", "bugId": 47, "problem": " private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n       Builder x = OriginalMapping.newBuilder()\n         .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n       if (entry.getNameId() != UNMAPPED) {\n         x.setIdentifier(names[entry.getNameId()]);\n       }", "fixed": " private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n       Builder x = OriginalMapping.newBuilder()\n         .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine() + 1)\n        .setColumnPosition(entry.getSourceColumn() + 1);\n       if (entry.getNameId() != UNMAPPED) {\n         x.setIdentifier(names[entry.getNameId()]);\n       }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcParValChange", "objInstMod", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "initFix"]}
{"project": "Time", "bugId": 26, "problem": " public long addWrapField(long instant, int value) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +", "fixed": " public long addWrapField(long instant, int value) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.addWrapField(localInstant, value);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 68, "problem": " private Node parseFunctionType(JsDocToken token) {\n     if (token != JsDocToken.LP) {\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }", "fixed": " private Node parseFunctionType(JsDocToken token) {\n     if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }", "observations": "An assignment was moved outside a branch.", "repairActions": ["mcAdd"], "repairPatterns": ["codeMove", "copyPaste", "missComp", "unwrapIfElse"]}
{"project": "Time", "bugId": 26, "problem": " public long roundFloor(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }", "fixed": " public long roundFloor(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundFloor(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Time", "bugId": 27, "problem": " private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no\n         int size = elementPairs.size();\n         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n             Separator sep = (Separator) elementPairs.get(0);\n                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                 sep = sep.finish(f.getPrinter(), f.getParser());\n                 return new PeriodFormatter(sep, sep);\n         }\n         Object[] comp = createComposite(elementPairs);\n         if (notPrinter) {", "fixed": " private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no\n         int size = elementPairs.size();\n         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n             Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                 sep = sep.finish(f.getPrinter(), f.getParser());\n                 return new PeriodFormatter(sep, sep);\n            }\n         }\n         Object[] comp = createComposite(elementPairs);\n         if (notPrinter) {", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckP", "wrapsIf"]}
{"project": "Closure", "bugId": 80, "problem": " static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n       case Token.OBJECTLIT:\n         return true;\n       case Token.IN:\n         return true;", "fixed": " static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n       case Token.OBJECTLIT:\n         return true;\n      case Token.DELPROP:\n       case Token.IN:\n         return true;", "observations": "These blocks are inserted as extra switch clauses. Should be a \"Missing Condition\", \"Missing Block\" or both?", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["expLogicExpand"]}
{"project": "Lang", "bugId": 61, "problem": " public int indexOf(String str, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {", "fixed": " public int indexOf(String str, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        int len = size - strLen + 1;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {", "observations": "Changes/fix computing of a variable.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["expArithMod", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 82, "problem": " private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;", "fixed": " private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;", "observations": "Changes operator in condition.", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Time", "bugId": 6, "problem": " public static synchronized GJChronology getInstance(\n             cutoverInstant = DEFAULT_CUTOVER;\n         } else {\n             cutoverInstant = gregorianCutover.toInstant();\n         }\n         GJChronology chrono;", "fixed": " public static synchronized GJChronology getInstance(\n             cutoverInstant = DEFAULT_CUTOVER;\n         } else {\n             cutoverInstant = gregorianCutover.toInstant();\n            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n            if (cutoverDate.getYear() <= 0) {\n                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n            }\n         }\n         GJChronology chrono;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "exThrowsAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Math", "bugId": 11, "problem": " public double density(final double[] vals) throws DimensionMismatchException {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }", "fixed": " public double density(final double[] vals) throws DimensionMismatchException {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }", "observations": "", "repairActions": ["mcParValChange", "retExpChange"], "repairPatterns": ["expArithMod", "singleLine"]}
{"project": "Lang", "bugId": 32, "problem": "      * \n      * @since 2.3\n      */\n    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n        @Override\n        protected Set<IDKey> initialValue() {\n            return new HashSet<IDKey>();\n        }\n    };\n     /*\n      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()", "fixed": "      * \n      * @since 2.3\n      */\n    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n     /*\n      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()", "observations": "Applies null check using synchronized block with object lock (HashCodeBuilder.class)", "repairActions": ["condBranIfAdd", "mcAdd", "mdOverride", "mdRem", "objInstMod", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP"]}
{"project": "Lang", "bugId": 21, "problem": " public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&", "fixed": " public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&", "observations": "", "repairActions": ["mcParValChange", "retExpChange", "varReplVar"], "repairPatterns": ["constChange", "expLogicMod", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 50, "problem": " protected final double doSolve() {\n                     break;\n                 case REGULA_FALSI:\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                     break;\n                 default:", "fixed": " protected final double doSolve() {\n                     break;\n                 case REGULA_FALSI:\n                     break;\n                 default:", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Closure", "bugId": 26, "problem": " private String normalizeSourceName(String filename) {\n       AbstractPostOrderCallback {\n     private int scriptNodeCount = 0;\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {", "fixed": " private String normalizeSourceName(String filename) {\n       AbstractPostOrderCallback {\n     private int scriptNodeCount = 0;\n    private Set<String> modulesWithExports = Sets.newHashSet();\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 16, "problem": " public static double sinh(double x) {\n       if (x > 20) {\n               return 0.5 * exp(x);\n           }\n      if (x < -20) {\n               return -0.5 * exp(-x);\n       }\n       if (x == 0) {", "fixed": " public static double sinh(double x) {\n       if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n               return 0.5 * exp(x);\n           }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n               return -0.5 * exp(-x);\n          }\n       }\n       if (x == 0) {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Closure", "bugId": 100, "problem": " private boolean shouldReportThis(Node n, Node parent) {\n     }\n    return false;\n   }\n   /**", "fixed": " private boolean shouldReportThis(Node n, Node parent) {\n     }\n    return parent != null && NodeUtil.isGet(parent);\n   }\n   /**", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrongComp"]}
{"project": "Closure", "bugId": 18, "problem": " Node parseInputs() {\n       boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n         for (CompilerInput input : inputs) {", "fixed": " Node parseInputs() {\n       boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {", "observations": "", "repairActions": ["condExpRed"], "repairPatterns": ["expLogicReduce", "singleLine"]}
{"project": "Closure", "bugId": 50, "problem": " private Node tryFoldArrayJoin(Node n) {\n     Node right = callTarget.getNext();\n     if (right != null) {\n      if (!NodeUtil.isImmutableValue(right)) {\n         return n;\n       }\n     }", "fixed": " private Node tryFoldArrayJoin(Node n) {\n     Node right = callTarget.getNext();\n     if (right != null) {\n      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n         return n;\n       }\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN"]}
{"project": "Lang", "bugId": 32, "problem": " static void register(Object value) {\n      * @since 2.3\n      */\n     static void unregister(Object value) {\n        getRegistry().remove(new IDKey(value));\n     }\n     /**", "fixed": " static void register(Object value) {\n      * @since 2.3\n      */\n     static void unregister(Object value) {\n        Set<IDKey> s = getRegistry();\n        if (s != null) {\n            s.remove(new IDKey(value));\n            synchronized (HashCodeBuilder.class) {\n                if (s.isEmpty()) {\n                    REGISTRY.remove();\n                }\n            }\n        }\n     }\n     /**", "observations": "Applies null check using synchronized block with object lock (HashCodeBuilder.class)", "repairActions": ["condBranIfAdd", "mcAdd", "mdOverride", "mdRem", "objInstMod", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP"]}
{"project": "Mockito", "bugId": 38, "problem": " private boolean safelyMatches(Matcher m, Object arg) {\n     }\r\n     private boolean toStringEquals(Matcher m, Object arg) {\r\n        return StringDescription.toString(m).equals(arg.toString());\r\n     }\r\n }\r", "fixed": " private boolean safelyMatches(Matcher m, Object arg) {\n     }\r\n     private boolean toStringEquals(Matcher m, Object arg) {\r\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\r\n     }\r\n }\r", "observations": "", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckP", "singleLine", "wrapsIfElse"]}
{"project": "Math", "bugId": 35, "problem": " public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n        this.elitismRate = elitismRate;\n     }\n     /**", "fixed": " public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n        setElitismRate(elitismRate);\n     }\n     /**", "observations": "Similar to Math-34", "repairActions": ["assignRem", "mcAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrapsMethod", "wrongVarRef"]}
{"project": "Closure", "bugId": 75, "problem": " static Double getNumberValue(Node n) {\n   }\n   static Double getStringNumberValue(String rawJsString) {\n     String s = trimJsWhiteSpace(rawJsString);", "fixed": " static Double getNumberValue(Node n) {\n   }\n   static Double getStringNumberValue(String rawJsString) {\n    if (rawJsString.contains(\"\\u000b\")) {\n      return null;\n    }\n     String s = trimJsWhiteSpace(rawJsString);", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd", "retExpChange", "varReplVar"], "repairPatterns": ["condBlockRetAdd", "constChange", "wrongVarRef"]}
{"project": "Mockito", "bugId": 26, "problem": " public static boolean isPrimitiveWrapper(Class<?> type) {\n         primitiveValues.put(int.class, 0);\r\n         primitiveValues.put(long.class, 0L);\r\n         primitiveValues.put(float.class, 0F);\r\n        primitiveValues.put(double.class, 0);\r\n     }\r\n }\n\\ No newline at end of file", "fixed": " public static boolean isPrimitiveWrapper(Class<?> type) {\n         primitiveValues.put(int.class, 0);\r\n         primitiveValues.put(long.class, 0L);\r\n         primitiveValues.put(float.class, 0F);\r\n        primitiveValues.put(double.class, 0D);\r\n     }\r\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine", "wrongComp"]}
{"project": "Closure", "bugId": 128, "problem": " private void unrollBinaryOperator(\n   static boolean isSimpleNumber(String s) {\n     int len = s.length();\n     for (int index = 0; index < len; index++) {\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n    return len > 0 && s.charAt(0) != '0';\n   }\n   static double getSimpleNumber(String s) {", "fixed": " private void unrollBinaryOperator(\n   static boolean isSimpleNumber(String s) {\n     int len = s.length();\n    if (len == 0) {\n      return false;\n    }\n     for (int index = 0; index < len; index++) {\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n    return len == 1 || s.charAt(0) != '0';\n   }\n   static double getSimpleNumber(String s) {", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockRetAdd", "expLogicMod"]}
{"project": "Lang", "bugId": 32, "problem": "      * @since 2.3\n      */\n     static boolean isRegistered(Object value) {\n        return getRegistry().contains(new IDKey(value));\n     }\n     /**", "fixed": "      * @since 2.3\n      */\n     static boolean isRegistered(Object value) {\n        Set<IDKey> registry = getRegistry();\n        return registry != null && registry.contains(new IDKey(value));\n     }\n     /**", "observations": "Applies null check using synchronized block with object lock (HashCodeBuilder.class)", "repairActions": ["condBranIfAdd", "mcAdd", "mdOverride", "mdRem", "objInstMod", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP"]}
{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n         double w = x;\n         double d = 0;\n         double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n        int count = 0;\n        while (count < maximalIterationCount) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;", "fixed": " private double localMin(boolean isMinim,\n         double w = x;\n         double d = 0;\n         double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n        while (true) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 6, "problem": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n           \"assignment to property \" + propName + \" of \" +\n           getReadableJSTypeName(owner, true),\n           rightType, leftType);\n      }\n       return false;\n     }\n     return true;", "fixed": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n           \"assignment to property \" + propName + \" of \" +\n           getReadableJSTypeName(owner, true),\n           rightType, leftType);\n       return false;\n     }\n     return true;", "observations": "", "repairActions": ["condBranRem", "mcRem"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Math", "bugId": 100, "problem": " public double getChiSquare(EstimationProblem problem) {\n     public double[] guessParametersErrors(EstimationProblem problem)\n       throws EstimationException {\n         int m = problem.getMeasurements().length;\n        int p = problem.getAllParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                           new Object[] { new Integer(m), new Integer(p)});\n         }\n        double[] errors = new double[problem.getAllParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n         double[][] covar = getCovariances(problem);\n         for (int i = 0; i < errors.length; ++i) {", "fixed": " public double getChiSquare(EstimationProblem problem) {\n     public double[] guessParametersErrors(EstimationProblem problem)\n       throws EstimationException {\n         int m = problem.getMeasurements().length;\n        int p = problem.getUnboundParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                           new Object[] { new Integer(m), new Integer(p)});\n         }\n        double[] errors = new double[problem.getUnboundParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n         double[][] covar = getCovariances(problem);\n         for (int i = 0; i < errors.length; ++i) {", "observations": "Apply the same replace of methods in three different places.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Lang", "bugId": 27, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;", "observations": "", "repairActions": ["condExpExpand", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "expLogicExpand"]}
{"project": "Mockito", "bugId": 10, "problem": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n         return recordDeepStubAnswer(\r\n                newDeepStubMock(returnTypeGenericMetadata),\r\n                 container\r\n         );\r\n     }\r", "fixed": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n         return recordDeepStubAnswer(\r\n                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\r\n                 container\r\n         );\r\n     }\r", "observations": "Changes signature of existent methods, adding new params.", "repairActions": ["mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Math", "bugId": 84, "problem": " protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 return;\n             }", "fixed": " protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                return;\n            }\n            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {\n                 return;\n             }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 118, "problem": " private void handleObjectLit(NodeTraversal t, Node n) {\n           child != null;\n           child = child.getNext()) {\n         String name = child.getString();", "fixed": " private void handleObjectLit(NodeTraversal t, Node n) {\n           child != null;\n           child = child.getNext()) {\n        if (child.isQuotedString()) {\n          continue;\n        }\n         String name = child.getString();", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Time", "bugId": 9, "problem": " public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n         if (hoursOffset == 0 && minutesOffset == 0) {\n             return DateTimeZone.UTC;\n         }\n         if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n         int offset = 0;\n         try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n             if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n             } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {", "fixed": " public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n         if (hoursOffset == 0 && minutesOffset == 0) {\n             return DateTimeZone.UTC;\n         }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n         if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n         int offset = 0;\n         try {\n            int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - minutesOffset;\n             } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {", "observations": "", "repairActions": ["assignExpChange", "condBranIfAdd", "exThrowsAdd", "mcRem", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "expArithMod"]}
{"project": "Time", "bugId": 22, "problem": " protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n        this(duration, null, null);\n     }\n     /**", "fixed": " protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n        super();\n        iType = PeriodType.time();\n        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n        iType = PeriodType.standard();\n        iValues = new int[8];\n        System.arraycopy(values, 0, iValues, 4, 4);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "varAdd"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Closure", "bugId": 119, "problem": " public void collect(JSModule module, Scope scope, Node n) {\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;", "fixed": " public void collect(JSModule module, Scope scope, Node n) {\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n              case Token.CATCH:\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;", "observations": "\"Case\" Added to switch... Should be considered a \"missing block\" too?", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Mockito", "bugId": 3, "problem": " public void captureArgumentsFrom(Invocation invocation) {\n                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                 }\n             }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                 }\n             }\n         } else {", "fixed": " public void captureArgumentsFrom(Invocation invocation) {\n                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                 }\n             }\n            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {\n                 if (m instanceof CapturesArguments) {\n                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];\n                    for (int i = 0; i < Array.getLength(rawArgument); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));\n                    }\n                 }\n             }\n         } else {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "loopCondChange", "mcAdd", "mcRem", "mdAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "wrongComp"]}
{"project": "Mockito", "bugId": 2, "problem": " package org.mockito.internal.util;\n public class Timer {", "fixed": " package org.mockito.internal.util;\nimport org.mockito.exceptions.Reporter;\n public class Timer {", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Lang", "bugId": 46, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n                             out.write('\\\\');\n                         out.write('/');\n                         break;\n                     default :", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n                        if (escapeForwardSlash) {\n                             out.write('\\\\');\n                        }\n                         out.write('/');\n                         break;\n                     default :", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Chart", "bugId": 1, "problem": " public LegendItemCollection getLegendItems() {\n         }\r\n         int index = this.plot.getIndexOf(this);\r\n         CategoryDataset dataset = this.plot.getDataset(index);\r\n        if (dataset != null) {\r\n             return result;\r\n         }\r\n         int seriesCount = dataset.getRowCount();\r", "fixed": " public LegendItemCollection getLegendItems() {\n         }\r\n         int index = this.plot.getIndexOf(this);\r\n         CategoryDataset dataset = this.plot.getDataset(index);\r\n        if (dataset == null) {\r\n             return result;\r\n         }\r\n         int seriesCount = dataset.getRowCount();\r", "observations": "Change Operator", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 41, "problem": " FunctionTypeBuilder inferFromOverriddenFunction(\n       }\n       parametersNode = paramBuilder.build();\n     }", "fixed": " FunctionTypeBuilder inferFromOverriddenFunction(\n       }\n      while (oldParams.hasNext()) {\n        paramBuilder.newParameterFromNode(oldParams.next());\n      }\n       parametersNode = paramBuilder.build();\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Math", "bugId": 78, "problem": " public boolean evaluateStep(final StepInterpolator interpolator)\n                     increasing = gb >= ga;", "fixed": " public boolean evaluateStep(final StepInterpolator interpolator)\n                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                            ta += epsilon;\n                            interpolator.setInterpolatedTime(ta);\n                            ga = handler.g(ta, interpolator.getInterpolatedState());\n                        }\n                        if (ga * gb > 0) {\n                            throw MathRuntimeException.createInternalError(null);\n                        }\n                    }\n                     increasing = gb >= ga;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp"]}
{"project": "Mockito", "bugId": 8, "problem": " protected void registerTypeVariablesOn(Type classType) {\n             if (actualTypeArgument instanceof WildcardType) {\r\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n            } else {\r\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n             }\r", "fixed": " protected void registerTypeVariablesOn(Type classType) {\n             if (actualTypeArgument instanceof WildcardType) {\r\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n            } else if (typeParameter != actualTypeArgument) {\r\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n             }\r", "observations": "Replaced and \"else\" with an \"else if\"", "repairActions": ["condBranIfAdd"], "repairPatterns": ["singleLine", "wrapsIf"]}
{"project": "Closure", "bugId": 11, "problem": " private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (n.getJSType() != null && parent.isAssign()) {\n      return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);", "fixed": " private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);", "observations": "", "repairActions": ["condBranRem", "mcRem", "retRem"], "repairPatterns": ["condBlockRem"]}
