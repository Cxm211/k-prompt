{"project": "Closure", "bugId": 27, "problem": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isLabelName());\n    Preconditions.checkState(finallyBody.isLabelName());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "fixed": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Chart", "bugId": 22, "problem": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n        if (row >= 0) {\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n         }\r\n         else {\r\n             return null;\r", "fixed": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n        int index = rowData.getIndex(columnKey);\r\n        if (index >= 0) {\r\n            return rowData.getObject(index);\r\n         }\r\n         else {\r\n             return null;\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Mockito", "bugId": 27, "problem": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\r\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "fixed": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "observations": "", "repairActions": ["assignExpChange", "mcAdd", "mcRem", "objInstRem", "varRem"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Chart", "bugId": 22, "problem": " public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n                rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r", "fixed": " public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n            int i = rowData.getIndex(columnKey);\r\n            if (i >= 0) {\r\n                rowData.removeValue(i);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {", "fixed": " private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Lang", "bugId": 19, "problem": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n             }\n             int end = start;\n            while(input.charAt(end) != ';') \n             {\n                 end++;\n             }", "fixed": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n                if(start == seqEnd) {\n                    return 0;\n                }\n             }\n             int end = start;\n            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n             {\n                 end++;\n             }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Lang", "bugId": 52, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                     default :\n                         out.write(ch);\n                         break;", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                     default :\n                         out.write(ch);\n                         break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 90, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n     /**\n      * Adds 1 to the frequency count for v.", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        addValue((Comparable<?>) v);\n    }\n     /**\n      * Adds 1 to the frequency count for v.", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Chart", "bugId": 12, "problem": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        this.dataset = dataset;\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "fixed": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        setDataset(dataset);\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "observations": "It involves a \"wrap with method\", but the real change is converting from a class attribute assignment to a \"set\" method call.", "repairActions": ["assignRem", "mcAdd", "varReplMc"], "repairPatterns": ["singleLine", "wrapsMethod", "wrongVarRef"]}
{"project": "Lang", "bugId": 4, "problem": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "fixed": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq.toString());\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
