{"scenario": "valgrind-bug-12854-12855.tar.gz", "repairActions": [], "lines": 4, "problem": " \"                              stated shared object doesn't have the stated\\n\"\n \"                              text symbol.  Patterns can contain ? and *.\\n\"\n \"    --soname-synonyms=syn1=pattern1,syn2=pattern2,... synonym soname\\n\"\n\"                              patterns for some Valgrind wrapping\\n\"\n\"                              or replacement (such as malloc replacement)\\n\"\n \"\\n\";\n Char* usage2 =\n \"\\n\"", "fixed": " \"                              stated shared object doesn't have the stated\\n\"\n \"                              text symbol.  Patterns can contain ? and *.\\n\"\n \"    --soname-synonyms=syn1=pattern1,syn2=pattern2,... synonym soname\\n\"\n\"              specify patterns for function wrapping or replacement.\\n\"\n\"              To use a non-libc malloc library that is\\n\"\n\"                  in the main exe:  --soname-synonyms=somalloc=NONE\\n\"\n\"                  in libxyzzy.so:   --soname-synonyms=somalloc=libxyzzy.so\\n\"\n \"\\n\";\n Char* usage2 =\n \"\\n\""}
{"scenario": "php-bug-2011-11-04-9da01ac6b6-7334dfd7eb.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 10, "problem": " }\n if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {\n if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\n do_inheritance_check_on_method(fn, other_trait_fn TSRMLS_CC);\n zend_function_dtor(other_trait_fn);\n zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n } else {", "fixed": " }\n if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {\n if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\nif (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\nif (   !zend_do_perform_implementation_check(fn, other_trait_fn TSRMLS_CC)\n|| !zend_do_perform_implementation_check(other_trait_fn, fn TSRMLS_CC)) {\nzend_get_function_declaration(fn TSRMLS_CC),\nzend_get_function_declaration(other_trait_fn TSRMLS_CC));\n}\n}\nelse {\n do_inheritance_check_on_method(fn, other_trait_fn TSRMLS_CC);\n}\n zend_function_dtor(other_trait_fn);\n zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n } else {"}
{"scenario": "wireshark-bug-37122-37123.tar.gz", "repairActions": ["Changes Method Signature", "Changes Condition"], "lines": 35, "problem": " return fd_head;\n }\n static gboolean\nfree_all_reassembled_fragments(gpointer key_arg, gpointer value,\n gpointer user_data _U_)\n {\nfragment_data *fd_head, *tmp_fd;\nreassembled_key *key = (reassembled_key *)key_arg;\nfor (fd_head = value; fd_head != NULL; fd_head = tmp_fd) {\ntmp_fd=fd_head->next;\n if(fd_head->data && !(fd_head->flags&FD_NOT_MALLOCED)) {\n g_free(fd_head->data);\n fd_head->data = NULL;\n }\nif(key->frame == fd_head->reassembled_in){\ng_slice_free(fragment_data, fd_head);\n }\n}\n return TRUE;\n }\n }\n }\nstatic void\nreassembled_key_free(void *ptr)\n{\nreassembled_key *key = (reassembled_key *)ptr;\ng_slice_free(reassembled_key, key);\n}\n void\n fragment_table_init(GHashTable **fragment_table)\n {\n g_hash_table_foreach_remove(*reassembled_table,\n free_all_reassembled_fragments, NULL);\n } else {\n*reassembled_table = g_hash_table_new_full(reassembled_hash,\nreassembled_equal, reassembled_key_free, NULL);\n *reassembled_table = g_hash_table_new(reassembled_hash,\n reassembled_equal);\n }\n }\n void\n reassembled_key *new_key;\n fragment_data *fd;\n if (fd_head->next == NULL) {\nnew_key = g_slice_new(reassembled_key);\n new_key = se_alloc(sizeof(reassembled_key));\n new_key->frame = pinfo->fd->num;\n new_key->id = id;\n g_hash_table_insert(reassembled_table, new_key, fd_head);\n } else {\n for (fd = fd_head->next; fd != NULL; fd = fd->next){\nnew_key = g_slice_new(reassembled_key);\n new_key = se_alloc(sizeof(reassembled_key));\n new_key->frame = fd->frame;\n new_key->id = id;\n g_hash_table_insert(reassembled_table, new_key,\n }\n fragment_reassembled(fd_head, pinfo, reassembled_table, id);\n if (fd_head->next != NULL) {\nnew_key = g_slice_new(reassembled_key);\n new_key = se_alloc(sizeof(reassembled_key));\n new_key->frame = pinfo->fd->num;\n new_key->id = id;\n g_hash_table_insert(reassembled_table, new_key, fd_head);", "fixed": " return fd_head;\n }\n static gboolean\nfree_all_reassembled_fragments(gpointer key_arg _U_, gpointer value,\n gpointer user_data _U_)\n {\nfragment_data *fd_head;\nfor (fd_head = value; fd_head != NULL; fd_head = fd_head->next) {\n if(fd_head->data && !(fd_head->flags&FD_NOT_MALLOCED)) {\n g_free(fd_head->data);\n fd_head->data = NULL;\n }\n }\n return TRUE;\n }\n }\n }\n void\n fragment_table_init(GHashTable **fragment_table)\n {\n g_hash_table_foreach_remove(*reassembled_table,\n free_all_reassembled_fragments, NULL);\n } else {\n *reassembled_table = g_hash_table_new(reassembled_hash,\n reassembled_equal);\n }\n }\n void\n reassembled_key *new_key;\n fragment_data *fd;\n if (fd_head->next == NULL) {\n new_key = se_alloc(sizeof(reassembled_key));\n new_key->frame = pinfo->fd->num;\n new_key->id = id;\n g_hash_table_insert(reassembled_table, new_key, fd_head);\n } else {\n for (fd = fd_head->next; fd != NULL; fd = fd->next){\n new_key = se_alloc(sizeof(reassembled_key));\n new_key->frame = fd->frame;\n new_key->id = id;\n g_hash_table_insert(reassembled_table, new_key,\n }\n fragment_reassembled(fd_head, pinfo, reassembled_table, id);\n if (fd_head->next != NULL) {\n new_key = se_alloc(sizeof(reassembled_key));\n new_key->frame = pinfo->fd->num;\n new_key->id = id;\n g_hash_table_insert(reassembled_table, new_key, fd_head);"}
{"scenario": "wireshark-bug-37284-37285.tar.gz", "repairActions": [], "lines": 3, "problem": " static GAsyncQueue *pcap_queue;\n static gint64 pcap_queue_bytes;\n static gint64 pcap_queue_packets;\nstatic gint64 pcap_queue_byte_limit = 1000000;\nstatic gint64 pcap_queue_packet_limit = 1;\n static gboolean capture_child = FALSE;\n static gchar *sig_pipe_name = NULL;", "fixed": " static GAsyncQueue *pcap_queue;\n static gint64 pcap_queue_bytes;\n static gint64 pcap_queue_packets;\nstatic gint64 pcap_queue_byte_limit = 1024 * 1024;\nstatic gint64 pcap_queue_packet_limit = 1000;\n static gboolean capture_child = FALSE;\n static gchar *sig_pipe_name = NULL;"}
{"scenario": "php-bug-2011-03-27-2191af9546-b83e243c23.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable", "Adds Method"], "lines": 112, "problem": " PHPAPI zend_class_entry *spl_ce_RecursiveIterator;\n PHPAPI zend_class_entry *spl_ce_RecursiveIteratorIterator;\n PHPAPI zend_class_entry *spl_ce_FilterIterator;\n PHPAPI zend_class_entry *spl_ce_RecursiveFilterIterator;\n PHPAPI zend_class_entry *spl_ce_ParentIterator;\n PHPAPI zend_class_entry *spl_ce_SeekableIterator;\n PHPAPI zend_class_entry *spl_ce_LimitIterator;\n break;\n }\n default:\n if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &zobject, ce_inner) == FAILURE) {\n zend_restore_error_handling(&error_handling TSRMLS_CC);\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_FilterIterator, zend_ce_iterator, DIT_FilterIterator);\n }\n SPL_METHOD(dual_it, getInnerIterator)\n {\n spl_dual_it_object   *intern;\n intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n spl_filter_it_next(getThis(), intern TSRMLS_CC);\n }\n SPL_METHOD(RecursiveFilterIterator, __construct)\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RecursiveFilterIterator, spl_ce_RecursiveIterator, DIT_RecursiveFilterIterator);\n zval_ptr_dtor(&retval);\n }\n }\n SPL_METHOD(ParentIterator, __construct)\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_ParentIterator, spl_ce_RecursiveIterator, DIT_ParentIterator);\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RegexIterator, zend_ce_iterator, DIT_RegexIterator);\n }\n SPL_METHOD(RegexIterator, accept)\n {\n spl_dual_it_object *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n }\n }\n zend_object_std_dtor(&object->std TSRMLS_CC);\n efree(object);\n }\n SPL_ABSTRACT_ME(FilterIterator, accept,   arginfo_recursive_it_void)\n {NULL, NULL, NULL}\n };\n ZEND_BEGIN_ARG_INFO(arginfo_parent_it___construct, 0)\n ZEND_ARG_OBJ_INFO(0, iterator, RecursiveIterator, 0)\n ZEND_END_ARG_INFO();\n spl_ce_FilterIterator->ce_flags |= ZEND_ACC_EXPLICIT_ABSTRACT_CLASS;\n REGISTER_SPL_SUB_CLASS_EX(RecursiveFilterIterator, FilterIterator, spl_dual_it_new, spl_funcs_RecursiveFilterIterator);\n REGISTER_SPL_IMPLEMENTS(RecursiveFilterIterator, RecursiveIterator);\n REGISTER_SPL_SUB_CLASS_EX(ParentIterator, RecursiveFilterIterator, spl_dual_it_new, spl_funcs_ParentIterator);\n REGISTER_SPL_INTERFACE(Countable);\n REGISTER_SPL_INTERFACE(SeekableIterator);", "fixed": " PHPAPI zend_class_entry *spl_ce_RecursiveIterator;\n PHPAPI zend_class_entry *spl_ce_RecursiveIteratorIterator;\n PHPAPI zend_class_entry *spl_ce_FilterIterator;\nPHPAPI zend_class_entry *spl_ce_CallbackFilterIterator;\n PHPAPI zend_class_entry *spl_ce_RecursiveFilterIterator;\nPHPAPI zend_class_entry *spl_ce_RecursiveCallbackFilterIterator;\n PHPAPI zend_class_entry *spl_ce_ParentIterator;\n PHPAPI zend_class_entry *spl_ce_SeekableIterator;\n PHPAPI zend_class_entry *spl_ce_LimitIterator;\n break;\n }\ncase DIT_CallbackFilterIterator:\ncase DIT_RecursiveCallbackFilterIterator: {\n_spl_cbfilter_it_intern *cfi = emalloc(sizeof(*cfi));\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Of\", &zobject, ce_inner, &cfi->fci, &cfi->fcc) == FAILURE) {\nzend_restore_error_handling(&error_handling TSRMLS_CC);\nefree(cfi);\nreturn NULL;\n}\nif (cfi->fci.function_name) {\nZ_ADDREF_P(cfi->fci.function_name);\n}\nif (cfi->fci.object_ptr) {\nZ_ADDREF_P(cfi->fci.object_ptr);\n}\nintern->u.cbfilter = cfi;\nbreak;\n}\n default:\n if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &zobject, ce_inner) == FAILURE) {\n zend_restore_error_handling(&error_handling TSRMLS_CC);\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_FilterIterator, zend_ce_iterator, DIT_FilterIterator);\n }\nSPL_METHOD(CallbackFilterIterator, __construct)\n{\nspl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_CallbackFilterIterator, zend_ce_iterator, DIT_CallbackFilterIterator);\n}\n SPL_METHOD(dual_it, getInnerIterator)\n {\n spl_dual_it_object   *intern;\n intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n spl_filter_it_next(getThis(), intern TSRMLS_CC);\n }\nSPL_METHOD(RecursiveCallbackFilterIterator, __construct)\n{\nspl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RecursiveCallbackFilterIterator, spl_ce_RecursiveIterator, DIT_RecursiveCallbackFilterIterator);\n}\n SPL_METHOD(RecursiveFilterIterator, __construct)\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RecursiveFilterIterator, spl_ce_RecursiveIterator, DIT_RecursiveFilterIterator);\n zval_ptr_dtor(&retval);\n }\n }\nSPL_METHOD(RecursiveCallbackFilterIterator, getChildren)\n{\nspl_dual_it_object   *intern;\nzval                 *retval;\nif (zend_parse_parameters_none() == FAILURE) {\nreturn;\n}\nintern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\nzend_call_method_with_0_params(&intern->inner.zobject, intern->inner.ce, NULL, \"getchildren\", &retval);\nif (!EG(exception) && retval) {\nspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, retval, intern->u.cbfilter->fci.function_name TSRMLS_CC);\n}\nif (retval) {\nzval_ptr_dtor(&retval);\n}\n}\n SPL_METHOD(ParentIterator, __construct)\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_ParentIterator, spl_ce_RecursiveIterator, DIT_ParentIterator);\n {\n spl_dual_it_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, spl_ce_RegexIterator, zend_ce_iterator, DIT_RegexIterator);\n }\nSPL_METHOD(CallbackFilterIterator, accept)\n{\nspl_dual_it_object     *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\nzend_fcall_info        *fci = &intern->u.cbfilter->fci;\nzend_fcall_info_cache  *fcc = &intern->u.cbfilter->fcc;\nzval                  **params[3];\nzval                    zkey;\nzval                   *zkey_p = &zkey;\nzval                   *result;\nif (zend_parse_parameters_none() == FAILURE) {\nreturn;\n}\nif (intern->current.data == NULL) {\nRETURN_FALSE;\n}\nINIT_PZVAL(&zkey);\nif (intern->current.key_type == HASH_KEY_IS_LONG) {\nZVAL_LONG(&zkey, intern->current.int_key);\n} else {\nZVAL_STRINGL(&zkey, intern->current.str_key, intern->current.str_key_len-1, 0);\n}\nparams[0] = &intern->current.data;\nparams[1] = &zkey_p;\nparams[2] = &intern->inner.zobject;\nfci->retval_ptr_ptr = &result;\nfci->param_count = 3;\nfci->params = params;\nfci->no_separation = 0;\nif (zend_call_function(fci, fcc TSRMLS_CC) != SUCCESS || !result) {\nRETURN_FALSE;\n}\nif (EG(exception)) {\nreturn;\n}\nRETURN_ZVAL(result, 1, 1);\n}\n SPL_METHOD(RegexIterator, accept)\n {\n spl_dual_it_object *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n }\n }\nif (object->dit_type == DIT_CallbackFilterIterator || object->dit_type == DIT_RecursiveCallbackFilterIterator) {\nif (object->u.cbfilter) {\nif (object->u.cbfilter->fci.function_name) {\nzval_ptr_dtor(&object->u.cbfilter->fci.function_name);\n}\nif (object->u.cbfilter->fci.object_ptr) {\nzval_ptr_dtor(&object->u.cbfilter->fci.object_ptr);\n}\nefree(object->u.cbfilter);\n}\n}\n zend_object_std_dtor(&object->std TSRMLS_CC);\n efree(object);\n }\n SPL_ABSTRACT_ME(FilterIterator, accept,   arginfo_recursive_it_void)\n {NULL, NULL, NULL}\n };\nZEND_BEGIN_ARG_INFO(arginfo_callback_filter_it___construct, 0)\nZEND_ARG_OBJ_INFO(0, iterator, Iterator, 0)\nZEND_ARG_INFO(0, callback)\nZEND_END_ARG_INFO();\nstatic const zend_function_entry spl_funcs_CallbackFilterIterator[] = {\nSPL_ME(CallbackFilterIterator, __construct, arginfo_callback_filter_it___construct, ZEND_ACC_PUBLIC)\nSPL_ME(CallbackFilterIterator, accept,      arginfo_recursive_it_void, ZEND_ACC_PUBLIC)\n{NULL, NULL, NULL}\n};\nZEND_BEGIN_ARG_INFO(arginfo_recursive_callback_filter_it___construct, 0)\nZEND_ARG_OBJ_INFO(0, iterator, RecursiveIterator, 0)\nZEND_ARG_INFO(0, callback)\nZEND_END_ARG_INFO();\nstatic const zend_function_entry spl_funcs_RecursiveCallbackFilterIterator[] = {\nSPL_ME(RecursiveCallbackFilterIterator, __construct, arginfo_recursive_callback_filter_it___construct, ZEND_ACC_PUBLIC)\nSPL_ME(RecursiveFilterIterator,  hasChildren,      arginfo_recursive_it_void, ZEND_ACC_PUBLIC)\nSPL_ME(RecursiveCallbackFilterIterator,  getChildren,      arginfo_recursive_it_void, ZEND_ACC_PUBLIC)\n{NULL, NULL, NULL}\n};\n ZEND_BEGIN_ARG_INFO(arginfo_parent_it___construct, 0)\n ZEND_ARG_OBJ_INFO(0, iterator, RecursiveIterator, 0)\n ZEND_END_ARG_INFO();\n spl_ce_FilterIterator->ce_flags |= ZEND_ACC_EXPLICIT_ABSTRACT_CLASS;\n REGISTER_SPL_SUB_CLASS_EX(RecursiveFilterIterator, FilterIterator, spl_dual_it_new, spl_funcs_RecursiveFilterIterator);\n REGISTER_SPL_IMPLEMENTS(RecursiveFilterIterator, RecursiveIterator);\nREGISTER_SPL_SUB_CLASS_EX(CallbackFilterIterator, FilterIterator, spl_dual_it_new, spl_funcs_CallbackFilterIterator);\nREGISTER_SPL_SUB_CLASS_EX(RecursiveCallbackFilterIterator, CallbackFilterIterator, spl_dual_it_new, spl_funcs_RecursiveCallbackFilterIterator);\nREGISTER_SPL_IMPLEMENTS(RecursiveCallbackFilterIterator, RecursiveIterator);\n REGISTER_SPL_SUB_CLASS_EX(ParentIterator, RecursiveFilterIterator, spl_dual_it_new, spl_funcs_ParentIterator);\n REGISTER_SPL_INTERFACE(Countable);\n REGISTER_SPL_INTERFACE(SeekableIterator);"}
{"scenario": "php-bug-2011-10-31-2e5d5e5ac6-b5f15ef561.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 5, "problem": " void zend_do_implements_trait(znode *trait_name TSRMLS_DC)\n {\n zend_op *opline;\n switch (zend_get_class_fetch_type(Z_STRVAL(trait_name->u.constant), Z_STRLEN(trait_name->u.constant))) {\n case ZEND_FETCH_CLASS_SELF:\n case ZEND_FETCH_CLASS_PARENT:", "fixed": " void zend_do_implements_trait(znode *trait_name TSRMLS_DC)\n {\n zend_op *opline;\nif ((CG(active_class_entry)->ce_flags & ZEND_ACC_INTERFACE)) {\nzend_error(E_COMPILE_ERROR,\n\"Cannot use traits inside of interfaces. %s is used in %s\",\nZ_STRVAL(trait_name->u.constant), CG(active_class_entry)->name);\n}\n switch (zend_get_class_fetch_type(Z_STRVAL(trait_name->u.constant), Z_STRLEN(trait_name->u.constant))) {\n case ZEND_FETCH_CLASS_SELF:\n case ZEND_FETCH_CLASS_PARENT:"}
{"scenario": "php-bug-2011-12-04-1e6a82a1cf-dfa08dc325.tar.gz", "repairActions": [], "lines": 1, "problem": " }\n void php_filter_validate_email(PHP_INPUT_FILTER_PARAM_DECL)\n {\nconst char regexp[] = \"/^(?!(?:(?:\\\\x22?\\\\x5C[\\\\x00-\\\\x7E]\\\\x22?)|(?:\\\\x22?[^\\\\x5C\\\\x22]\\\\x22?)){255,})(?!(?:(?:\\\\x22?\\\\x5C[\\\\x00-\\\\x7E]\\\\x22?)|(?:\\\\x22?[^\\\\x5C\\\\x22]\\\\x22?)){65,}@)(?:(?:[\\\\x21\\\\x23-\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2F-\\\\x39\\\\x3D\\\\x3F\\\\x5E-\\\\x7E]+)|(?:\\\\x22(?:[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7F]|(?:\\\\x5C[\\\\x00-\\\\x7F]))*\\\\x22))(?:\\\\.(?:(?:[\\\\x21\\\\x23-\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2F-\\\\x39\\\\x3D\\\\x3F\\\\x5E-\\\\x7E]+)|(?:\\\\x22(?:[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7F]|(?:\\\\x5C[\\\\x00-\\\\x7F]))*\\\\x22)))*@(?:(?:(?!.*[^.]{64,})(?:(?:(?:xn--)?[a-z0-9]+(?:-[a-z0-9]+)*\\\\.){1,126}){1,}(?:(?:[a-z][a-z0-9]*)|(?:(?:xn--)[a-z0-9]+))(?:-[a-z0-9]+)*)|(?:\\\\[(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){7})|(?:(?!(?:.*[a-f0-9][:\\\\]]){7,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?)))|(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){5}:)|(?:(?!(?:.*[a-f0-9]:){5,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3}:)?)))?(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))(?:\\\\.(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))){3}))\\\\]))$/iD\";\n pcre       *re = NULL;\n pcre_extra *pcre_extra = NULL;\n int preg_options = 0;", "fixed": " }\n void php_filter_validate_email(PHP_INPUT_FILTER_PARAM_DECL)\n {\nconst char regexp[] = \"/^(?!(?:(?:\\\\x22?\\\\x5C[\\\\x00-\\\\x7E]\\\\x22?)|(?:\\\\x22?[^\\\\x5C\\\\x22]\\\\x22?)){255,})(?!(?:(?:\\\\x22?\\\\x5C[\\\\x00-\\\\x7E]\\\\x22?)|(?:\\\\x22?[^\\\\x5C\\\\x22]\\\\x22?)){65,}@)(?:(?:[\\\\x21\\\\x23-\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2F-\\\\x39\\\\x3D\\\\x3F\\\\x5E-\\\\x7E]+)|(?:\\\\x22(?:[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7F]|(?:\\\\x5C[\\\\x00-\\\\x7F]))*\\\\x22))(?:\\\\.(?:(?:[\\\\x21\\\\x23-\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2F-\\\\x39\\\\x3D\\\\x3F\\\\x5E-\\\\x7E]+)|(?:\\\\x22(?:[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7F]|(?:\\\\x5C[\\\\x00-\\\\x7F]))*\\\\x22)))*@(?:(?:(?!.*[^.]{64,})(?:(?:(?:xn--)?[a-z0-9]+(?:-+[a-z0-9]+)*\\\\.){1,126}){1,}(?:(?:[a-z][a-z0-9]*)|(?:(?:xn--)[a-z0-9]+))(?:-+[a-z0-9]+)*)|(?:\\\\[(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){7})|(?:(?!(?:.*[a-f0-9][:\\\\]]){7,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?)))|(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){5}:)|(?:(?!(?:.*[a-f0-9]:){5,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3}:)?)))?(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))(?:\\\\.(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))){3}))\\\\]))$/iD\";\n pcre       *re = NULL;\n pcre_extra *pcre_extra = NULL;\n int preg_options = 0;"}
{"scenario": "php-bug-2011-11-19-51a4ae6576-bc810a443d.tar.gz", "repairActions": ["Changes Condition"], "lines": 2, "problem": " {\n zend_uint child_flags;\n zend_uint parent_flags = parent->common.fn_flags;\nif (parent->common.fn_flags & ZEND_ACC_ABSTRACT\n && parent->common.scope != (child->common.prototype ? child->common.prototype->common.scope : child->common.scope)\n && child->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_IMPLEMENTED_ABSTRACT)) {\n zend_error(E_COMPILE_ERROR, \"Can't inherit abstract function %s::%s() (previously declared abstract in %s)\",", "fixed": " {\n zend_uint child_flags;\n zend_uint parent_flags = parent->common.fn_flags;\nif ((parent->common.scope->ce_flags & ZEND_ACC_INTERFACE) == 0\n&& parent->common.fn_flags & ZEND_ACC_ABSTRACT\n && parent->common.scope != (child->common.prototype ? child->common.prototype->common.scope : child->common.scope)\n && child->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_IMPLEMENTED_ABSTRACT)) {\n zend_error(E_COMPILE_ERROR, \"Can't inherit abstract function %s::%s() (previously declared abstract in %s)\","}
{"scenario": "php-bug-2011-12-10-74343ca506-52c36e60c4.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " php_stream_fill_read_buffer(stream, len + toread TSRMLS_CC);\n just_read = (stream->writepos - stream->readpos) - len;\n len += just_read;\nif (just_read < toread) {\n break;\n }\n }", "fixed": " php_stream_fill_read_buffer(stream, len + toread TSRMLS_CC);\n just_read = (stream->writepos - stream->readpos) - len;\n len += just_read;\nif (just_read == 0) {\n break;\n }\n }"}
{"scenario": "lighttpd-bug-1806-1807.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Changes Condition"], "lines": 26, "problem": " server_socket *srv_sock = con->srv_socket;\n if (dc->parent && dc->parent->context_ndx) {\n if (con->conf.log_condition_handling) {\nlog_error_write(srv, __FILE__, __LINE__,  \"sb\", \"go parent\", dc->parent->key);\n }\nif (config_check_cond_cached(srv, con, dc->parent) == COND_RESULT_FALSE) {\n return COND_RESULT_FALSE;\n }\n }\n if (dc->prev) {\n if (con->conf.log_condition_handling) {\nlog_error_write(srv, __FILE__, __LINE__,  \"sb\", \"go prev\", dc->prev->key);\n }\n config_check_cond_cached(srv, con, dc->prev);\nif (COND_RESULT_FALSE == con->cond_cache[dc->context_ndx].result) {\nreturn COND_RESULT_FALSE;\n }\n }\n if (!con->conditional_is_valid[dc->comp]) {\n if (con->conf.log_condition_handling) {\nTRACE(\"cond[%d] is valid: %d\", dc->comp, con->conditional_is_valid[dc->comp]);\n }\n return COND_RESULT_UNSET;\n }\n if (con->conf.log_condition_handling) {\n TRACE(\"[%d] result: %s\",\n dc->context_ndx,\ncaches[dc->context_ndx].result == COND_RESULT_TRUE ? \"true\" : \"false\");\n }\n } else {\n if (con->conf.log_condition_cache_handling) {\n TRACE(\"[%d] (cached) result: %s\",\n dc->context_ndx,\ncaches[dc->context_ndx].result == COND_RESULT_TRUE ? \"true\" : \"false\");\n }\n }\n return caches[dc->context_ndx].result;", "fixed": " server_socket *srv_sock = con->srv_socket;\n if (dc->parent && dc->parent->context_ndx) {\n if (con->conf.log_condition_handling) {\nTRACE(\"checking if the parent (%s) evaluates to 'true'\", BUF_STR(dc->parent->key));\n }\nswitch (config_check_cond_cached(srv, con, dc->parent)) {\ncase COND_RESULT_FALSE:\n return COND_RESULT_FALSE;\ncase COND_RESULT_UNSET:\nreturn COND_RESULT_UNSET;\ndefault:\nbreak;\n }\n }\n if (dc->prev) {\n if (con->conf.log_condition_handling) {\nTRACE(\"triggering eval of successors of (%s) [in else]\", BUF_STR(dc->key));\n }\n config_check_cond_cached(srv, con, dc->prev);\nif (con->conf.log_condition_handling) {\nTRACE(\"(%s) [in else] -> %s\", BUF_STR(dc->key), con->cond_cache[dc->context_ndx].result == COND_RESULT_FALSE ? \"false\" : \"we will see\");\n }\nswitch (con->cond_cache[dc->context_ndx].result) {\ncase COND_RESULT_FALSE:\nreturn con->cond_cache[dc->context_ndx].result;\ndefault:\nbreak;\n }\n}\n if (!con->conditional_is_valid[dc->comp]) {\n if (con->conf.log_condition_handling) {\nTRACE(\"is condition [%d] (%s) already valid ? %s\",\ndc->comp,\nBUF_STR(dc->key),\ncon->conditional_is_valid[dc->comp] ? \"yeah\" : \"nej\");\n }\n return COND_RESULT_UNSET;\n }\n if (con->conf.log_condition_handling) {\n TRACE(\"[%d] result: %s\",\n dc->context_ndx,\ncaches[dc->context_ndx].result == COND_RESULT_UNSET ? \"unknown\" :\n(caches[dc->context_ndx].result == COND_RESULT_TRUE ? \"true\" : \"false\")\n);\n }\n } else {\n if (con->conf.log_condition_cache_handling) {\n TRACE(\"[%d] (cached) result: %s\",\n dc->context_ndx,\ncaches[dc->context_ndx].result == COND_RESULT_UNSET ? \"unknown\" :\n(caches[dc->context_ndx].result == COND_RESULT_TRUE ? \"true\" : \"false\")\n);\n }\n }\n return caches[dc->context_ndx].result;"}
{"scenario": "php-bug-2011-11-01-ceac9dc490-9b0d73af1d.tar.gz", "repairActions": ["Adds Method Call"], "lines": 2, "problem": " }\n if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {\n if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\n zend_function_dtor(other_trait_fn);\n zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n } else {\n if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\n abstract_solved = 1;\n } else {\n collision++;", "fixed": " }\n if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {\n if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\ndo_inheritance_check_on_method(fn, other_trait_fn TSRMLS_CC);\n zend_function_dtor(other_trait_fn);\n zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n } else {\n if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\ndo_inheritance_check_on_method(other_trait_fn, fn TSRMLS_CC);\n abstract_solved = 1;\n } else {\n collision++;"}
{"scenario": "gmp-bug-14166-14167.tar.gz", "repairActions": [], "lines": 1, "problem": " }\n if (bsize == 0)\n {\nssize = SIZ (a) >= 0 ? 1 : -1;\n if (ALLOC (g) < asize)\n _mpz_realloc (g, asize);\n gp = PTR (g);", "fixed": " }\n if (bsize == 0)\n {\nssize = SIZ (a) >= 0 ? (asize != 0) : -1;\n if (ALLOC (g) < asize)\n _mpz_realloc (g, asize);\n gp = PTR (g);"}
{"scenario": "php-bug-2011-11-08-6a42b41c3d-5063a77128.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable"], "lines": 24, "problem": " ZEND_BEGIN_ARG_INFO_EX(arginfo_token_get_all, 0, 0, 1)\n ZEND_ARG_INFO(0, source)\n ZEND_END_ARG_INFO()\n int token_type;\n zend_bool destroy;\n int token_line = 1;\n array_init(return_value);\n ZVAL_NULL(&token);\n while ((token_type = lex_scan(&token TSRMLS_CC))) {\n zval_dtor(&token);\n }\n ZVAL_NULL(&token);\ntoken_line = CG(zend_lineno);\nif (token_type == T_HALT_COMPILER) {\n break;\n }\n }\n }\n PHP_FUNCTION(token_get_all)", "fixed": " ZEND_BEGIN_ARG_INFO_EX(arginfo_token_get_all, 0, 0, 1)\n ZEND_ARG_INFO(0, source)\n ZEND_END_ARG_INFO()\n int token_type;\n zend_bool destroy;\n int token_line = 1;\n array_init(return_value);\n ZVAL_NULL(&token);\n while ((token_type = lex_scan(&token TSRMLS_CC))) {\n zval_dtor(&token);\n }\n ZVAL_NULL(&token);\nif (need_tokens != -1) {\nif (token_type != T_WHITESPACE && token_type != T_OPEN_TAG\n&& token_type != T_COMMENT && token_type != T_DOC_COMMENT\n&& --need_tokens == 0\n) {\nif (zendcursor != zendlimit) {\nMAKE_STD_ZVAL(keyword);\narray_init(keyword);\nadd_next_index_long(keyword, T_INLINE_HTML);\nadd_next_index_stringl(keyword, (char *)zendcursor, zendlimit - zendcursor, 1);\nadd_next_index_long(keyword, token_line);\nadd_next_index_zval(return_value, keyword);\n}\n break;\n }\n} else if (token_type == T_HALT_COMPILER) {\nneed_tokens = 3;\n}\ntoken_line = CG(zend_lineno);\n }\n }\n PHP_FUNCTION(token_get_all)"}
