{"scenario": "php-bug-2011-05-21-f5a9e17f9c-964f44a280.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 1, "problem": " zend_hash_destroy(&pcre_globals->pcre_cache);\n }\n PHP_INI_BEGIN()\nSTD_PHP_INI_ENTRY(\"pcre.backtrack_limit\", \"1000000\", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)\n STD_PHP_INI_ENTRY(\"pcre.recursion_limit\", \"100000\", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)\n PHP_INI_END()\n static PHP_MINFO_FUNCTION(pcre)", "fixed": " zend_hash_destroy(&pcre_globals->pcre_cache);\n }\n PHP_INI_BEGIN()\nSTD_PHP_INI_ENTRY(\"pcre.backtrack_limit\", \"100000\", PHP_INI_ALL, OnUpdateLong, backtrack_limit, zend_pcre_globals, pcre_globals)\n STD_PHP_INI_ENTRY(\"pcre.recursion_limit\", \"100000\", PHP_INI_ALL, OnUpdateLong, recursion_limit, zend_pcre_globals, pcre_globals)\n PHP_INI_END()\n static PHP_MINFO_FUNCTION(pcre)"}
{"scenario": "lighttpd-bug-2330-2331.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable"], "lines": 46, "problem": " buffer *compress_cache_dir;\n array  *compress;\n off_t   compress_max_filesize;\n } plugin_config;\n typedef struct {\n PLUGIN_DATA;\n free(p);\n return HANDLER_GO_ON;\n }\n static int mkdir_recursive(char *dir) {\n char *p = dir;\n if (!dir || !dir[0])\n return -1;\n }\n *p++ = '/';\n }\n return (mkdir(dir, 0700) != 0) && (errno != EEXIST) ? -1 : 0;\n }\n static int mkdir_for_file(char *filename) {\n char *p = filename;\n if (!filename || !filename[0])\n { \"compress.cache-dir\",             NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },\n { \"compress.filetype\",              NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },\n { \"compress.max-filesize\",          NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },\n { NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }\n };\n p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n for (i = 0; i < srv->config_context->used; i++) {\n plugin_config *s;\n s = calloc(1, sizeof(plugin_config));\n s->compress_cache_dir = buffer_init();\n s->compress = array_init();\n s->compress_max_filesize = 0;\n cv[0].destination = s->compress_cache_dir;\n cv[1].destination = s->compress;\n cv[2].destination = &(s->compress_max_filesize);\n p->config_storage[i] = s;\n if (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n return HANDLER_ERROR;\n }\n if (!buffer_is_empty(s->compress_cache_dir)) {\n struct stat st;\n if (0 != stat(s->compress_cache_dir->ptr, &st)) {\n PATCH_OPTION(compress_cache_dir);\n PATCH_OPTION(compress);\n PATCH_OPTION(compress_max_filesize);\n for (i = 1; i < srv->config_context->used; i++) {\n data_config *dc = (data_config *)srv->config_context->data[i];\n s = p->config_storage[i];\n PATCH_OPTION(compress);\n } else if (buffer_is_equal_string(du->key, CONST_STR_LEN(\"compress.max-filesize\"))) {\n PATCH_OPTION(compress_max_filesize);\n }\n }\n }\n data_string *ds;\n int accept_encoding = 0;\n char *value;\nint srv_encodings = 0;\n int matched_encodings = 0;\n const char *dflt_gzip = \"gzip\";\n const char *dflt_deflate = \"deflate\";\n return HANDLER_GO_ON;\n }\n value = ds->value->ptr;\n if (NULL != strstr(value, \"gzip\")) accept_encoding |= HTTP_ACCEPT_ENCODING_GZIP;\n if (NULL != strstr(value, \"deflate\")) accept_encoding |= HTTP_ACCEPT_ENCODING_DEFLATE;\n if (NULL != strstr(value, \"compress\")) accept_encoding |= HTTP_ACCEPT_ENCODING_COMPRESS;\nif (NULL != strstr(value, \"bzip2\")) accept_encoding |= HTTP_ACCEPT_ENCODING_BZIP2;\nif (NULL != strstr(value, \"identity\")) accept_encoding |= HTTP_ACCEPT_ENCODING_IDENTITY;\nsrv_encodings |= HTTP_ACCEPT_ENCODING_BZIP2;\nsrv_encodings |= HTTP_ACCEPT_ENCODING_GZIP;\nsrv_encodings |= HTTP_ACCEPT_ENCODING_DEFLATE;\nif (0 == (matched_encodings = accept_encoding & srv_encodings)) {\n if (con->conf.log_request_handling) TRACE(\"we don't support the requested encoding: %s\", value);\n return HANDLER_GO_ON;\n }", "fixed": " buffer *compress_cache_dir;\n array  *compress;\n off_t   compress_max_filesize;\nint     allowed_encodings;\n } plugin_config;\n typedef struct {\n PLUGIN_DATA;\n free(p);\n return HANDLER_GO_ON;\n }\n static int mkdir_recursive(char *dir) {\n char *p = dir;\n if (!dir || !dir[0])\n return -1;\n }\n *p++ = '/';\nif (!*p) return 0;\n }\n return (mkdir(dir, 0700) != 0) && (errno != EEXIST) ? -1 : 0;\n }\n static int mkdir_for_file(char *filename) {\n char *p = filename;\n if (!filename || !filename[0])\n { \"compress.cache-dir\",             NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_CONNECTION },\n { \"compress.filetype\",              NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },\n { \"compress.max-filesize\",          NULL, T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },\n{ \"compress.allowed-encodings\",     NULL, T_CONFIG_ARRAY, T_CONFIG_SCOPE_CONNECTION },\n { NULL,                             NULL, T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }\n };\n p->config_storage = calloc(1, srv->config_context->used * sizeof(specific_config *));\n for (i = 0; i < srv->config_context->used; i++) {\n plugin_config *s;\narray  *encodings_arr = array_init();\n s = calloc(1, sizeof(plugin_config));\n s->compress_cache_dir = buffer_init();\n s->compress = array_init();\n s->compress_max_filesize = 0;\ns->allowed_encodings = 0;\n cv[0].destination = s->compress_cache_dir;\n cv[1].destination = s->compress;\n cv[2].destination = &(s->compress_max_filesize);\ncv[3].destination = encodings_arr;\n p->config_storage[i] = s;\n if (0 != config_insert_values_global(srv, ((data_config *)srv->config_context->data[i])->value, cv)) {\n return HANDLER_ERROR;\n }\nif (encodings_arr->used) {\nsize_t j = 0;\nfor (j = 0; j < encodings_arr->used; j++) {\ndata_string *ds = (data_string *)encodings_arr->data[j];\nif (NULL != strstr(ds->value->ptr, \"gzip\"))\ns->allowed_encodings |= HTTP_ACCEPT_ENCODING_GZIP;\nif (NULL != strstr(ds->value->ptr, \"deflate\"))\ns->allowed_encodings |= HTTP_ACCEPT_ENCODING_DEFLATE;\nif (NULL != strstr(ds->value->ptr, \"bzip2\"))\ns->allowed_encodings |= HTTP_ACCEPT_ENCODING_BZIP2;\n}\n} else {\ns->allowed_encodings = 0\n| HTTP_ACCEPT_ENCODING_GZIP | HTTP_ACCEPT_ENCODING_DEFLATE\n| HTTP_ACCEPT_ENCODING_BZIP2\n;\n}\narray_free(encodings_arr);\n if (!buffer_is_empty(s->compress_cache_dir)) {\n struct stat st;\n if (0 != stat(s->compress_cache_dir->ptr, &st)) {\n PATCH_OPTION(compress_cache_dir);\n PATCH_OPTION(compress);\n PATCH_OPTION(compress_max_filesize);\nPATCH_OPTION(allowed_encodings);\n for (i = 1; i < srv->config_context->used; i++) {\n data_config *dc = (data_config *)srv->config_context->data[i];\n s = p->config_storage[i];\n PATCH_OPTION(compress);\n } else if (buffer_is_equal_string(du->key, CONST_STR_LEN(\"compress.max-filesize\"))) {\n PATCH_OPTION(compress_max_filesize);\n} else if (buffer_is_equal_string(du->key, CONST_STR_LEN(\"compress.allowed-encodings\"))) {\nPATCH_OPTION(allowed_encodings);\n }\n }\n }\n data_string *ds;\n int accept_encoding = 0;\n char *value;\n int matched_encodings = 0;\n const char *dflt_gzip = \"gzip\";\n const char *dflt_deflate = \"deflate\";\n return HANDLER_GO_ON;\n }\n value = ds->value->ptr;\n if (NULL != strstr(value, \"gzip\")) accept_encoding |= HTTP_ACCEPT_ENCODING_GZIP;\n if (NULL != strstr(value, \"deflate\")) accept_encoding |= HTTP_ACCEPT_ENCODING_DEFLATE;\n if (NULL != strstr(value, \"compress\")) accept_encoding |= HTTP_ACCEPT_ENCODING_COMPRESS;\nif (NULL != strstr(value, \"bzip2\")) accept_encoding |= HTTP_ACCEPT_ENCODING_BZIP2;\nif (NULL != strstr(value, \"identity\")) accept_encoding |= HTTP_ACCEPT_ENCODING_IDENTITY;\nmatched_encodings = accept_encoding & p->conf.allowed_encodings;\nif (0 == matched_encodings) {\n if (con->conf.log_request_handling) TRACE(\"we don't support the requested encoding: %s\", value);\n return HANDLER_GO_ON;\n }"}
{"scenario": "lighttpd-bug-1948-1949.tar.gz", "repairActions": ["Adds If Statement"], "lines": 4, "problem": " if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {\n response_header_overwrite(srv, con, CONST_STR_LEN(\"Transfer-Encoding\"), CONST_STR_LEN(\"chunked\"));\n allow_keep_alive = 1;\n } else if (con->response.content_length >= 0) {\n buffer_copy_off_t(srv->tmp_buf, con->response.content_length);\n response_header_overwrite(srv, con, CONST_STR_LEN(\"Content-Length\"), srv->tmp_buf->ptr, srv->tmp_buf->used - 1);", "fixed": " if (con->response.transfer_encoding & HTTP_TRANSFER_ENCODING_CHUNKED) {\n response_header_overwrite(srv, con, CONST_STR_LEN(\"Transfer-Encoding\"), CONST_STR_LEN(\"chunked\"));\n allow_keep_alive = 1;\n} else if ((con->http_status >= 100 && con->http_status < 200) ||\ncon->http_status == 204 ||\ncon->http_status == 304) {\nallow_keep_alive = 1;\n } else if (con->response.content_length >= 0) {\n buffer_copy_off_t(srv->tmp_buf, con->response.content_length);\n response_header_overwrite(srv, con, CONST_STR_LEN(\"Content-Length\"), srv->tmp_buf->ptr, srv->tmp_buf->used - 1);"}
{"scenario": "libtiff-bug-2010-11-27-eb326f9-eec7ec0.tar.gz", "repairActions": [], "lines": 1, "problem": " \"An error occurred creating output PDF file\");\n goto fail;\n }\n fail:\n ret = EXIT_FAILURE;\n success:", "fixed": " \"An error occurred creating output PDF file\");\n goto fail;\n }\ngoto success;\n fail:\n ret = EXIT_FAILURE;\n success:"}
{"scenario": "gzip-bug-2010-02-19-3eb6091d69-884ef6d16c.tar.gz", "repairActions": ["Changes Method Call Args", "Changes Condition"], "lines": 3, "problem": " program_name);\n }\nif ((z_len == 0 && !decompress) || z_len > MAX_SUFFIX) {\nfprintf(stderr, \"%s: incorrect suffix '%s'\\n\",\nprogram_name, z_suffix);\n do_exit(ERROR);\n }\n if (do_lzw && !decompress) work = lzw;", "fixed": " program_name);\n }\nif (z_len == 0 || z_len > MAX_SUFFIX) {\nfprintf(stderr, \"%s: invalid suffix '%s'\\n\", program_name, z_suffix);\n do_exit(ERROR);\n }\n if (do_lzw && !decompress) work = lzw;"}
{"scenario": "libtiff-bug-2005-12-14-6746b87-0d3d51d.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable", "Adds Loop"], "lines": 46, "problem": " (void) imagewidth; (void) spp;\n for (row = 0; row < imagelength; row++) {\n if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore)\ngoto bad;\n if (TIFFWriteScanline(out, buf, row, 0) < 0)\n goto bad;\n }\n _TIFFfree(buf);\nreturn 1;\n bad:\n _TIFFfree(buf);\nreturn 0;\n }\n typedef void biasFn (void *image, void *bias, uint32 pixels);\n buf = _TIFFmalloc(bufSize);\n biasBuf = _TIFFmalloc(bufSize);\n for (row = 0; row < imagelength; row++) {\nif (TIFFReadScanline(in, buf, row, 0) < 0\n&& !ignore)\ngoto bad;\nif (TIFFReadScanline(bias, biasBuf, row, 0) < 0\n&& !ignore)\ngoto bad;\n subtractLine (buf, biasBuf, imagewidth);\nif (TIFFWriteScanline(out, buf, row, 0) < 0)\ngoto bad;\n }\n_TIFFfree(buf);\n_TIFFfree(biasBuf);\nTIFFSetDirectory(bias,\nTIFFCurrentDirectory(bias));\nreturn 1;\nbad:\n_TIFFfree(buf);\n_TIFFfree(biasBuf);\nreturn 0;\n} else {\nfprintf (stderr, \"No support for biasing %d bit pixels\\n\",\nsampleBits);\nreturn 0;\n }\n }\n fprintf (stderr,\"Bias image %s,%d\\nis not the same size as %s,%d\\n\",\n TIFFFileName(bias), TIFFCurrentDirectory(bias),\n TIFFFileName(in), TIFFCurrentDirectory(in));\nreturn 0;\n} else {\n fprintf (stderr, \"Can't bias %s,%d as it has >1 Sample/Pixel\\n\",\n TIFFFileName(in), TIFFCurrentDirectory(in));\nreturn 0;\n }\n }\n DECLAREcpFunc(cpDecodedStrips)\n tsize_t cc = (row + rowsperstrip > imagelength) ?\n TIFFVStripSize(in, imagelength - row) : stripsize;\n if (TIFFReadEncodedStrip(in, s, buf, cc) < 0 && !ignore)\ngoto bad;\nif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0)\ngoto bad;\n row += rowsperstrip;\n }\n _TIFFfree(buf);\nreturn 1;\n }\nreturn 0;\nbad:\n_TIFFfree(buf);\nreturn 0;\n }\n DECLAREcpFunc(cpSeparate2SeparateByRow)\n {\n for (s = 0; s < spp; s++) {\n for (row = 0; row < imagelength; row++) {\n if (TIFFReadScanline(in, buf, row, s) < 0 && !ignore)\ngoto bad;\n if (TIFFWriteScanline(out, buf, row, s) < 0)\n goto bad;\n }\n }\n _TIFFfree(buf);\nreturn 1;\n bad:\n _TIFFfree(buf);\nreturn 0;\n }\n DECLAREcpFunc(cpContig2SeparateByRow)\n {\n for (s = 0; s < spp; s++) {\n for (row = 0; row < imagelength; row++) {\n if (TIFFReadScanline(in, inbuf, row, 0) < 0 && !ignore)\ngoto bad;\n inp = ((uint8*)inbuf) + s;\n outp = (uint8*)outbuf;\n for (n = imagewidth; n-- > 0;) {\n goto bad;\n }\n }\n if (inbuf) _TIFFfree(inbuf);\n if (outbuf) _TIFFfree(outbuf);\nreturn 1;\n bad:\n if (inbuf) _TIFFfree(inbuf);\n if (outbuf) _TIFFfree(outbuf);\nreturn 0;\n }\n DECLAREcpFunc(cpSeparate2ContigByRow)\n {\n for (row = 0; row < imagelength; row++) {\n for (s = 0; s < spp; s++) {\n if (TIFFReadScanline(in, inbuf, row, s) < 0 && !ignore)\ngoto bad;\n inp = (uint8*)inbuf;\n outp = ((uint8*)outbuf) + s;\n for (n = imagewidth; n-- > 0;) {\n if (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n goto bad;\n }\n if (inbuf) _TIFFfree(inbuf);\n if (outbuf) _TIFFfree(outbuf);\n return (TRUE);", "fixed": " (void) imagewidth; (void) spp;\n for (row = 0; row < imagelength; row++) {\n if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore)\ngoto done;\n if (TIFFWriteScanline(out, buf, row, 0) < 0)\n goto bad;\n }\ndone:\n _TIFFfree(buf);\nreturn (TRUE);\n bad:\n _TIFFfree(buf);\nreturn (FALSE);\n }\n typedef void biasFn (void *image, void *bias, uint32 pixels);\n buf = _TIFFmalloc(bufSize);\n biasBuf = _TIFFmalloc(bufSize);\n for (row = 0; row < imagelength; row++) {\nif (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore)\nbreak;\nif (TIFFReadScanline(bias, biasBuf, row, 0) < 0 && !ignore)\nbreak;\n subtractLine (buf, biasBuf, imagewidth);\nif (TIFFWriteScanline(out, buf, row, 0) < 0) {\n_TIFFfree(buf); _TIFFfree(biasBuf);\nreturn FALSE;\n }\n }\n_TIFFfree(buf); _TIFFfree(biasBuf);\nTIFFSetDirectory (bias, TIFFCurrentDirectory(bias));\nreturn TRUE;\n}else{\nfprintf (stderr, \"No support for biasing %d bit pixels\\n\", sampleBits);\nreturn FALSE;\n }\n}\n fprintf (stderr,\"Bias image %s,%d\\nis not the same size as %s,%d\\n\",\n TIFFFileName(bias), TIFFCurrentDirectory(bias),\n TIFFFileName(in), TIFFCurrentDirectory(in));\nreturn FALSE;\n}else{\n fprintf (stderr, \"Can't bias %s,%d as it has >1 Sample/Pixel\\n\",\n TIFFFileName(in), TIFFCurrentDirectory(in));\nreturn FALSE;\n }\n }\n DECLAREcpFunc(cpDecodedStrips)\n tsize_t cc = (row + rowsperstrip > imagelength) ?\n TIFFVStripSize(in, imagelength - row) : stripsize;\n if (TIFFReadEncodedStrip(in, s, buf, cc) < 0 && !ignore)\nbreak;\nif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n_TIFFfree(buf);\nreturn (FALSE);\n}\n row += rowsperstrip;\n }\n _TIFFfree(buf);\nreturn (TRUE);\n }\nreturn (FALSE);\n }\n DECLAREcpFunc(cpSeparate2SeparateByRow)\n {\n for (s = 0; s < spp; s++) {\n for (row = 0; row < imagelength; row++) {\n if (TIFFReadScanline(in, buf, row, s) < 0 && !ignore)\ngoto done;\n if (TIFFWriteScanline(out, buf, row, s) < 0)\n goto bad;\n }\n }\ndone:\n _TIFFfree(buf);\nreturn (TRUE);\n bad:\n _TIFFfree(buf);\nreturn (FALSE);\n }\n DECLAREcpFunc(cpContig2SeparateByRow)\n {\n for (s = 0; s < spp; s++) {\n for (row = 0; row < imagelength; row++) {\n if (TIFFReadScanline(in, inbuf, row, 0) < 0 && !ignore)\ngoto done;\n inp = ((uint8*)inbuf) + s;\n outp = (uint8*)outbuf;\n for (n = imagewidth; n-- > 0;) {\n goto bad;\n }\n }\ndone:\n if (inbuf) _TIFFfree(inbuf);\n if (outbuf) _TIFFfree(outbuf);\nreturn (TRUE);\n bad:\n if (inbuf) _TIFFfree(inbuf);\n if (outbuf) _TIFFfree(outbuf);\nreturn (FALSE);\n }\n DECLAREcpFunc(cpSeparate2ContigByRow)\n {\n for (row = 0; row < imagelength; row++) {\n for (s = 0; s < spp; s++) {\n if (TIFFReadScanline(in, inbuf, row, s) < 0 && !ignore)\ngoto done;\n inp = (uint8*)inbuf;\n outp = ((uint8*)outbuf) + s;\n for (n = imagewidth; n-- > 0;) {\n if (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n goto bad;\n }\ndone:\n if (inbuf) _TIFFfree(inbuf);\n if (outbuf) _TIFFfree(outbuf);\n return (TRUE);"}
{"scenario": "php-bug-2012-03-06-6237456cae-5e80c05deb.tar.gz", "repairActions": ["Changes Method Signature", "Changes Method Call Args", "Adds Method Call", "Adds Loop", "Adds Method"], "lines": 16, "problem": " RETURN_FALSE; \\\n } \\\n }\nstatic void finfo_objects_dtor(void *object, zend_object_handle handle TSRMLS_DC)\n {\n struct finfo_object *intern = (struct finfo_object *) object;\n if (intern->ptr) {\n zend_object_std_init(&intern->zo, class_type TSRMLS_CC);\n object_properties_init(&intern->zo, class_type);\n intern->ptr = NULL;\nretval.handle = zend_objects_store_put(intern, finfo_objects_dtor, NULL, NULL TSRMLS_CC);\n retval.handlers = (zend_object_handlers *) &finfo_object_handlers;\n return retval;\n }\n php_info_print_table_row(2, \"version\", PHP_FILEINFO_VERSION);\n php_info_print_table_end();\n }\n PHP_FUNCTION(finfo_open)\n {\n long options = MAGIC_NONE;\n FILEINFO_DECLARE_INIT_OBJECT(object)\n char resolved_path[MAXPATHLEN];\n if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|lp\", &options, &file, &file_len) == FAILURE) {\n RETURN_FALSE;\n }\n if (object) {\n if (php_check_open_basedir(file TSRMLS_CC)) {\n RETURN_FALSE;\n }\n if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) {\n RETURN_FALSE;\n }\n file = resolved_path;\n if (finfo->magic == NULL) {\n efree(finfo);\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid mode '%ld'.\", options);\n RETURN_FALSE;\n }\n if (magic_load(finfo->magic, file) == -1) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to load magic database at '%s'.\", file);\n magic_close(finfo->magic);\n efree(finfo);\n RETURN_FALSE;\n }\n if (object) {", "fixed": " RETURN_FALSE; \\\n } \\\n }\nstatic void finfo_objects_free(void *object TSRMLS_DC)\n {\n struct finfo_object *intern = (struct finfo_object *) object;\n if (intern->ptr) {\n zend_object_std_init(&intern->zo, class_type TSRMLS_CC);\n object_properties_init(&intern->zo, class_type);\n intern->ptr = NULL;\nretval.handle = zend_objects_store_put(intern, NULL,\nfinfo_objects_free, NULL TSRMLS_CC);\n retval.handlers = (zend_object_handlers *) &finfo_object_handlers;\n return retval;\n }\n php_info_print_table_row(2, \"version\", PHP_FILEINFO_VERSION);\n php_info_print_table_end();\n }\ndo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\nif (object) {\t\t\t\t\t\t\t\t\t\t\t\\\nzend_object_store_ctor_failed(object TSRMLS_CC);\t\\\nzval_dtor(object);\t\t\t\t\t\t\t\t\t\\\nZVAL_NULL(object);\t\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n PHP_FUNCTION(finfo_open)\n {\n long options = MAGIC_NONE;\n FILEINFO_DECLARE_INIT_OBJECT(object)\n char resolved_path[MAXPATHLEN];\n if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|lp\", &options, &file, &file_len) == FAILURE) {\nFILEINFO_DESTROY_OBJECT(object);\n RETURN_FALSE;\n }\n if (object) {\n if (php_check_open_basedir(file TSRMLS_CC)) {\nFILEINFO_DESTROY_OBJECT(object);\n RETURN_FALSE;\n }\n if (!expand_filepath_with_mode(file, resolved_path, NULL, 0, CWD_EXPAND TSRMLS_CC)) {\nFILEINFO_DESTROY_OBJECT(object);\n RETURN_FALSE;\n }\n file = resolved_path;\n if (finfo->magic == NULL) {\n efree(finfo);\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid mode '%ld'.\", options);\nFILEINFO_DESTROY_OBJECT(object);\n RETURN_FALSE;\n }\n if (magic_load(finfo->magic, file) == -1) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to load magic database at '%s'.\", file);\n magic_close(finfo->magic);\n efree(finfo);\nFILEINFO_DESTROY_OBJECT(object);\n RETURN_FALSE;\n }\n if (object) {"}
{"scenario": "libtiff-bug-2009-08-28-e8a47d4-023b6df.tar.gz", "repairActions": ["Changes Type"], "lines": 17, "problem": "static TIFFErrorHandler old_error_handler = 0;\nstatic int status = 0;\nstatic int showdata = 0;\nstatic int rawdata = 0;\nstatic int showwords = 0;\nstatic int readdata = 0;\nstatic int stoponerr = 1;\n static\tvoid usage(void);\n static\tvoid tiffinfo(TIFF*, uint16, long);\nstatic void\nPrivateErrorHandler(const char* module, const char* fmt, va_list ap)\n{\nif (old_error_handler)\n(*old_error_handler)(module,fmt,ap);\nstatus = 1;\n}\n int\n main(int argc, char* argv[])\n {\n }\n if (optind >= argc)\n usage();\nold_error_handler = _TIFFerrorHandler;\n(void) TIFFSetErrorHandler(PrivateErrorHandler);\n multiplefiles = (argc - optind > 1);\n for (; optind < argc; optind++) {\n if (multiplefiles)\n TIFFClose(tif);\n }\n }\nreturn (status);\n }\n char* stuff[] = {\n \"usage: tiffinfo [options] input...\",", "fixed": "int\tshowdata = 0;\nint\trawdata = 0;\nint\tshowwords = 0;\nint\treaddata = 0;\nint\tstoponerr = 1;\n static\tvoid usage(void);\n static\tvoid tiffinfo(TIFF*, uint16, long);\n int\n main(int argc, char* argv[])\n {\n }\n if (optind >= argc)\n usage();\n multiplefiles = (argc - optind > 1);\n for (; optind < argc; optind++) {\n if (multiplefiles)\n TIFFClose(tif);\n }\n }\nreturn (0);\n }\n char* stuff[] = {\n \"usage: tiffinfo [options] input...\","}
{"scenario": "lighttpd-bug-1913-1914.tar.gz", "repairActions": ["Adds If Statement"], "lines": 2, "problem": " cgi_env_add(&env, CONST_STR_LEN(\"HTTPS\"), CONST_STR_LEN(\"on\"));\n }\n ltostr(buf, con->request.content_length);\n cgi_env_add(&env, CONST_STR_LEN(\"CONTENT_LENGTH\"), buf, strlen(buf));\n cgi_env_add(&env, CONST_STR_LEN(\"SCRIPT_FILENAME\"), CONST_BUF_LEN(con->physical.path));\n cgi_env_add(&env, CONST_STR_LEN(\"SCRIPT_NAME\"), CONST_BUF_LEN(con->uri.path));\n cgi_env_add(&env, CONST_STR_LEN(\"DOCUMENT_ROOT\"), CONST_BUF_LEN(con->physical.doc_root));", "fixed": " cgi_env_add(&env, CONST_STR_LEN(\"HTTPS\"), CONST_STR_LEN(\"on\"));\n }\nif (con->request.content_length > 0) {\n ltostr(buf, con->request.content_length);\n cgi_env_add(&env, CONST_STR_LEN(\"CONTENT_LENGTH\"), buf, strlen(buf));\n}\n cgi_env_add(&env, CONST_STR_LEN(\"SCRIPT_FILENAME\"), CONST_BUF_LEN(con->physical.path));\n cgi_env_add(&env, CONST_STR_LEN(\"SCRIPT_NAME\"), CONST_BUF_LEN(con->uri.path));\n cgi_env_add(&env, CONST_STR_LEN(\"DOCUMENT_ROOT\"), CONST_BUF_LEN(con->physical.doc_root));"}
{"scenario": "php-bug-2011-01-18-b5e12bd4da-163b3bcec9.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable"], "lines": 33, "problem": " }\n PHP_FUNCTION(dom_document_save_html)\n {\nzval *id;\n xmlDoc *docp;\ndom_object *intern;\nxmlChar *mem;\n int size, format;\n dom_doc_propsptr doc_props;\nif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &id, dom_document_class_entry) == FAILURE) {\n return;\n }\n DOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n doc_props = dom_get_doc_props(intern->document);\n format = doc_props->formatoutput;\n htmlDocDumpMemoryFormat(docp, &mem, &size, format);\n htmlDocDumpMemory(docp, &mem, &size);\n if (!size) {\n if (mem)\n xmlFree(mem);\nRETURN_FALSE;\n }\nRETVAL_STRINGL(mem, size, 1);\nxmlFree(mem);\n }\n PHP_METHOD(domdocument, registerNodeClass)", "fixed": " }\n PHP_FUNCTION(dom_document_save_html)\n {\nzval *id, *nodep = NULL;\n xmlDoc *docp;\nxmlNode *node;\nxmlBufferPtr buf;\ndom_object *intern, *nodeobj;\nxmlChar *mem = NULL;\n int size, format;\n dom_doc_propsptr doc_props;\nif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(),\n\"O|O!\", &id, dom_document_class_entry, &nodep, dom_node_class_entry)\n== FAILURE) {\n return;\n }\n DOM_GET_OBJ(docp, id, xmlDocPtr, intern);\n doc_props = dom_get_doc_props(intern->document);\n format = doc_props->formatoutput;\nif (nodep != NULL) {\nDOM_GET_OBJ(node, nodep, xmlNodePtr, nodeobj);\nif (node->doc != docp) {\nphp_dom_throw_error(WRONG_DOCUMENT_ERR, dom_get_strict_error(intern->document) TSRMLS_CC);\nRETURN_FALSE;\n}\nbuf = xmlBufferCreate();\nif (!buf) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not fetch buffer\");\nRETURN_FALSE;\n}\nxmlNodeDump(buf, docp, node, 0, format);\nmem = (xmlChar*) xmlBufferContent(buf);\nif (!mem) {\nRETVAL_FALSE;\n} else {\nRETVAL_STRING(mem, 1);\n}\nxmlBufferFree(buf);\n} else {\n htmlDocDumpMemoryFormat(docp, &mem, &size, format);\n htmlDocDumpMemory(docp, &mem, &size);\n if (!size) {\nRETVAL_FALSE;\n} else {\nRETVAL_STRINGL(mem, size, 1);\n}\n if (mem)\n xmlFree(mem);\n }\n }\n PHP_METHOD(domdocument, registerNodeClass)"}
{"scenario": "php-bug-2011-04-07-d3274b7f20-77ed819430.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Loop"], "lines": 25, "problem": " } else {\n if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {\n zend_error(E_NOTICE,\"Undefined index:  %s\", Z_STRVAL_P(offset));\n }\n }\n break;", "fixed": " } else {\n if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {\n zend_error(E_NOTICE,\"Undefined index:  %s\", Z_STRVAL_P(offset));\n} else {\nspl_array_object *obj = intern;\nwhile (1) {\nif ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) {\nbreak;\n} else if (Z_TYPE_P(obj->array) == IS_OBJECT) {\nif ((obj->ar_flags & SPL_ARRAY_USE_OTHER) == 0) {\nobj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);\nbreak;\n} else {\nobj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);\n}\n} else {\nobj = NULL;\nbreak;\n}\n}\nif (obj) {\nzend_property_info *property_info = zend_get_property_info(obj->std.ce, offset, 1 TSRMLS_CC);\nif (property_info &&\n(property_info->flags & ZEND_ACC_STATIC) == 0 &&\nproperty_info->offset >= 0) {\nobj->std.properties_table[property_info->offset] = NULL;\n}\n}\n }\n }\n break;"}
{"scenario": "php-bug-2011-05-13-db0c957f02-8ba00176f1.tar.gz", "repairActions": ["Changes Condition"], "lines": 7, "problem": " fnname_len = strlen(fn->common.function_name);\n if (aliases) {\n while (aliases[i]) {\nif (!aliases[i]->trait_method->ce || (fn->common.scope == aliases[i]->trait_method->ce &&\n (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,\n aliases[i]->trait_method->mname_len,\nfn->common.function_name, fnname_len) == 0))) {\n if (aliases[i]->alias) {\n fn_copy = *fn;\n zend_traits_duplicate_function(&fn_copy, estrndup(aliases[i]->alias, aliases[i]->alias_len) TSRMLS_CC);\n if (aliases) {\n i = 0;\n while (aliases[i]) {\nif ((!aliases[i]->trait_method->ce || fn->common.scope == aliases[i]->trait_method->ce) &&\n (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,\n aliases[i]->trait_method->mname_len,\n fn->common.function_name, fnname_len) == 0)) {", "fixed": " fnname_len = strlen(fn->common.function_name);\n if (aliases) {\n while (aliases[i]) {\nif (\n(!aliases[i]->trait_method->ce || fn->common.scope == aliases[i]->trait_method->ce)\n&&\n (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,\n aliases[i]->trait_method->mname_len,\nfn->common.function_name, fnname_len) == 0)) {\n if (aliases[i]->alias) {\n fn_copy = *fn;\n zend_traits_duplicate_function(&fn_copy, estrndup(aliases[i]->alias, aliases[i]->alias_len) TSRMLS_CC);\n if (aliases) {\n i = 0;\n while (aliases[i]) {\nif (\n(!aliases[i]->trait_method->ce || fn->common.scope == aliases[i]->trait_method->ce)\n&&\n (zend_binary_strcasecmp(aliases[i]->trait_method->method_name,\n aliases[i]->trait_method->mname_len,\n fn->common.function_name, fnname_len) == 0)) {"}
{"scenario": "php-bug-2011-10-31-c4eb5f2387-2e5d5e5ac6.tar.gz", "repairActions": [], "lines": 3, "problem": " {\n zend_object *object;\n if (class_type->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\nchar *what = class_type->ce_flags & ZEND_ACC_INTERFACE ? \"interface\" : \"abstract class\";\n zend_error(E_ERROR, \"Cannot instantiate %s %s\", what, class_type->name);\n }\n zend_update_class_constants(class_type TSRMLS_CC);", "fixed": " {\n zend_object *object;\n if (class_type->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\nchar *what =   (class_type->ce_flags & ZEND_ACC_INTERFACE)                ? \"interface\"\n:((class_type->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) ? \"trait\"\n:                                                              \"abstract class\";\n zend_error(E_ERROR, \"Cannot instantiate %s %s\", what, class_type->name);\n }\n zend_update_class_constants(class_type TSRMLS_CC);"}
{"scenario": "gzip-bug-2009-10-09-1a085b1446-118a107f2d.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 5, "problem": " magic[1] = (char) imagic1;\n } else {\n magic[0] = (char)get_byte();\n magic[1] = (char)get_byte();\n imagic1 = 0;\n }\n method = -1;\n part_nb++;", "fixed": " magic[1] = (char) imagic1;\n } else {\n magic[0] = (char)get_byte();\nif (magic[0]) {\n magic[1] = (char)get_byte();\n imagic1 = 0;\n} else {\nimagic1 = try_byte ();\nmagic[1] = (char) imagic1;\n}\n }\n method = -1;\n part_nb++;"}
{"scenario": "lighttpd-bug-2254-2259.tar.gz", "repairActions": ["Changes Condition"], "lines": 3, "problem": " for (i = 0; i < 8; i++) {\n ts = (ts << 4) + hex2int(*(ts_str + i));\n }\nif (srv->cur_ts - ts > p->conf.timeout ||\nsrv->cur_ts - ts < -p->conf.timeout) {\n if (con->conf.log_request_handling) {\n TRACE(\"timestamp is too old: %ld, timeout: %d\", ts, p->conf.timeout);\n }\ncon->http_status = 408;\n return HANDLER_FINISHED;\n }\n rel_uri = ts_str + 8;", "fixed": " for (i = 0; i < 8; i++) {\n ts = (ts << 4) + hex2int(*(ts_str + i));\n }\nif ( (srv->cur_ts > ts && srv->cur_ts - ts > p->conf.timeout) ||\n(srv->cur_ts < ts && ts - srv->cur_ts > p->conf.timeout) ) {\n if (con->conf.log_request_handling) {\n TRACE(\"timestamp is too old: %ld, timeout: %d\", ts, p->conf.timeout);\n }\ncon->http_status = 410;\n return HANDLER_FINISHED;\n }\n rel_uri = ts_str + 8;"}
