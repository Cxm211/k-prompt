{"scenario": "valgrind-bug-11621-11622.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 22, "problem": " static Thread** map_threads = NULL; \n \n static WordFM* map_locks = NULL; \nstatic WordSetU* univ_tsets = NULL; \n static WordSetU* univ_lsets = NULL; \n static WordSetU* univ_laog  = NULL; \n \n static Lock* mk_LockN ( LockKind kind, Addr guestaddr ) {\n static ULong unique = 0;\n Lock* lock             = HG_(zalloc)( \"hg.mk_Lock.1\", sizeof(Lock) );\nlock->admin_next       = admin_locks;\nlock->admin_prev       = NULL;\n if (admin_locks)\n admin_locks->admin_prev = lock;\n admin_locks            = lock;\n lock->unique           = unique++;\n lock->magic            = LockN_MAGIC;\n lock->appeared_at      = NULL;\n libhb_so_dealloc(lk->hbso);\n if (lk->heldBy)\n VG_(deleteBag)( lk->heldBy );\nif (admin_locks == lk) {\n admin_locks = lk->admin_next;\nif (admin_locks)\nadmin_locks->admin_prev = NULL;\n }\n else {\n lk->admin_prev->admin_next = lk->admin_next;\n lk->admin_next->admin_prev = lk->admin_prev;\n }\n VG_(memset)(lk, 0xAA, sizeof(*lk));\n HG_(free)(lk);\n }\n map_locks = VG_(newFM)( HG_(zalloc), \"hg.ids.2\", HG_(free),\n NULL);\n tl_assert(map_locks != NULL);\ntl_assert(univ_tsets == NULL);\nuniv_tsets = HG_(newWordSetU)( HG_(zalloc), \"hg.ids.3\", HG_(free),\n8 );\ntl_assert(univ_tsets != NULL);\n tl_assert(univ_lsets == NULL);\n univ_lsets = HG_(newWordSetU)( HG_(zalloc), \"hg.ids.4\", HG_(free),\n 8 );\n if (VG_(clo_stats)) {\n if (1) {\n VG_(printf)(\"\\n\");\nHG_(ppWSUstats)( univ_tsets, \"univ_tsets\" );\nVG_(printf)(\"\\n\");\n HG_(ppWSUstats)( univ_lsets, \"univ_lsets\" );\n if (HG_(clo_track_lockorders)) {\n VG_(printf)(\"\\n\");\n VG_(printf)(\"\\n\");\n VG_(printf)(\"        locksets: %'8d unique lock sets\\n\",\n (Int)HG_(cardinalityWSU)( univ_lsets ));\nVG_(printf)(\"      threadsets: %'8d unique thread sets\\n\",\n(Int)HG_(cardinalityWSU)( univ_tsets ));\n if (HG_(clo_track_lockorders)) {\n VG_(printf)(\"       univ_laog: %'8d unique lock sets\\n\",\n (Int)HG_(cardinalityWSU)( univ_laog ));", "fixed": " static Thread** map_threads = NULL; \n \n static WordFM* map_locks = NULL; \n static WordSetU* univ_lsets = NULL; \n static WordSetU* univ_laog  = NULL; \n \n static Lock* mk_LockN ( LockKind kind, Addr guestaddr ) {\n static ULong unique = 0;\n Lock* lock             = HG_(zalloc)( \"hg.mk_Lock.1\", sizeof(Lock) );\n if (admin_locks)\n admin_locks->admin_prev = lock;\nlock->admin_next       = admin_locks;\nlock->admin_prev       = NULL;\n admin_locks            = lock;\n lock->unique           = unique++;\n lock->magic            = LockN_MAGIC;\n lock->appeared_at      = NULL;\n libhb_so_dealloc(lk->hbso);\n if (lk->heldBy)\n VG_(deleteBag)( lk->heldBy );\nif (lk == admin_locks) {\ntl_assert(lk->admin_prev == NULL);\nif (lk->admin_next)\nlk->admin_next->admin_prev = NULL;\n admin_locks = lk->admin_next;\n }\n else {\ntl_assert(lk->admin_prev != NULL);\n lk->admin_prev->admin_next = lk->admin_next;\nif (lk->admin_next)\n lk->admin_next->admin_prev = lk->admin_prev;\n }\n VG_(memset)(lk, 0xAA, sizeof(*lk));\n HG_(free)(lk);\n }\n map_locks = VG_(newFM)( HG_(zalloc), \"hg.ids.2\", HG_(free),\n NULL);\n tl_assert(map_locks != NULL);\n tl_assert(univ_lsets == NULL);\n univ_lsets = HG_(newWordSetU)( HG_(zalloc), \"hg.ids.4\", HG_(free),\n 8 );\n if (VG_(clo_stats)) {\n if (1) {\n VG_(printf)(\"\\n\");\n HG_(ppWSUstats)( univ_lsets, \"univ_lsets\" );\n if (HG_(clo_track_lockorders)) {\n VG_(printf)(\"\\n\");\n VG_(printf)(\"\\n\");\n VG_(printf)(\"        locksets: %'8d unique lock sets\\n\",\n (Int)HG_(cardinalityWSU)( univ_lsets ));\n if (HG_(clo_track_lockorders)) {\n VG_(printf)(\"       univ_laog: %'8d unique lock sets\\n\",\n (Int)HG_(cardinalityWSU)( univ_laog ));"}
{"scenario": "php-bug-2012-03-22-3efc9f2f78-2e19cccad7.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition"], "lines": 22, "problem": " spl_filesystem_file_free_line(intern TSRMLS_CC);\n break;\n }\n{\nzend_object_iterator *iterator;\niterator = (zend_object_iterator*)\nspl_filesystem_object_to_iterator(intern);\nif (iterator->data != NULL) {\niterator->data = NULL;\niterator->funcs->dtor(iterator TSRMLS_CC);\n}\n}\n efree(object);\n }\n static zend_object_value spl_filesystem_object_new_ex(zend_class_entry *class_type, spl_filesystem_object **obj TSRMLS_DC)\n }\n dir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n iterator   = spl_filesystem_object_to_iterator(dir_object);\nif (iterator->intern.data == NULL) {\niterator->intern.data = object;\n iterator->intern.funcs = &spl_filesystem_dir_it_funcs;\n iterator->current = object;\n}\nzval_add_ref(&object);\n return (zend_object_iterator*)iterator;\n }\n static void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n static void spl_filesystem_tree_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n {\n spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\nif (iterator->intern.data) {\nzval *object = \titerator->intern.data;\nzval_ptr_dtor(&object);\n} else {\n if (iterator->current) {\n zval_ptr_dtor(&iterator->current);\n }\n }\n}\n static void spl_filesystem_tree_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n {\n spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n }\n dir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n iterator   = spl_filesystem_object_to_iterator(dir_object);\nif (iterator->intern.data == NULL) {\niterator->intern.data = object;\n iterator->intern.funcs = &spl_filesystem_tree_it_funcs;\n}\nzval_add_ref(&object);\n return (zend_object_iterator*)iterator;\n }\n static int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TSRMLS_DC)", "fixed": " spl_filesystem_file_free_line(intern TSRMLS_CC);\n break;\n }\n efree(object);\n }\n static zend_object_value spl_filesystem_object_new_ex(zend_class_entry *class_type, spl_filesystem_object **obj TSRMLS_DC)\n }\n dir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n iterator   = spl_filesystem_object_to_iterator(dir_object);\nZ_SET_REFCOUNT_P(object, Z_REFCOUNT_P(object) + 2);\niterator->intern.data = (void*)object;\n iterator->intern.funcs = &spl_filesystem_dir_it_funcs;\n iterator->current = object;\n return (zend_object_iterator*)iterator;\n }\n static void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n static void spl_filesystem_tree_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n {\n spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\nzval *zfree = (zval*)iterator->intern.data;\n if (iterator->current) {\n zval_ptr_dtor(&iterator->current);\n }\niterator->intern.data = NULL;\nzval_ptr_dtor(&zfree);\nzval_ptr_dtor(&zfree);\n }\n static void spl_filesystem_tree_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n {\n spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n }\n dir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n iterator   = spl_filesystem_object_to_iterator(dir_object);\nZ_SET_REFCOUNT_P(object, Z_REFCOUNT_P(object) + 2);\niterator->intern.data = (void*)object;\n iterator->intern.funcs = &spl_filesystem_tree_it_funcs;\niterator->current = NULL;\n return (zend_object_iterator*)iterator;\n }\n static int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TSRMLS_DC)"}
{"scenario": "wireshark-bug-37190-37191.tar.gz", "repairActions": ["Changes Method Signature", "Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable", "Adds Loop", "Adds Method"], "lines": 162, "problem": " static gboolean capture_child = FALSE;\n static gchar *sig_pipe_name = NULL;\n INITFILTER_BAD_FILTER,\n INITFILTER_OTHER_ERROR\n } initfilter_status_t;\n typedef struct _pcap_options {\n pcap_t         *pcap_h;\n static const char *cap_pipe_err_str;\n static void\n console_log_handler(const char *log_domain, GLogLevelFlags log_level,\n const char *message, gpointer user_data _U_);\n static capture_options global_capture_opts;\n static gboolean quiet = FALSE;\nstatic void capture_loop_packet_cb(u_char *user, const struct pcap_pkthdr *phdr,\n const u_char *pd);\n static void capture_loop_get_errmsg(char *errmsg, int errmsglen, const char *fname,\n int err, gboolean is_close);\n static void WS_MSVC_NORETURN exit_main(int err) G_GNUC_NORETURN;\n fprintf(output, \"                              files:NUM - ringbuffer: replace after NUM files\\n\");\n fprintf(output, \"  -n                       use pcapng format instead of pcap\\n\");\n fprintf(output, \"Miscellaneous:\\n\");\n fprintf(output, \"  -q                       don't report packet capture counts\\n\");\n fprintf(output, \"  -v                       print version information and exit\\n\");\n fprintf(output, \"  -h                       display this help and exit\\n\");\n phdr.ts.tv_usec = pcap_opts->cap_pipe_rechdr.hdr.ts_usec;\n phdr.caplen = pcap_opts->cap_pipe_rechdr.hdr.incl_len;\n phdr.len = pcap_opts->cap_pipe_rechdr.hdr.orig_len;\ncapture_loop_packet_cb((u_char *)ld, &phdr, data);\n pcap_opts->cap_pipe_state = STATE_EXPECT_REC_HDR;\n return 1;\n case PD_PIPE_EOF:\n return FALSE;\n }\n for (i = 0; i < capture_opts->ifaces->len; i++) {\n interface_opts = g_array_index(capture_opts->ifaces, interface_options, i);\n pcap_opts.pcap_h = NULL;\n }\n }\n static int\ncapture_loop_dispatch(capture_options *capture_opts _U_, loop_data *ld,\n char *errmsg, int errmsg_len, pcap_options *pcap_opts)\n {\n int       inpkts;\n if (pcap_opts->pcap_fd != -1) {\n sel_ret = cap_pipe_select(pcap_opts->pcap_fd);\n if (sel_ret > 0) {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, 1, capture_loop_packet_cb,\n (u_char *)&(pcap_opts->interface_id));\n if (inpkts < 0) {\n if (inpkts == -1) {\n pcap_opts->pcap_err = TRUE;\n g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_DEBUG, \"capture_loop_dispatch: from pcap_dispatch\");\ninpkts = pcap_dispatch(pcap_opts->pcap_h, 1, capture_loop_packet_cb, (u_char *) ld);\ninpkts = pcap_dispatch(pcap_opts->pcap_h, -1, capture_loop_packet_cb, (u_char *) ld);\n if (inpkts < 0) {\n if (inpkts == -1) {\n u_char *pkt_data;\n in = 0;\n while(ld->go &&\n(in = pcap_next_ex(pcap_opts->pcap_h, &pkt_header, &pkt_data)) == 1)\ncapture_loop_packet_cb( (u_char *) ld, pkt_header, pkt_data);\n if(in < 0) {\n pcap_opts->pcap_err = TRUE;\n ld->go = FALSE;\n }\n return TRUE;\n }\n static gboolean\n capture_loop_start(capture_options *capture_opts, gboolean *stats_known, struct pcap_stat *stats)\n {\n gettimeofday(&upd_time, NULL);\n g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Capture loop running!\");\n while (global_ld.go) {\ninpkts = capture_loop_dispatch(capture_opts, &global_ld, errmsg,\n sizeof(errmsg), &pcap_opts);\n if (global_ld.report_packet_count) {\n fprintf(stderr, \"%u packet%s captured\\n\", global_ld.packet_count,\n }\n }\n g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Capture loop stopping ...\");\n if (cnd_file_duration != NULL)\n cnd_delete(cnd_file_duration);\n if (cnd_autostop_files != NULL)\n }\n }\n static void\ncapture_loop_packet_cb(u_char *user, const struct pcap_pkthdr *phdr,\n const u_char *pd)\n {\nloop_data *ld = (loop_data *) (void *) user;\n int err;\nif (!ld->go)\n return;\nif (ld->pdh) {\n gboolean successful;\n if (global_capture_opts.use_pcapng) {\nsuccessful = libpcap_write_enhanced_packet_block(ld->pdh, phdr, 0, pd, &ld->bytes_written, &err);\n } else {\nsuccessful = libpcap_write_packet(ld->pdh, phdr, pd, &ld->bytes_written, &err);\n }\n if (!successful) {\nld->go = FALSE;\nld->err = err;\n } else {\nld->packet_count++;\nif ((ld->packet_max > 0) && (ld->packet_count >= ld->packet_max)) {\nld->go = FALSE;\n }\n }\n }\n }\n int\n main(int argc, char *argv[])\n {\n if ((debug_log = ws_fopen(\"dumpcap_debug_log.tmp\",\"w\")) == NULL) {\n fprintf (stderr, \"Unable to open debug log file !\\n\");\n break;\n case 'q':\n quiet = TRUE;\n break;\n case 'D':\n list_interfaces = TRUE;", "fixed": "static GAsyncQueue *pcap_queue;\n static gboolean capture_child = FALSE;\n static gchar *sig_pipe_name = NULL;\n INITFILTER_BAD_FILTER,\n INITFILTER_OTHER_ERROR\n } initfilter_status_t;\ntypedef struct _pcap_queue_element {\nguint              interface_id;\nstruct pcap_pkthdr phdr;\nu_char             *pd;\n} pcap_queue_element;\n typedef struct _pcap_options {\n pcap_t         *pcap_h;\n static const char *cap_pipe_err_str;\n static void\n console_log_handler(const char *log_domain, GLogLevelFlags log_level,\n const char *message, gpointer user_data _U_);\n static capture_options global_capture_opts;\n static gboolean quiet = FALSE;\nstatic gboolean use_threads = FALSE;\nstatic void capture_loop_write_packet_cb(u_char *user, const struct pcap_pkthdr *phdr,\n const u_char *pd);\nstatic void capture_loop_queue_packet_cb(u_char *user, const struct pcap_pkthdr *phdr,\nconst u_char *pd);\n static void capture_loop_get_errmsg(char *errmsg, int errmsglen, const char *fname,\n int err, gboolean is_close);\n static void WS_MSVC_NORETURN exit_main(int err) G_GNUC_NORETURN;\n fprintf(output, \"                              files:NUM - ringbuffer: replace after NUM files\\n\");\n fprintf(output, \"  -n                       use pcapng format instead of pcap\\n\");\n fprintf(output, \"Miscellaneous:\\n\");\nfprintf(output, \"  -t                       use a separate thread per interface\\n\");\n fprintf(output, \"  -q                       don't report packet capture counts\\n\");\n fprintf(output, \"  -v                       print version information and exit\\n\");\n fprintf(output, \"  -h                       display this help and exit\\n\");\n phdr.ts.tv_usec = pcap_opts->cap_pipe_rechdr.hdr.ts_usec;\n phdr.caplen = pcap_opts->cap_pipe_rechdr.hdr.incl_len;\n phdr.len = pcap_opts->cap_pipe_rechdr.hdr.orig_len;\nif (use_threads) {\ncapture_loop_queue_packet_cb((u_char *)&pcap_opts->interface_id, &phdr, data);\n} else {\ncapture_loop_write_packet_cb((u_char *)&pcap_opts->interface_id, &phdr, data);\n}\n pcap_opts->cap_pipe_state = STATE_EXPECT_REC_HDR;\n return 1;\n case PD_PIPE_EOF:\n return FALSE;\n }\nif ((use_threads == FALSE) &&\n(capture_opts->ifaces->len > 1)) {\ng_snprintf(errmsg, errmsg_len,\n\"Using threads is required for capturing on mulitple interfaces! Use the -t option.\");\nreturn FALSE;\n}\n for (i = 0; i < capture_opts->ifaces->len; i++) {\n interface_opts = g_array_index(capture_opts->ifaces, interface_options, i);\n pcap_opts.pcap_h = NULL;\n }\n }\n static int\ncapture_loop_dispatch(loop_data *ld,\n char *errmsg, int errmsg_len, pcap_options *pcap_opts)\n {\n int       inpkts;\n if (pcap_opts->pcap_fd != -1) {\n sel_ret = cap_pipe_select(pcap_opts->pcap_fd);\n if (sel_ret > 0) {\nif (use_threads) {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, 1, capture_loop_queue_packet_cb,\n (u_char *)&(pcap_opts->interface_id));\n} else {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, 1, capture_loop_write_packet_cb,\n(u_char *)&(pcap_opts->interface_id));\n}\n if (inpkts < 0) {\n if (inpkts == -1) {\n pcap_opts->pcap_err = TRUE;\n g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_DEBUG, \"capture_loop_dispatch: from pcap_dispatch\");\nif (use_threads) {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, 1, capture_loop_queue_packet_cb, (u_char *)&pcap_opts->interface_id);\n} else {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, 1, capture_loop_write_packet_cb, (u_char *)&pcap_opts->interface_id);\n}\nif (use_threads) {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, -1, capture_loop_queue_packet_cb, (u_char *)&pcap_opts->interface_id);\n} else {\ninpkts = pcap_dispatch(pcap_opts->pcap_h, -1, capture_loop_write_packet_cb, (u_char *)&pcap_opts->interface_id);\n}\n if (inpkts < 0) {\n if (inpkts == -1) {\n u_char *pkt_data;\n in = 0;\n while(ld->go &&\n(in = pcap_next_ex(pcap_opts->pcap_h, &pkt_header, &pkt_data)) == 1) {\nif (use_threads) {\ncapture_loop_queue_packet_cb((u_char *)&pcap_opts->interface_id, pkt_header, pkt_data);\n} else {\ncapture_loop_write_packet_cb((u_char *)&pcap_opts->interface_id, pkt_header, pkt_data);\n}\n}\n if(in < 0) {\n pcap_opts->pcap_err = TRUE;\n ld->go = FALSE;\n }\n return TRUE;\n }\nstatic void *\npcap_read_handler(void* arg)\n{\npcap_options pcap_opts;\nguint interface_id;\nchar errmsg[MSG_MAX_LENGTH+1];\ninterface_id = *(guint *)arg;\ng_free(arg);\npcap_opts = g_array_index(global_ld.pcaps, pcap_options, interface_id);\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Started thread for interface %d.\",\ninterface_id);\nwhile (global_ld.go) {\ncapture_loop_dispatch(&global_ld, errmsg, sizeof(errmsg), &pcap_opts);\n}\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Stopped thread for interface %d.\",\ninterface_id);\ng_thread_exit(NULL);\nreturn (NULL);\n}\n static gboolean\n capture_loop_start(capture_options *capture_opts, gboolean *stats_known, struct pcap_stat *stats)\n {\n gettimeofday(&upd_time, NULL);\n g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Capture loop running!\");\nif (use_threads) {\npcap_queue = g_async_queue_new();\nfor (i = 0; i < global_ld.pcaps->len; i++) {\ngint *interface_id;\ninterface_id = (gint *)g_malloc(sizeof(guint));\n*interface_id = i;\npcap_opts = g_array_index(global_ld.pcaps, pcap_options, i);\npcap_opts.tid = g_thread_create(pcap_read_handler, interface_id, TRUE, NULL);\nglobal_ld.pcaps = g_array_remove_index(global_ld.pcaps, i);\ng_array_insert_val(global_ld.pcaps, i, pcap_opts);\n}\n}\n while (global_ld.go) {\nif (use_threads) {\nGTimeVal    write_thread_time;\npcap_queue_element *queue_element;\ng_get_current_time(&write_thread_time);\ng_time_val_add(&write_thread_time, WRITER_THREAD_TIMEOUT);\nqueue_element = g_async_queue_timed_pop(pcap_queue, &write_thread_time);\nif (queue_element) {\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO,\n\"Dequeued a packet of length %d captured on interface %d.\",\nqueue_element->phdr.caplen,queue_element->interface_id);\ncapture_loop_write_packet_cb((u_char *)&queue_element->interface_id,\n&queue_element->phdr,\nqueue_element->pd);\ng_free(queue_element->pd);\ng_free(queue_element);\ninpkts = 1;\n} else {\ninpkts = 0;\n}\n} else {\ninpkts = capture_loop_dispatch(&global_ld, errmsg,\n sizeof(errmsg), &pcap_opts);\n}\n if (global_ld.report_packet_count) {\n fprintf(stderr, \"%u packet%s captured\\n\", global_ld.packet_count,\n }\n }\n g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Capture loop stopping ...\");\nif (use_threads) {\npcap_queue_element *queue_element;\nfor (i = 0; i < global_ld.pcaps->len; i++) {\npcap_opts = g_array_index(global_ld.pcaps, pcap_options, i);\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Waiting for thread of interface %u...\",\npcap_opts.interface_id);\ng_thread_join(pcap_opts.tid);\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO, \"Thread of interface %u terminated.\",\npcap_opts.interface_id);\n}\nwhile ((queue_element = g_async_queue_try_pop(pcap_queue))) {\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO,\n\"Dequeued a packet of length %d captured on interface %d.\",\nqueue_element->phdr.caplen,queue_element->interface_id);\ncapture_loop_write_packet_cb((u_char *)&queue_element->interface_id,\n&queue_element->phdr,\nqueue_element->pd);\ng_free(queue_element->pd);\ng_free(queue_element);\nglobal_ld.inpkts_to_sync_pipe += 1;\nif (capture_opts->output_to_pipe) {\nlibpcap_dump_flush(global_ld.pdh, NULL);\n}\n}\n}\n if (cnd_file_duration != NULL)\n cnd_delete(cnd_file_duration);\n if (cnd_autostop_files != NULL)\n }\n }\n static void\ncapture_loop_write_packet_cb(u_char *user, const struct pcap_pkthdr *phdr,\n const u_char *pd)\n {\nguint interface_id = *(guint *) (void *) user;\n int err;\nif (!global_ld.go)\n return;\nif (global_ld.pdh) {\n gboolean successful;\n if (global_capture_opts.use_pcapng) {\nsuccessful = libpcap_write_enhanced_packet_block(global_ld.pdh, phdr, interface_id, pd, &global_ld.bytes_written, &err);\n } else {\nsuccessful = libpcap_write_packet(global_ld.pdh, phdr, pd, &global_ld.bytes_written, &err);\n }\n if (!successful) {\nglobal_ld.go = FALSE;\nglobal_ld.err = err;\n } else {\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO,\n\"Wrote a packet of length %d captured on interface %u.\",\nphdr->caplen, interface_id);\nglobal_ld.packet_count++;\nif ((global_ld.packet_max > 0) && (global_ld.packet_count >= global_ld.packet_max)) {\nglobal_ld.go = FALSE;\n }\n }\n }\n }\nstatic void\ncapture_loop_queue_packet_cb(u_char *user, const struct pcap_pkthdr *phdr,\nconst u_char *pd)\n{\npcap_queue_element *queue_element;\nguint interface_id;\nif (!global_ld.go)\nreturn;\ninterface_id = *(guint *) (void *) user;\nqueue_element = (pcap_queue_element *)g_malloc(sizeof(pcap_queue_element));\nqueue_element->interface_id = interface_id;\nqueue_element->phdr = *phdr;\nqueue_element->pd = (u_char *)g_malloc(phdr->caplen);\nmemcpy(queue_element->pd, pd, phdr->caplen);\ng_async_queue_push(pcap_queue, queue_element);\ng_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO,\n\"Queued a packet of length %d captured on interface %u.\",\nphdr->caplen, interface_id);\n}\n int\n main(int argc, char *argv[])\n {\n if ((debug_log = ws_fopen(\"dumpcap_debug_log.tmp\",\"w\")) == NULL) {\n fprintf (stderr, \"Unable to open debug log file !\\n\");\n break;\n case 'q':\n quiet = TRUE;\nbreak;\ncase 't':\nuse_threads = TRUE;\n break;\n case 'D':\n list_interfaces = TRUE;"}
{"scenario": "libtiff-bug-2005-12-21-3b848a7-3edb9cd.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n if(EstimateStripByteCounts(tif, dir, dircount) < 0)\n goto bad;\n} else if (td->td_nstrips > 1\n && td->td_compression == COMPRESSION_NONE\n && td->td_stripbytecount[0] != td->td_stripbytecount[1]) {\n TIFFWarning(module,", "fixed": " _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n if(EstimateStripByteCounts(tif, dir, dircount) < 0)\n goto bad;\n} else if (td->td_nstrips > 2\n && td->td_compression == COMPRESSION_NONE\n && td->td_stripbytecount[0] != td->td_stripbytecount[1]) {\n TIFFWarning(module,"}
{"scenario": "valgrind-bug-12641-12642.tar.gz", "repairActions": ["Changes Condition"], "lines": 2, "problem": " vg_assert(cc);\n if (req_alignB < VG_MIN_MALLOC_SZB\n|| req_alignB > 1048576\n || VG_(log2)( req_alignB ) == -1 ) {\n VG_(printf)(\"VG_(arena_memalign)(%p, %lu, %lu)\\n\"\n \"bad alignment value %lu\\n\"", "fixed": " vg_assert(cc);\n if (req_alignB < VG_MIN_MALLOC_SZB\n|| req_alignB > 16 * 1024 * 1024\n || VG_(log2)( req_alignB ) == -1 ) {\n VG_(printf)(\"VG_(arena_memalign)(%p, %lu, %lu)\\n\"\n \"bad alignment value %lu\\n\""}
{"scenario": "libtiff-bug-2007-08-24-827b6bc-22da1d6.tar.gz", "repairActions": ["Changes Method Call Args", "Adds If Statement"], "lines": 20, "problem": " const char reason[] = \"for fields array\";\n TIFFField** tp;\n uint32 i;\nfor (i = 0; i < n; i++) {\nconst TIFFField *fip =\nTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\nif (fip) {\nTIFFErrorExt(tif->tif_clientdata, module,\n\"Field with tag %lu is already registered as \\\"%s\\\"\",\n(unsigned int) info[i].field_tag,\nfip->field_name);\nreturn 0;\n}\n}\n tif->tif_foundfield = NULL;\n if (tif->tif_fields && tif->tif_nfields > 0) {\n tif->tif_fields = (TIFFField**)\n return 0;\n }\n tp = tif->tif_fields + tif->tif_nfields;\nfor (i = 0; i < n; i++)\n*tp++ = (TIFFField *) (info + i);\nqsort(tif->tif_fields, tif->tif_nfields += n,\n sizeof(TIFFField *), tagCompare);\n return n;\n }", "fixed": " const char reason[] = \"for fields array\";\n TIFFField** tp;\n uint32 i;\n tif->tif_foundfield = NULL;\n if (tif->tif_fields && tif->tif_nfields > 0) {\n tif->tif_fields = (TIFFField**)\n return 0;\n }\n tp = tif->tif_fields + tif->tif_nfields;\nfor (i = 0; i < n; i++) {\nconst TIFFField *fip =\nTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\nif (!fip) {\ntif->tif_fields[tif->tif_nfields] = (TIFFField *) (info+i);\ntif->tif_nfields++;\n}\n}\nqsort(tif->tif_fields, tif->tif_nfields,\n sizeof(TIFFField *), tagCompare);\n return n;\n }"}
{"scenario": "php-bug-2012-03-11-3954743813-d4f05fbffc.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " }\n object = getThis();\n if (message) {\nzend_update_property_string(default_exception_ce, object, \"message\", sizeof(\"message\")-1, message TSRMLS_CC);\n }\n if (code) {\n zend_update_property_long(default_exception_ce, object, \"code\", sizeof(\"code\")-1, code TSRMLS_CC);", "fixed": " }\n object = getThis();\n if (message) {\nzend_update_property_stringl(default_exception_ce, object, \"message\", sizeof(\"message\")-1, message, message_len TSRMLS_CC);\n }\n if (code) {\n zend_update_property_long(default_exception_ce, object, \"code\", sizeof(\"code\")-1, code TSRMLS_CC);"}
{"scenario": "php-bug-2012-01-29-d8b312845c-dc27324dd9.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Loop", "Adds Method"], "lines": 99, "problem": " }\n efree(func);\n }\n }\n static int sqlite_handle_closer(pdo_dbh_t *dbh TSRMLS_DC)\n {\n pdo_sqlite_db_handle *H = (pdo_sqlite_db_handle *)dbh->driver_data;\n TSRMLS_FETCH();\n do_callback(&func->afini, func->fini, 0, NULL, context, 1 TSRMLS_CC);\n }\n static PHP_METHOD(SQLite, sqliteCreateFunction)\n {\n struct pdo_sqlite_func *func;\n efree(func);\n RETURN_FALSE;\n }\n static const zend_function_entry dbh_methods[] = {\n PHP_ME(SQLite, sqliteCreateFunction, NULL, ZEND_ACC_PUBLIC)\n PHP_ME(SQLite, sqliteCreateAggregate, NULL, ZEND_ACC_PUBLIC)\n PHP_FE_END\n };\n static const zend_function_entry *get_driver_methods(pdo_dbh_t *dbh, int kind TSRMLS_DC)", "fixed": " }\n efree(func);\n }\nstruct pdo_sqlite_collation *collation;\nwhile (H->collations) {\ncollation = H->collations;\nH->collations = collation->next;\nif (H->db) {\nsqlite3_create_collation(H->db,\ncollation->name,\nSQLITE_UTF8,\ncollation,\nNULL);\n }\nefree((char*)collation->name);\nif (collation->callback) {\nzval_ptr_dtor(&collation->callback);\n}\nefree(collation);\n}\n}\n static int sqlite_handle_closer(pdo_dbh_t *dbh TSRMLS_DC)\n {\n pdo_sqlite_db_handle *H = (pdo_sqlite_db_handle *)dbh->driver_data;\n TSRMLS_FETCH();\n do_callback(&func->afini, func->fini, 0, NULL, context, 1 TSRMLS_CC);\n }\nstatic int php_sqlite3_collation_callback(void *context,\nint string1_len, const void *string1,\nint string2_len, const void *string2)\n{\nint ret;\nzval *zstring1, *zstring2;\nzval **zargs[2];\nzval *retval = NULL;\nstruct pdo_sqlite_collation *collation = (struct pdo_sqlite_collation*) context;\nTSRMLS_FETCH();\ncollation->fc.fci.size = sizeof(collation->fc.fci);\ncollation->fc.fci.function_table = EG(function_table);\ncollation->fc.fci.function_name = collation->callback;\ncollation->fc.fci.symbol_table = NULL;\ncollation->fc.fci.object_ptr = NULL;\ncollation->fc.fci.retval_ptr_ptr = &retval;\nMAKE_STD_ZVAL(zstring1);\nZVAL_STRINGL(zstring1, (char *) string1, string1_len, 1);\nzargs[0] = &zstring1;\nMAKE_STD_ZVAL(zstring2);\nZVAL_STRINGL(zstring2, (char *) string2, string2_len, 1);\nzargs[1] = &zstring2;\ncollation->fc.fci.param_count = 2;\ncollation->fc.fci.params = zargs;\nif ((ret = zend_call_function(&collation->fc.fci, &collation->fc.fcc TSRMLS_CC)) == FAILURE) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"An error occurred while invoking the callback\");\n}\nelse if (retval) {\nif (Z_TYPE_P(retval) != IS_LONG) {\nconvert_to_long_ex(&retval);\n}\nret = 0;\nif (Z_LVAL_P(retval) > 0) {\nret = 1;\n}\nelse if (Z_LVAL_P(retval) < 0) {\nret = -1;\n}\nzval_ptr_dtor(&retval);\n}\nzval_ptr_dtor(zargs[0]);\nzval_ptr_dtor(zargs[1]);\nreturn ret;\n}\n static PHP_METHOD(SQLite, sqliteCreateFunction)\n {\n struct pdo_sqlite_func *func;\n efree(func);\n RETURN_FALSE;\n }\nstatic PHP_METHOD(SQLite, sqliteCreateCollation)\n{\nstruct pdo_sqlite_collation *collation;\nzval *callback;\nchar *collation_name;\nint collation_name_len;\nchar *cbname = NULL;\npdo_dbh_t *dbh;\npdo_sqlite_db_handle *H;\nint ret;\nif (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sz\",\n&collation_name, &collation_name_len, &callback)) {\nRETURN_FALSE;\n}\ndbh = zend_object_store_get_object(getThis() TSRMLS_CC);\nPDO_CONSTRUCT_CHECK;\nif (!zend_is_callable(callback, 0, &cbname TSRMLS_CC)) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"function '%s' is not callable\", cbname);\nefree(cbname);\nRETURN_FALSE;\n}\nefree(cbname);\nH = (pdo_sqlite_db_handle *)dbh->driver_data;\ncollation = (struct pdo_sqlite_collation*)ecalloc(1, sizeof(*collation));\nret = sqlite3_create_collation(H->db, collation_name, SQLITE_UTF8, collation, php_sqlite3_collation_callback);\nif (ret == SQLITE_OK) {\ncollation->name = estrdup(collation_name);\nMAKE_STD_ZVAL(collation->callback);\nMAKE_COPY_ZVAL(&callback, collation->callback);\ncollation->next = H->collations;\nH->collations = collation;\nRETURN_TRUE;\n}\nefree(collation);\nRETURN_FALSE;\n}\n static const zend_function_entry dbh_methods[] = {\n PHP_ME(SQLite, sqliteCreateFunction, NULL, ZEND_ACC_PUBLIC)\n PHP_ME(SQLite, sqliteCreateAggregate, NULL, ZEND_ACC_PUBLIC)\nPHP_ME(SQLite, sqliteCreateCollation, NULL, ZEND_ACC_PUBLIC)\n PHP_FE_END\n };\n static const zend_function_entry *get_driver_methods(pdo_dbh_t *dbh, int kind TSRMLS_DC)"}
{"scenario": "php-bug-2011-03-19-5d0c948296-8deb11c0c3.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 4, "problem": " intern->u.dir.index = 0;\n if (EG(exception) || intern->u.dir.dirp == NULL) {\n intern->u.dir.entry.d_name[0] = '\\0';\n } else {\n do {\n spl_filesystem_dir_read(intern TSRMLS_CC);", "fixed": " intern->u.dir.index = 0;\n if (EG(exception) || intern->u.dir.dirp == NULL) {\n intern->u.dir.entry.d_name[0] = '\\0';\nif (!EG(exception)) {\nzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0\nTSRMLS_CC, \"Failed to open directory \\\"%s\\\"\", path);\n}\n } else {\n do {\n spl_filesystem_dir_read(intern TSRMLS_CC);"}
{"scenario": "php-bug-2012-03-08-0169020e49-cdc512afb3.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " err_buf_p = zend_llist_get_next_ex(err_list, &pos), i++) {\n strcat(msg, *err_buf_p);\n if (i < count - 1) {\nl += brlen;\n }\n }\n free_msg = 1;", "fixed": " err_buf_p = zend_llist_get_next_ex(err_list, &pos), i++) {\n strcat(msg, *err_buf_p);\n if (i < count - 1) {\nstrcat(msg, br);\n }\n }\n free_msg = 1;"}
{"scenario": "valgrind-bug-12474-12475.tar.gz", "repairActions": ["Changes Condition"], "lines": 2, "problem": " {\n ThreadId vg_tid;\n vg_tid = VG_(get_running_tid)();\nif (DRD_(thread_address_on_any_stack)(addr)) {\n GenericErrInfo GEI = {\n .tid = DRD_(thread_get_running_tid)(),", "fixed": " {\n ThreadId vg_tid;\n vg_tid = VG_(get_running_tid)();\nif (!DRD_(get_check_stack_accesses)()\n&& DRD_(thread_address_on_any_stack)(addr)) {\n GenericErrInfo GEI = {\n .tid = DRD_(thread_get_running_tid)(),"}
{"scenario": "php-bug-2012-02-08-ff63c09e6f-6672171672.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " HashTable *ht;\n if (track_vars_array) {\n ht = Z_ARRVAL_P(track_vars_array);\nzend_hash_del(ht, var, var_len + 1);\n }\n zval_dtor(val);\n if (!PG(display_errors)) {", "fixed": " HashTable *ht;\n if (track_vars_array) {\n ht = Z_ARRVAL_P(track_vars_array);\nzend_symtable_del(ht, var, var_len + 1);\n }\n zval_dtor(val);\n if (!PG(display_errors)) {"}
{"scenario": "php-bug-2011-04-06-18d71a6f59-187eb235fe.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Variable"], "lines": 7, "problem": " add_next_index_stringl(return_value, (const char *)low, 1, 1);\n }\n } else if (Z_TYPE_P(zlow) == IS_DOUBLE || Z_TYPE_P(zhigh) == IS_DOUBLE || is_step_double) {\ndouble low, high;\n double_str:\n convert_to_double(zlow);\n convert_to_double(zhigh);\n low = Z_DVAL_P(zlow);\n high = Z_DVAL_P(zhigh);\n if (low > high) {\n if (low - high < step || step <= 0) {\n err = 1;\n goto err;\n }\nfor (; low >= (high - DOUBLE_DRIFT_FIX); low -= step) {\nadd_next_index_double(return_value, low);\n }\n } else if (high > low) {\n if (high - low < step || step <= 0) {\n err = 1;\n goto err;\n }\nfor (; low <= (high + DOUBLE_DRIFT_FIX); low += step) {\nadd_next_index_double(return_value, low);\n }\n } else {\n add_next_index_double(return_value, low);", "fixed": " add_next_index_stringl(return_value, (const char *)low, 1, 1);\n }\n } else if (Z_TYPE_P(zlow) == IS_DOUBLE || Z_TYPE_P(zhigh) == IS_DOUBLE || is_step_double) {\ndouble low, high, value;\nlong i;\n double_str:\n convert_to_double(zlow);\n convert_to_double(zhigh);\n low = Z_DVAL_P(zlow);\n high = Z_DVAL_P(zhigh);\ni = 0;\n if (low > high) {\n if (low - high < step || step <= 0) {\n err = 1;\n goto err;\n }\nfor (value = low; value >= (high - DOUBLE_DRIFT_FIX); value = low - (++i * step)) {\nadd_next_index_double(return_value, value);\n }\n } else if (high > low) {\n if (high - low < step || step <= 0) {\n err = 1;\n goto err;\n }\nfor (value = low; value <= (high + DOUBLE_DRIFT_FIX); value = low + (++i * step)) {\nadd_next_index_double(return_value, value);\n }\n } else {\n add_next_index_double(return_value, low);"}
{"scenario": "php-bug-2011-05-17-453c954f8a-daecb2c0f4.tar.gz", "repairActions": [], "lines": 1, "problem": " c.name_len = sizeof(\"NULL\");\n c.value.type = IS_NULL;\n zend_register_constant(&c TSRMLS_CC);\nc.flags = CONST_PERSISTENT | CONST_CS;\n c.name = zend_strndup(ZEND_STRL(\"ZEND_THREAD_SAFE\"));\n c.name_len = sizeof(\"ZEND_THREAD_SAFE\");\n c.value.value.lval = ZTS_V;", "fixed": " c.name_len = sizeof(\"NULL\");\n c.value.type = IS_NULL;\n zend_register_constant(&c TSRMLS_CC);\nc.flags = CONST_PERSISTENT;\n c.name = zend_strndup(ZEND_STRL(\"ZEND_THREAD_SAFE\"));\n c.name_len = sizeof(\"ZEND_THREAD_SAFE\");\n c.value.value.lval = ZTS_V;"}
{"scenario": "php-bug-2012-01-16-36df53421e-f32760bd40.tar.gz", "repairActions": [], "lines": 5, "problem": " return PHP_OUTPUT_HANDLER_FAILURE;\n }\n if (php_output_handler_append(handler, &context->in TSRMLS_CC) && !context->op) {\nstatus = PHP_OUTPUT_HANDLER_NO_DATA;\n } else {\n if (!(handler->flags & PHP_OUTPUT_HANDLER_STARTED)) {\n context->op |= PHP_OUTPUT_HANDLER_START;\n handler->buffer.used = 0;\n handler->buffer.size = 0;\n break;\ncase PHP_OUTPUT_HANDLER_SUCCESS:\nhandler->buffer.used = 0;\nbreak;\n case PHP_OUTPUT_HANDLER_NO_DATA:\n php_output_context_reset(context);\n break;\n }\n context->op = original_op;", "fixed": " return PHP_OUTPUT_HANDLER_FAILURE;\n }\n if (php_output_handler_append(handler, &context->in TSRMLS_CC) && !context->op) {\ncontext->op = original_op;\nreturn PHP_OUTPUT_HANDLER_NO_DATA;\n } else {\n if (!(handler->flags & PHP_OUTPUT_HANDLER_STARTED)) {\n context->op |= PHP_OUTPUT_HANDLER_START;\n handler->buffer.used = 0;\n handler->buffer.size = 0;\n break;\n case PHP_OUTPUT_HANDLER_NO_DATA:\n php_output_context_reset(context);\ncase PHP_OUTPUT_HANDLER_SUCCESS:\nhandler->buffer.used = 0;\n break;\n }\n context->op = original_op;"}
{"scenario": "php-bug-2012-03-12-7aefbf70a8-efc94f3115.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " (code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n )\n goto invalid_code;\nif (!CHARSET_UNICODE_COMPAT(charset)) {\n if (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0)\n goto invalid_code;\n }", "fixed": " (code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n )\n goto invalid_code;\nif (charset != cs_utf_8) {\n if (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0)\n goto invalid_code;\n }"}
{"scenario": "lighttpd-bug-2785-2786.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable"], "lines": 8, "problem": " buffer_copy_string_buffer(con->request.uri, req->uri_raw);\n } else {\n char *sl;\n con->http_status = 400;\n return 0;\n }\nif (NULL == (sl = strchr(BUF_STR(req->uri_raw) + 7, '/'))) {\n con->http_status = 400;\n return 0;\n }\n buffer_copy_string(con->request.uri, sl);\nbuffer_copy_string_len(con->request.http_host, BUF_STR(req->uri_raw) + 7, sl - BUF_STR(req->uri_raw) - 7);\n if (request_check_hostname(con->request.http_host)) {\n if (srv->srvconf.log_request_header_on_error) {\n TRACE(\"Host header is invalid (Status: 400), was %s\", SAFE_BUF_STR(con->request.http_host));", "fixed": " buffer_copy_string_buffer(con->request.uri, req->uri_raw);\n } else {\n char *sl;\nint l;\nl = 8;\nl = 7;\n} else {\n con->http_status = 400;\n return 0;\n }\nif (NULL == (sl = strchr(BUF_STR(req->uri_raw) + l, '/'))) {\n con->http_status = 400;\n return 0;\n }\n buffer_copy_string(con->request.uri, sl);\nbuffer_copy_string_len(con->request.http_host, BUF_STR(req->uri_raw) + l, sl - BUF_STR(req->uri_raw) - l);\n if (request_check_hostname(con->request.http_host)) {\n if (srv->srvconf.log_request_header_on_error) {\n TRACE(\"Host header is invalid (Status: 400), was %s\", SAFE_BUF_STR(con->request.http_host));"}
{"scenario": "libtiff-bug-2008-04-15-2e8b2f1-0d27dc0.tar.gz", "repairActions": [], "lines": 1, "problem": " { TIFFTAG_SUBIFD, -1, -1, TIFF_IFD8, 0, TIFF_SETGET_C16_IFD8, TIFF_SETGET_UNDEFINED, FIELD_SUBIFD, 1, 1, \"SubIFD\", &tiffFieldArray },\n { TIFFTAG_INKSET, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, \"InkSet\", NULL },\n { TIFFTAG_INKNAMES, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_C16_ASCII, TIFF_SETGET_UNDEFINED, FIELD_INKNAMES, 1, 1, \"InkNames\", NULL },\n{ TIFFTAG_NUMBEROFINKS, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UNDEFINED, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"NumberOfInks\", NULL },\n { TIFFTAG_DOTRANGE, 2, 2, TIFF_SHORT, 0, TIFF_SETGET_UINT16_PAIR, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, \"DotRange\", NULL },\n { TIFFTAG_TARGETPRINTER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"TargetPrinter\", NULL },\n { TIFFTAG_EXTRASAMPLES, -1, -1, TIFF_SHORT, 0, TIFF_SETGET_C16_UINT16, TIFF_SETGET_UNDEFINED, FIELD_EXTRASAMPLES, 0, 1, \"ExtraSamples\", NULL },", "fixed": " { TIFFTAG_SUBIFD, -1, -1, TIFF_IFD8, 0, TIFF_SETGET_C16_IFD8, TIFF_SETGET_UNDEFINED, FIELD_SUBIFD, 1, 1, \"SubIFD\", &tiffFieldArray },\n { TIFFTAG_INKSET, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, \"InkSet\", NULL },\n { TIFFTAG_INKNAMES, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_C16_ASCII, TIFF_SETGET_UNDEFINED, FIELD_INKNAMES, 1, 1, \"InkNames\", NULL },\n{ TIFFTAG_NUMBEROFINKS, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"NumberOfInks\", NULL },\n { TIFFTAG_DOTRANGE, 2, 2, TIFF_SHORT, 0, TIFF_SETGET_UINT16_PAIR, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, \"DotRange\", NULL },\n { TIFFTAG_TARGETPRINTER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"TargetPrinter\", NULL },\n { TIFFTAG_EXTRASAMPLES, -1, -1, TIFF_SHORT, 0, TIFF_SETGET_C16_UINT16, TIFF_SETGET_UNDEFINED, FIELD_EXTRASAMPLES, 0, 1, \"ExtraSamples\", NULL },"}
{"scenario": "python-bug-70098-70101.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 6, "problem": " Py_DECREF(self->unconsumed_tail);\n self->unconsumed_tail = PyBytes_FromStringAndSize((char *)self->zst.next_in,\n self->zst.avail_in);\nif(!self->unconsumed_tail) {\n Py_DECREF(RetVal);\n RetVal = NULL;\n goto error;\n}\n }\n if (err == Z_STREAM_END) {\n Py_XDECREF(self->unused_data);", "fixed": " Py_DECREF(self->unconsumed_tail);\n self->unconsumed_tail = PyBytes_FromStringAndSize((char *)self->zst.next_in,\n self->zst.avail_in);\n}\nelse if (PyBytes_GET_SIZE(self->unconsumed_tail) > 0) {\nPy_DECREF(self->unconsumed_tail);\nself->unconsumed_tail = PyBytes_FromStringAndSize(\"\", 0);\n}\nif (self->unconsumed_tail == NULL) {\n Py_DECREF(RetVal);\n RetVal = NULL;\n goto error;\n }\n if (err == Z_STREAM_END) {\n Py_XDECREF(self->unused_data);"}
{"scenario": "libtiff-bug-2009-06-30-b44af47-e0b51f3.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 3, "problem": " defcompression = COMPRESSION_ADOBE_DEFLATE;\n } else if (strneq(opt, \"jbig\", 4)) {\n defcompression = COMPRESSION_JBIG;\n } else\n return (0);\n return (1);\n \" -c packbits     compress output with packbits encoding\",\n \" -c g3[:opts]    compress output with CCITT Group 3 encoding\",\n \" -c g4           compress output with CCITT Group 4 encoding\",\n \" -c none         use no compression algorithm on output\",\n \"\",\n \"Group 3 options:\",", "fixed": " defcompression = COMPRESSION_ADOBE_DEFLATE;\n } else if (strneq(opt, \"jbig\", 4)) {\n defcompression = COMPRESSION_JBIG;\n} else if (strneq(opt, \"sgilog\", 6)) {\ndefcompression = COMPRESSION_SGILOG;\n } else\n return (0);\n return (1);\n \" -c packbits     compress output with packbits encoding\",\n \" -c g3[:opts]    compress output with CCITT Group 3 encoding\",\n \" -c g4           compress output with CCITT Group 4 encoding\",\n\" -c sgilog       compress output with SGILOG encoding\",\n \" -c none         use no compression algorithm on output\",\n \"\",\n \"Group 3 options:\","}
{"scenario": "php-bug-2011-10-16-1f78177e2b-d4ae4e79db.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 1, "problem": " need_comma = 1;\n }\n json_pretty_print_indent(buf, options TSRMLS_CC);\njson_escape_string(buf, key, key_len - 1, options TSRMLS_CC);\n smart_str_appendc(buf, ':');\n json_pretty_print_char(buf, options, ' ' TSRMLS_CC);\n php_json_encode(buf, *data, options TSRMLS_CC);", "fixed": " need_comma = 1;\n }\n json_pretty_print_indent(buf, options TSRMLS_CC);\njson_escape_string(buf, key, key_len - 1, options & ~PHP_JSON_NUMERIC_CHECK TSRMLS_CC);\n smart_str_appendc(buf, ':');\n json_pretty_print_char(buf, options, ' ' TSRMLS_CC);\n php_json_encode(buf, *data, options TSRMLS_CC);"}
{"scenario": "valgrind-bug-11623-11624.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 6, "problem": " \n Thread* thr;\n SO*     so;\n if (SHOW_EVENTS >= 1)\n tl_assert(thr); \n so = map_usertag_to_SO_lookup_or_alloc( usertag );\n tl_assert(so);\nlibhb_so_send( thr->hbthr, so, True );\n }\n static\n void evh__HG_USERSO_RECV_POST ( ThreadId tid, UWord usertag )", "fixed": " \n Thread* thr;\n SO*     so;\n if (SHOW_EVENTS >= 1)\n tl_assert(thr); \n so = map_usertag_to_SO_lookup_or_alloc( usertag );\n tl_assert(so);\nlibhb_so_send( thr->hbthr, so, False );\n }\n static\n void evh__HG_USERSO_RECV_POST ( ThreadId tid, UWord usertag )"}
{"scenario": "php-bug-2011-01-29-147382033a-5bb0a44e06.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 12, "problem": " php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown or bad format (%s)\", format);\n retval = FAILURE;\n } else {\n *rt = p;\n retval = SUCCESS;\n }\n timelib_error_container_dtor(errors);\n return retval;", "fixed": " php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown or bad format (%s)\", format);\n retval = FAILURE;\n } else {\nif(p) {\n *rt = p;\n retval = SUCCESS;\n} else {\nif(b && e) {\ntimelib_update_ts(b, NULL);\ntimelib_update_ts(e, NULL);\n*rt = timelib_diff(b, e);\nretval = SUCCESS;\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse interval (%s)\", format);\nretval = FAILURE;\n}\n}\n }\n timelib_error_container_dtor(errors);\n return retval;"}
{"scenario": "php-bug-2011-11-08-0ac9b9b0ae-cacf363957.tar.gz", "repairActions": [], "lines": 2, "problem": " ifunc->scope = dbh->std.ce;\n ifunc->prototype = NULL;\n if (funcs->flags) {\nifunc->fn_flags = funcs->flags;\n } else {\nifunc->fn_flags = ZEND_ACC_PUBLIC;\n }\n if (funcs->arg_info) {\n zend_internal_function_info *info = (zend_internal_function_info*)funcs->arg_info;", "fixed": " ifunc->scope = dbh->std.ce;\n ifunc->prototype = NULL;\n if (funcs->flags) {\nifunc->fn_flags = funcs->flags | ZEND_ACC_NEVER_CACHE;\n } else {\nifunc->fn_flags = ZEND_ACC_PUBLIC | ZEND_ACC_NEVER_CACHE;\n }\n if (funcs->arg_info) {\n zend_internal_function_info *info = (zend_internal_function_info*)funcs->arg_info;"}
{"scenario": "php-bug-2011-03-25-8138f7de40-3acdca4703.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " efree(arch);\n }\n return;\n} else if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, (void **)&pphar)) {\n goto carry_on;\n } else if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, fname, fname_len, (void **)&pphar)) {\n if (SUCCESS == phar_copy_on_write(pphar TSRMLS_CC)) {", "fixed": " efree(arch);\n }\n return;\n} else if (PHAR_GLOBALS->phar_fname_map.arBuckets && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, (void **)&pphar)) {\n goto carry_on;\n } else if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, fname, fname_len, (void **)&pphar)) {\n if (SUCCESS == phar_copy_on_write(pphar TSRMLS_CC)) {"}
{"scenario": "php-bug-2011-02-01-1f49902999-f2329f1f4b.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method"], "lines": 6, "problem": " RETURN_FALSE;\n }\n }\n ZEND_METHOD(reflection_class, getConstants)\n {\n zval *tmp_copy;\n }\n GET_REFLECTION_OBJECT_PTR(ce);\n array_init(return_value);\nzend_hash_apply_with_argument(&ce->constants_table, (apply_func_arg_t) zval_update_constant, (void*)1 TSRMLS_CC);\n zend_hash_copy(Z_ARRVAL_P(return_value), &ce->constants_table, (copy_ctor_func_t) zval_add_ref, (void *) &tmp_copy, sizeof(zval *));\n }\n ZEND_METHOD(reflection_class, getConstant)\n return;\n }\n GET_REFLECTION_OBJECT_PTR(ce);\nzend_hash_apply_with_argument(&ce->constants_table, (apply_func_arg_t) zval_update_constant, (void*)1 TSRMLS_CC);\n if (zend_hash_find(&ce->constants_table, name, name_len + 1, (void **) &value) == FAILURE) {\n RETURN_FALSE;\n }", "fixed": " RETURN_FALSE;\n }\n }\nstatic int _update_constant_ex_cb_wrapper(void *pDest, void *ce TSRMLS_DC)\n{\nreturn zval_update_constant_ex(pDest, (void*)(zend_uintptr_t)1U, ce);\n}\n ZEND_METHOD(reflection_class, getConstants)\n {\n zval *tmp_copy;\n }\n GET_REFLECTION_OBJECT_PTR(ce);\n array_init(return_value);\nzend_hash_apply_with_argument(&ce->constants_table, _update_constant_ex_cb_wrapper, ce TSRMLS_CC);\n zend_hash_copy(Z_ARRVAL_P(return_value), &ce->constants_table, (copy_ctor_func_t) zval_add_ref, (void *) &tmp_copy, sizeof(zval *));\n }\n ZEND_METHOD(reflection_class, getConstant)\n return;\n }\n GET_REFLECTION_OBJECT_PTR(ce);\nzend_hash_apply_with_argument(&ce->constants_table, _update_constant_ex_cb_wrapper, ce TSRMLS_CC);\n if (zend_hash_find(&ce->constants_table, name, name_len + 1, (void **) &value) == FAILURE) {\n RETURN_FALSE;\n }"}
{"scenario": "lighttpd-bug-2661-2662.tar.gz", "repairActions": ["Adds If Statement"], "lines": 1, "problem": " return p;\n }\n static void accesslog_append_escaped(buffer *dest, buffer *str) {\n buffer_prepare_append(dest, str->used - 1);\n for (unsigned int i = 0; i < str->used - 1; i++) {\n if (str->ptr[i] >= ' ' && str->ptr[i] <= '~') {", "fixed": " return p;\n }\n static void accesslog_append_escaped(buffer *dest, buffer *str) {\nif (str->used == 0) return;\n buffer_prepare_append(dest, str->used - 1);\n for (unsigned int i = 0; i < str->used - 1; i++) {\n if (str->ptr[i] >= ' ' && str->ptr[i] <= '~') {"}
{"scenario": "python-bug-69368-69372.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 12, "problem": " break;\n case BINARY_SUBSCR:\n newconst = PyObject_GetItem(v, w);\n break;\n case BINARY_LSHIFT:\n newconst = PyNumber_Lshift(v, w);", "fixed": " break;\n case BINARY_SUBSCR:\n newconst = PyObject_GetItem(v, w);\nif (newconst != NULL &&\nPyUnicode_Check(v) && PyUnicode_Check(newconst)) {\nPy_UNICODE ch = PyUnicode_AS_UNICODE(newconst)[0];\nif (ch > 0xFFFF) {\nif (ch >= 0xD800 && ch <= 0xDFFF) {\nPy_DECREF(newconst);\nreturn 0;\n}\n}\n break;\n case BINARY_LSHIFT:\n newconst = PyNumber_Lshift(v, w);"}
{"scenario": "php-bug-2011-03-22-0de2e61cab-991ba13174.tar.gz", "repairActions": ["Adds Method Call"], "lines": 5, "problem": " if (intobj->diff->invert) {\n bias = -1;\n }\n dateobj->time->relative.y = intobj->diff->y * bias;\n dateobj->time->relative.m = intobj->diff->m * bias;\n dateobj->time->relative.d = intobj->diff->d * bias;\n dateobj->time->relative.h = intobj->diff->h * bias;\n dateobj->time->relative.i = intobj->diff->i * bias;\n dateobj->time->relative.s = intobj->diff->s * bias;\ndateobj->time->relative.weekday = 0;\ndateobj->time->relative.have_weekday_relative = 0;\n }\n dateobj->time->have_relative = 1;\n dateobj->time->sse_uptodate = 0;\n if (intobj->diff->invert) {\n bias = -1;\n }\n dateobj->time->relative.y = 0 - (intobj->diff->y * bias);\n dateobj->time->relative.m = 0 - (intobj->diff->m * bias);\n dateobj->time->relative.d = 0 - (intobj->diff->d * bias);\n dateobj->time->relative.i = 0 - (intobj->diff->i * bias);\n dateobj->time->relative.s = 0 - (intobj->diff->s * bias);\n dateobj->time->have_relative = 1;\ndateobj->time->relative.weekday = 0;\ndateobj->time->relative.have_weekday_relative = 0;\n dateobj->time->sse_uptodate = 0;\n timelib_update_ts(dateobj->time, NULL);\n timelib_update_from_sse(dateobj->time);", "fixed": " if (intobj->diff->invert) {\n bias = -1;\n }\nmemset(&dateobj->time->relative, 0, sizeof(struct timelib_rel_time));\n dateobj->time->relative.y = intobj->diff->y * bias;\n dateobj->time->relative.m = intobj->diff->m * bias;\n dateobj->time->relative.d = intobj->diff->d * bias;\n dateobj->time->relative.h = intobj->diff->h * bias;\n dateobj->time->relative.i = intobj->diff->i * bias;\n dateobj->time->relative.s = intobj->diff->s * bias;\n }\n dateobj->time->have_relative = 1;\n dateobj->time->sse_uptodate = 0;\n if (intobj->diff->invert) {\n bias = -1;\n }\nmemset(&dateobj->time->relative, 0, sizeof(struct timelib_rel_time));\n dateobj->time->relative.y = 0 - (intobj->diff->y * bias);\n dateobj->time->relative.m = 0 - (intobj->diff->m * bias);\n dateobj->time->relative.d = 0 - (intobj->diff->d * bias);\n dateobj->time->relative.i = 0 - (intobj->diff->i * bias);\n dateobj->time->relative.s = 0 - (intobj->diff->s * bias);\n dateobj->time->have_relative = 1;\n dateobj->time->sse_uptodate = 0;\n timelib_update_ts(dateobj->time, NULL);\n timelib_update_from_sse(dateobj->time);"}
{"scenario": "php-bug-2011-01-06-e7a1d5004e-3571c955b5.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Method"], "lines": 10, "problem": " }\n intern->u.regex.mode = mode;\n intern->u.regex.regex = estrndup(regex, regex_len);\n intern->u.regex.pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC);\n if (intern->u.regex.pce == NULL) {\n zend_restore_error_handling(&error_handling TSRMLS_CC);\n efree(subject);\n }\n }\n SPL_METHOD(RegexIterator, getMode)\n {\n spl_dual_it_object *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n SPL_ME(RegexIterator,   setFlags,         arginfo_regex_it_set_flags,      ZEND_ACC_PUBLIC)\n SPL_ME(RegexIterator,   getPregFlags,     arginfo_recursive_it_void,       ZEND_ACC_PUBLIC)\n SPL_ME(RegexIterator,   setPregFlags,     arginfo_regex_it_set_preg_flags, ZEND_ACC_PUBLIC)\n {NULL, NULL, NULL}\n };\n ZEND_BEGIN_ARG_INFO_EX(arginfo_rec_regex_it___construct, 0, 0, 2)", "fixed": " }\n intern->u.regex.mode = mode;\n intern->u.regex.regex = estrndup(regex, regex_len);\nintern->u.regex.regex_len = regex_len;\n intern->u.regex.pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC);\n if (intern->u.regex.pce == NULL) {\n zend_restore_error_handling(&error_handling TSRMLS_CC);\n efree(subject);\n }\n }\nSPL_METHOD(RegexIterator, getRegex)\n{\nspl_dual_it_object *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\nif (zend_parse_parameters_none() == FAILURE) {\nreturn;\n}\nRETURN_STRINGL(intern->u.regex.regex, intern->u.regex.regex_len, 1);\n}\n SPL_METHOD(RegexIterator, getMode)\n {\n spl_dual_it_object *intern = (spl_dual_it_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n SPL_ME(RegexIterator,   setFlags,         arginfo_regex_it_set_flags,      ZEND_ACC_PUBLIC)\n SPL_ME(RegexIterator,   getPregFlags,     arginfo_recursive_it_void,       ZEND_ACC_PUBLIC)\n SPL_ME(RegexIterator,   setPregFlags,     arginfo_regex_it_set_preg_flags, ZEND_ACC_PUBLIC)\nSPL_ME(RegexIterator,   getRegex,         arginfo_recursive_it_void,       ZEND_ACC_PUBLIC)\n {NULL, NULL, NULL}\n };\n ZEND_BEGIN_ARG_INFO_EX(arginfo_rec_regex_it___construct, 0, 0, 2)"}
{"scenario": "php-bug-2011-12-04-b3ad0b7af7-1d6c98a136.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Variable"], "lines": 5, "problem": " }\n static void do_inherit_parent_constructor(zend_class_entry *ce)\n {\nzend_function *function;\n if (!ce->parent) {\n return;\n }\n return;\n }\n if (zend_hash_find(&ce->parent->function_table, ZEND_CONSTRUCTOR_FUNC_NAME, sizeof(ZEND_CONSTRUCTOR_FUNC_NAME), (void **)&function)==SUCCESS) {\nzend_hash_update(&ce->function_table, ZEND_CONSTRUCTOR_FUNC_NAME, sizeof(ZEND_CONSTRUCTOR_FUNC_NAME), function, sizeof(zend_function), NULL);\nfunction_add_ref(function);\n } else {\n char *lc_class_name;\n char *lc_parent_class_name;\n if (!zend_hash_exists(&ce->function_table, lc_parent_class_name, ce->parent->name_length+1) &&\n zend_hash_find(&ce->parent->function_table, lc_parent_class_name, ce->parent->name_length+1, (void **)&function)==SUCCESS) {\n if (function->common.fn_flags & ZEND_ACC_CTOR) {\nzend_hash_update(&ce->function_table, lc_parent_class_name, ce->parent->name_length+1, function, sizeof(zend_function), NULL);\nfunction_add_ref(function);\n }\n }\n efree(lc_parent_class_name);", "fixed": " }\n static void do_inherit_parent_constructor(zend_class_entry *ce)\n {\nzend_function *function, *new_function;\n if (!ce->parent) {\n return;\n }\n return;\n }\n if (zend_hash_find(&ce->parent->function_table, ZEND_CONSTRUCTOR_FUNC_NAME, sizeof(ZEND_CONSTRUCTOR_FUNC_NAME), (void **)&function)==SUCCESS) {\nzend_hash_update(&ce->function_table, ZEND_CONSTRUCTOR_FUNC_NAME, sizeof(ZEND_CONSTRUCTOR_FUNC_NAME), function, sizeof(zend_function), (void**)&new_function);\nfunction_add_ref(new_function);\n } else {\n char *lc_class_name;\n char *lc_parent_class_name;\n if (!zend_hash_exists(&ce->function_table, lc_parent_class_name, ce->parent->name_length+1) &&\n zend_hash_find(&ce->parent->function_table, lc_parent_class_name, ce->parent->name_length+1, (void **)&function)==SUCCESS) {\n if (function->common.fn_flags & ZEND_ACC_CTOR) {\nzend_hash_update(&ce->function_table, lc_parent_class_name, ce->parent->name_length+1, function, sizeof(zend_function), (void**)new_function);\nfunction_add_ref(new_function);\n }\n }\n efree(lc_parent_class_name);"}
{"scenario": "php-bug-2011-11-08-c3e56a152c-3598185a74.tar.gz", "repairActions": ["Changes Condition", "Adds Variable"], "lines": 3, "problem": " int class_name_len;\n zend_class_entry *instance_ce;\n zend_class_entry **ce;\n zend_bool retval;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs\", &obj, &class_name, &class_name_len) == FAILURE) {\n return;\n }\nif (Z_TYPE_P(obj) == IS_STRING) {\n zend_class_entry **the_ce;\n if (zend_lookup_class(Z_STRVAL_P(obj), Z_STRLEN_P(obj), &the_ce TSRMLS_CC) == FAILURE) {\n RETURN_FALSE;", "fixed": " int class_name_len;\n zend_class_entry *instance_ce;\n zend_class_entry **ce;\nzend_bool allow_string = only_subclass;\n zend_bool retval;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs|b\", &obj, &class_name, &class_name_len, &allow_string) == FAILURE) {\n return;\n }\nif (allow_string && Z_TYPE_P(obj) == IS_STRING) {\n zend_class_entry **the_ce;\n if (zend_lookup_class(Z_STRVAL_P(obj), Z_STRLEN_P(obj), &the_ce TSRMLS_CC) == FAILURE) {\n RETURN_FALSE;"}
{"scenario": "wireshark-bug-37172-37171.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 5, "problem": " FILE *debug_log;\n }\n }\n Sleep(1 * 1000);\n sleep(1);\n if (pcap_opts.pcap_h != NULL) {\n if (interface_opts.buffer_size > 1 &&\npcap_setbuff(pcap_opts.pcap_h, interface_opts.buffer_size * 1024 * 1024) != 0) {\n sync_secondary_msg_str = g_strdup_printf(\n \"The capture buffer size of %dMB seems to be too high for your machine,\\n\"\n \"the default of 1MB will be used.\\n\"\n if ((capture_opts->sampling_method != CAPTURE_SAMP_NONE) &&\n struct pcap_samp *samp;\nif ((samp = pcap_setsampling(pcap_opts.pcap_h)) != NULL) {\n switch (capture_opts->sampling_method) {\n case CAPTURE_SAMP_BY_COUNT:\n samp->method = PCAP_SAMP_1_EVERY_N;", "fixed": " FILE *debug_log;\n }\n }\nif (! global_ld.from_cap_pipe)\n Sleep(1 * 1000);\n sleep(1);\n if (pcap_opts.pcap_h != NULL) {\n if (interface_opts.buffer_size > 1 &&\npcap_setbuff(pcap_opts.pcap_h, option.buffer_size * 1024 * 1024) != 0) {\n sync_secondary_msg_str = g_strdup_printf(\n \"The capture buffer size of %dMB seems to be too high for your machine,\\n\"\n \"the default of 1MB will be used.\\n\"\n if ((capture_opts->sampling_method != CAPTURE_SAMP_NONE) &&\n struct pcap_samp *samp;\nif ((samp = pcap_setsampling(option.pcap_h)) != NULL) {\n switch (capture_opts->sampling_method) {\n case CAPTURE_SAMP_BY_COUNT:\n samp->method = PCAP_SAMP_1_EVERY_N;"}
{"scenario": "php-bug-2011-04-07-77ed819430-efcb9a71cd.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " } else if (Z_ISREF_PP(p)) {\n ALLOC_INIT_ZVAL(tmp);\n ZVAL_COPY_VALUE(tmp, *p);\n Z_SET_REFCOUNT_P(tmp, 0);\n Z_UNSET_ISREF_P(tmp);\n } else {", "fixed": " } else if (Z_ISREF_PP(p)) {\n ALLOC_INIT_ZVAL(tmp);\n ZVAL_COPY_VALUE(tmp, *p);\nzval_copy_ctor(tmp);\n Z_SET_REFCOUNT_P(tmp, 0);\n Z_UNSET_ISREF_P(tmp);\n } else {"}
{"scenario": "php-bug-2011-03-23-63673a533f-2adf58cfcf.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " }\n dpobj = zend_object_store_get_object(getThis() TSRMLS_CC);\n dpobj->current = NULL;\nif (isostr_len) {\n date_period_initialize(&(dpobj->start), &(dpobj->end), &(dpobj->interval), &recurrences, isostr, isostr_len TSRMLS_CC);\n if (dpobj->start == NULL) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"The ISO interval '%s' did not contain a start date.\", isostr);", "fixed": " }\n dpobj = zend_object_store_get_object(getThis() TSRMLS_CC);\n dpobj->current = NULL;\nif (isostr) {\n date_period_initialize(&(dpobj->start), &(dpobj->end), &(dpobj->interval), &recurrences, isostr, isostr_len TSRMLS_CC);\n if (dpobj->start == NULL) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"The ISO interval '%s' did not contain a start date.\", isostr);"}
{"scenario": "python-bug-69934-69935.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Variable"], "lines": 5, "problem": " static void\n trip_signal(int sig_num)\n {\n Handlers[sig_num].tripped = 1;\n if (is_tripped)\n return;\n is_tripped = 1;\n Py_AddPendingCall(checksignals_witharg, NULL);\nif (wakeup_fd != -1)\nwrite(wakeup_fd, \"\\0\", 1);\n }\n static void\n signal_handler(int sig_num)", "fixed": " static void\n trip_signal(int sig_num)\n {\nunsigned char byte;\n Handlers[sig_num].tripped = 1;\n if (is_tripped)\n return;\n is_tripped = 1;\n Py_AddPendingCall(checksignals_witharg, NULL);\nif (wakeup_fd != -1) {\nbyte = (unsigned char)sig_num;\nwrite(wakeup_fd, &byte, 1);\n}\n }\n static void\n signal_handler(int sig_num)"}
{"scenario": "php-bug-2012-03-12-438a30f1e7-7337a901b7.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 8, "problem": " if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &tv_sec, &tv_nsec) == FAILURE) {\n return;\n }\n php_req.tv_sec = (time_t) tv_sec;\n php_req.tv_nsec = tv_nsec;\n if (!nanosleep(&php_req, &php_rem)) {", "fixed": " if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &tv_sec, &tv_nsec) == FAILURE) {\n return;\n }\nif (tv_sec < 0) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The seconds value must be greater than 0\");\nRETURN_FALSE;\n}\nif (tv_nsec < 0) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The nanoseconds value must be greater than 0\");\nRETURN_FALSE;\n}\n php_req.tv_sec = (time_t) tv_sec;\n php_req.tv_nsec = tv_nsec;\n if (!nanosleep(&php_req, &php_rem)) {"}
{"scenario": "gmp-bug-13420-13421.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 7, "problem": " int windowsize, this_windowsize;\n mp_limb_t expbits;\n mp_ptr pp, this_pp;\nmp_ptr b2p;\n long i;\n TMP_DECL;\n ASSERT (en > 1 || (en == 1 && ep[0] > 1));\n pp = TMP_ALLOC_LIMBS (n << (windowsize - 1));\n this_pp = pp;\n redcify (this_pp, bp, bn, mp, n);\nb2p = tp + 2*n;\n mpn_sqr (tp, this_pp, n);\n if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\nmpn_redc_1 (b2p, tp, mp, n, mip[0]);\n else if (BELOW_THRESHOLD (n, REDC_2_TO_REDC_N_THRESHOLD))\nmpn_redc_2 (b2p, tp, mp, n, mip);\n if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_N_THRESHOLD))\nmpn_redc_1 (b2p, tp, mp, n, mip[0]);\n else\nmpn_redc_n (b2p, tp, mp, n, mip);\n for (i = (1 << (windowsize - 1)) - 1; i > 0; i--)\n {\nmpn_mul_n (tp, this_pp, b2p, n);\n this_pp += n;\n if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))", "fixed": " int windowsize, this_windowsize;\n mp_limb_t expbits;\n mp_ptr pp, this_pp;\n long i;\n TMP_DECL;\n ASSERT (en > 1 || (en == 1 && ep[0] > 1));\n pp = TMP_ALLOC_LIMBS (n << (windowsize - 1));\n this_pp = pp;\n redcify (this_pp, bp, bn, mp, n);\n mpn_sqr (tp, this_pp, n);\n if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))\nmpn_redc_1 (rp, tp, mp, n, mip[0]);\n else if (BELOW_THRESHOLD (n, REDC_2_TO_REDC_N_THRESHOLD))\nmpn_redc_2 (rp, tp, mp, n, mip);\n if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_N_THRESHOLD))\nmpn_redc_1 (rp, tp, mp, n, mip[0]);\n else\nmpn_redc_n (rp, tp, mp, n, mip);\n for (i = (1 << (windowsize - 1)) - 1; i > 0; i--)\n {\nmpn_mul_n (tp, this_pp, rp, n);\n this_pp += n;\n if (BELOW_THRESHOLD (n, REDC_1_TO_REDC_2_THRESHOLD))"}
{"scenario": "php-bug-2011-04-30-9c285fddbb-93f65cdeac.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Loop"], "lines": 19, "problem": " if (zend_hash_find(&EG(persistent_list), (char*)persistent_id, strlen(persistent_id)+1, (void*) &le) == SUCCESS) {\n if (Z_TYPE_P(le) == le_pstream) {\n if (stream) {\n *stream = (php_stream*)le->ptr;\n le->refcount++;\n (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);\n }\n return PHP_STREAM_PERSISTENT_SUCCESS;\n }\n return PHP_STREAM_PERSISTENT_FAILURE;\n pefree(stream->orig_path, stream->is_persistent);\n stream->orig_path = NULL;\n }\n OutputDebugString(leakinfo);\n fprintf(stderr, \"%s\", leakinfo);", "fixed": " if (zend_hash_find(&EG(persistent_list), (char*)persistent_id, strlen(persistent_id)+1, (void*) &le) == SUCCESS) {\n if (Z_TYPE_P(le) == le_pstream) {\n if (stream) {\nHashPosition pos;\nzend_rsrc_list_entry *regentry;\nulong index = -1;\nzend_hash_internal_pointer_reset_ex(&EG(regular_list), &pos);\nwhile (zend_hash_get_current_data_ex(&EG(regular_list),\n(void **)&regentry, &pos) == SUCCESS) {\nif (regentry->ptr == le->ptr) {\nzend_hash_get_current_key_ex(&EG(regular_list), NULL, NULL,\n&index, 0, &pos);\nbreak;\n}\nzend_hash_move_forward_ex(&EG(regular_list), &pos);\n}\n *stream = (php_stream*)le->ptr;\nif (index == -1) {\n le->refcount++;\n (*stream)->rsrc_id = ZEND_REGISTER_RESOURCE(NULL, *stream, le_pstream);\n} else {\nregentry->refcount++;\n(*stream)->rsrc_id = index;\n }\n}\n return PHP_STREAM_PERSISTENT_SUCCESS;\n }\n return PHP_STREAM_PERSISTENT_FAILURE;\n pefree(stream->orig_path, stream->is_persistent);\n stream->orig_path = NULL;\n }\n OutputDebugString(leakinfo);\n fprintf(stderr, \"%s\", leakinfo);"}
{"scenario": "python-bug-70019-70023.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 13, "problem": " return _steal_list_append(rval, encoded);\n }\n else if (PyList_Check(obj) || PyTuple_Check(obj)) {\nreturn encoder_listencode_list(s, rval, obj, indent_level);\n }\n else if (PyDict_Check(obj)) {\nreturn encoder_listencode_dict(s, rval, obj, indent_level);\n }\n else {\n PyObject *ident = NULL;\n Py_XDECREF(ident);\n return -1;\n }\n rv = encoder_listencode_obj(s, rval, newobj, indent_level);\n Py_DECREF(newobj);\n if (rv) {\n Py_XDECREF(ident);", "fixed": " return _steal_list_append(rval, encoded);\n }\n else if (PyList_Check(obj) || PyTuple_Check(obj)) {\nif (Py_EnterRecursiveCall(\" while encoding a JSON object\"))\nreturn -1;\nrv = encoder_listencode_list(s, rval, obj, indent_level);\nPy_LeaveRecursiveCall();\nreturn rv;\n }\n else if (PyDict_Check(obj)) {\nif (Py_EnterRecursiveCall(\" while encoding a JSON object\"))\nreturn -1;\nrv = encoder_listencode_dict(s, rval, obj, indent_level);\nPy_LeaveRecursiveCall();\nreturn rv;\n }\n else {\n PyObject *ident = NULL;\n Py_XDECREF(ident);\n return -1;\n }\nif (Py_EnterRecursiveCall(\" while encoding a JSON object\"))\nreturn -1;\n rv = encoder_listencode_obj(s, rval, newobj, indent_level);\nPy_LeaveRecursiveCall();\n Py_DECREF(newobj);\n if (rv) {\n Py_XDECREF(ident);"}
{"scenario": "php-bug-2011-05-24-b60f6774dc-1056c57fa9.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " ctx->result.len = 0;\n smart_str_free(&ctx->buf);\n } else {\n*handled_output = NULL;\n }\n } else {\n *handled_output = NULL;", "fixed": " ctx->result.len = 0;\n smart_str_free(&ctx->buf);\n } else {\n*handled_output = estrndup(output, *handled_output_len = output_len);\n }\n } else {\n *handled_output = NULL;"}
{"scenario": "libtiff-bug-2007-07-13-09e8220-f2d989d.tar.gz", "repairActions": ["Changes Method Call Args", "Changes Condition"], "lines": 3, "problem": " stripsize=size;\n if (!TIFFFillStrip(tif,strip))\n return((tmsize_t)(-1));\nif ((*tif->tif_decodestrip)(tif,buf,size,plane)<=0)\n return((tmsize_t)(-1));\n(*tif->tif_postdecode)(tif,buf,size);\nreturn(size);\n }\n static tmsize_t\n TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,", "fixed": " stripsize=size;\n if (!TIFFFillStrip(tif,strip))\n return((tmsize_t)(-1));\nif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n return((tmsize_t)(-1));\n(*tif->tif_postdecode)(tif,buf,stripsize);\nreturn(stripsize);\n }\n static tmsize_t\n TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,"}
{"scenario": "php-bug-2011-11-23-eca88d3064-db0888dfc1.tar.gz", "repairActions": ["Changes Condition"], "lines": 2, "problem": " if (coliding_prop->flags & ZEND_ACC_SHADOW) {\n zend_hash_quick_find(&coliding_prop->ce->properties_info, prop_name, prop_name_length+1, prop_hash, (void **) &coliding_prop);\n }\nif ((coliding_prop->flags & ZEND_ACC_PPP_MASK) == (property_info->flags & ZEND_ACC_PPP_MASK)) {\n if (property_info->flags & ZEND_ACC_STATIC) {\n not_compatible = (FAILURE == compare_function(&compare_result,\n ce->default_static_members_table[coliding_prop->offset],", "fixed": " if (coliding_prop->flags & ZEND_ACC_SHADOW) {\n zend_hash_quick_find(&coliding_prop->ce->properties_info, prop_name, prop_name_length+1, prop_hash, (void **) &coliding_prop);\n }\nif (   (coliding_prop->flags & (ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC))\n== (property_info->flags & (ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC))) {\n if (property_info->flags & ZEND_ACC_STATIC) {\n not_compatible = (FAILURE == compare_function(&compare_result,\n ce->default_static_members_table[coliding_prop->offset],"}
{"scenario": "php-bug-2011-04-19-11941b3fd2-821d7169d9.tar.gz", "repairActions": [], "lines": 1, "problem": " object_init_ex(res, zend_ce_closure);\n closure = (zend_closure *)zend_object_store_get_object(res TSRMLS_CC);\n closure->func = *func;\n if (closure->func.type == ZEND_USER_FUNCTION) {\n if (closure->func.op_array.static_variables) {\n HashTable *static_variables = closure->func.op_array.static_variables;", "fixed": " object_init_ex(res, zend_ce_closure);\n closure = (zend_closure *)zend_object_store_get_object(res TSRMLS_CC);\n closure->func = *func;\nclosure->func.common.prototype = NULL;\n if (closure->func.type == ZEND_USER_FUNCTION) {\n if (closure->func.op_array.static_variables) {\n HashTable *static_variables = closure->func.op_array.static_variables;"}
{"scenario": "php-bug-2012-02-25-38b549ea2f-1923ecfe25.tar.gz", "repairActions": ["Adds Method Call"], "lines": 3, "problem": " {\n if (Z_OBJ_HANDLER_PP(arg, cast_object)) {\n zval *obj;\nALLOC_ZVAL(obj);\nMAKE_COPY_ZVAL(arg, obj);\n if (Z_OBJ_HANDLER_P(*arg, cast_object)(*arg, obj, type TSRMLS_CC) == SUCCESS) {\n zval_ptr_dtor(arg);\n *arg = obj;\n *p = Z_STRVAL_PP(arg);\n return SUCCESS;\n }\nzval_ptr_dtor(&obj);\n }\n if (Z_OBJ_HT_PP(arg) == &std_object_handlers || !Z_OBJ_HANDLER_PP(arg, cast_object)) {\n SEPARATE_ZVAL_IF_NOT_REF(arg);", "fixed": " {\n if (Z_OBJ_HANDLER_PP(arg, cast_object)) {\n zval *obj;\nMAKE_STD_ZVAL(obj);\n if (Z_OBJ_HANDLER_P(*arg, cast_object)(*arg, obj, type TSRMLS_CC) == SUCCESS) {\n zval_ptr_dtor(arg);\n *arg = obj;\n *p = Z_STRVAL_PP(arg);\n return SUCCESS;\n }\nefree(obj);\n }\n if (Z_OBJ_HT_PP(arg) == &std_object_handlers || !Z_OBJ_HANDLER_PP(arg, cast_object)) {\n SEPARATE_ZVAL_IF_NOT_REF(arg);"}
{"scenario": "php-bug-2011-04-27-53204a26d2-118695a4ea.tar.gz", "repairActions": ["Changes Method Signature", "Changes Method Call Args", "Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable"], "lines": 11, "problem": " ZEND_BEGIN_ARG_INFO_EX(arginfo_filter_input_array, 0, 0, 1)\n ZEND_ARG_INFO(0, type)\n ZEND_ARG_INFO(0, definition)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO_EX(arginfo_filter_var_array, 0, 0, 1)\n ZEND_ARG_INFO(0, data)\n ZEND_ARG_INFO(0, definition)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO(arginfo_filter_list, 0)\n ZEND_END_ARG_INFO()\n add_next_index_zval(*filtered, tmp);\n }\n }\nstatic void php_filter_array_handler(zval *input, zval **op, zval *return_value TSRMLS_DC)\n {\n char *arg_key;\n uint arg_key_len;\n RETURN_FALSE;\n }\n if (zend_hash_find(Z_ARRVAL_P(input), arg_key, arg_key_len, (void **)&tmp) != SUCCESS) {\n add_assoc_null_ex(return_value, arg_key, arg_key_len);\n } else {\n zval *nval;\n ALLOC_ZVAL(nval);\n {\n long    fetch_from;\n zval   *array_input = NULL, **op = NULL;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|Z\",  &fetch_from, &op) == FAILURE) {\n return;\n }\n if (op\n RETURN_NULL();\n }\n }\nphp_filter_array_handler(array_input, op, return_value TSRMLS_CC);\n }\n PHP_FUNCTION(filter_var_array)\n {\n zval *array_input = NULL, **op = NULL;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|Z\",  &array_input, &op) == FAILURE) {\n return;\n }\n if (op\n ) {\n RETURN_FALSE;\n }\nphp_filter_array_handler(array_input, op, return_value TSRMLS_CC);\n }\n PHP_FUNCTION(filter_list)\n {", "fixed": " ZEND_BEGIN_ARG_INFO_EX(arginfo_filter_input_array, 0, 0, 1)\n ZEND_ARG_INFO(0, type)\n ZEND_ARG_INFO(0, definition)\nZEND_ARG_INFO(0, add_empty)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO_EX(arginfo_filter_var_array, 0, 0, 1)\n ZEND_ARG_INFO(0, data)\n ZEND_ARG_INFO(0, definition)\nZEND_ARG_INFO(0, add_empty)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO(arginfo_filter_list, 0)\n ZEND_END_ARG_INFO()\n add_next_index_zval(*filtered, tmp);\n }\n }\nstatic void php_filter_array_handler(zval *input, zval **op, zval *return_value, zend_bool add_empty TSRMLS_DC)\n {\n char *arg_key;\n uint arg_key_len;\n RETURN_FALSE;\n }\n if (zend_hash_find(Z_ARRVAL_P(input), arg_key, arg_key_len, (void **)&tmp) != SUCCESS) {\nif (add_empty) {\n add_assoc_null_ex(return_value, arg_key, arg_key_len);\n}\n } else {\n zval *nval;\n ALLOC_ZVAL(nval);\n {\n long    fetch_from;\n zval   *array_input = NULL, **op = NULL;\nzend_bool add_empty = 1;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|Zb\",  &fetch_from, &op, &add_empty) == FAILURE) {\n return;\n }\n if (op\n RETURN_NULL();\n }\n }\nphp_filter_array_handler(array_input, op, return_value, add_empty TSRMLS_CC);\n }\n PHP_FUNCTION(filter_var_array)\n {\n zval *array_input = NULL, **op = NULL;\nzend_bool add_empty = 1;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|Zb\",  &array_input, &op, &add_empty) == FAILURE) {\n return;\n }\n if (op\n ) {\n RETURN_FALSE;\n }\nphp_filter_array_handler(array_input, op, return_value, add_empty TSRMLS_CC);\n }\n PHP_FUNCTION(filter_list)\n {"}
{"scenario": "python-bug-69740-69743.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Changes Condition"], "lines": 6, "problem": " return NULL;\n }\n self = PyTuple_GET_ITEM(args, 0);\nif (!PyObject_IsInstance(self, (PyObject *)PyDescr_TYPE(descr))) {\n PyErr_Format(PyExc_TypeError,\n \"descriptor '%V' \"\n \"requires a '%.100s' object \"\n return NULL;\n }\n self = PyTuple_GET_ITEM(args, 0);\nif (!PyObject_IsInstance(self, (PyObject *)PyDescr_TYPE(descr))) {\n PyErr_Format(PyExc_TypeError,\n \"descriptor '%V' \"\n \"requires a '%.100s' object \"\n PyWrapperDescrObject *descr;\n assert(PyObject_TypeCheck(d, &PyWrapperDescr_Type));\n descr = (PyWrapperDescrObject *)d;\nassert(PyObject_IsInstance(self, (PyObject *)PyDescr_TYPE(descr)));\n wp = PyObject_GC_New(wrapperobject, &wrappertype);\n if (wp != NULL) {\n Py_INCREF(descr);", "fixed": " return NULL;\n }\n self = PyTuple_GET_ITEM(args, 0);\nif (!_PyObject_RealIsSubclass((PyObject *)Py_TYPE(self),\n(PyObject *)PyDescr_TYPE(descr))) {\n PyErr_Format(PyExc_TypeError,\n \"descriptor '%V' \"\n \"requires a '%.100s' object \"\n return NULL;\n }\n self = PyTuple_GET_ITEM(args, 0);\nif (!_PyObject_RealIsSubclass((PyObject *)Py_TYPE(self),\n(PyObject *)PyDescr_TYPE(descr))) {\n PyErr_Format(PyExc_TypeError,\n \"descriptor '%V' \"\n \"requires a '%.100s' object \"\n PyWrapperDescrObject *descr;\n assert(PyObject_TypeCheck(d, &PyWrapperDescr_Type));\n descr = (PyWrapperDescrObject *)d;\nassert(_PyObject_RealIsSubclass((PyObject *)Py_TYPE(self),\n(PyObject *)PyDescr_TYPE(descr)));\n wp = PyObject_GC_New(wrapperobject, &wrappertype);\n if (wp != NULL) {\n Py_INCREF(descr);"}
{"scenario": "python-bug-69945-69946.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Method"], "lines": 41, "problem": " }\n }\n static double\n m_log10(double x)\n {\n if (Py_IS_FINITE(x)) {\n Return the logarithm of x to the given base.\\n\\\n If the base not specified, returns the natural logarithm (base e) of x.\");\n static PyObject *\n math_log10(PyObject *self, PyObject *arg)\n {\n return loghelper(arg, m_log10, \"log10\");\n {\"log\",             math_log,       METH_VARARGS,   math_log_doc},\n {\"log1p\",           math_log1p,     METH_O,         math_log1p_doc},\n {\"log10\",           math_log10,     METH_O,         math_log10_doc},\n {\"modf\",            math_modf,      METH_O,         math_modf_doc},\n {\"pow\",             math_pow,       METH_VARARGS,   math_pow_doc},\n {\"radians\",         math_radians,   METH_O,         math_radians_doc},", "fixed": " }\n }\n static double\nm_log2(double x)\n{\nif (!Py_IS_FINITE(x)) {\nif (Py_IS_NAN(x))\nreturn x;\nelse if (x > 0.0)\nreturn x;\nelse {\nerrno = EDOM;\nreturn Py_NAN;\n}\n}\nif (x > 0.0) {\ndouble m;\nint e;\nm = frexp(x, &e);\nif (x >= 1.0) {\nreturn log(2.0 * m) / log(2.0) + (e - 1);\n}\nelse {\nreturn log(m) / log(2.0) + e;\n}\n}\nelse if (x == 0.0) {\nerrno = EDOM;\nreturn -Py_HUGE_VAL;\n}\nelse {\nerrno = EDOM;\nreturn Py_NAN;\n}\n}\nstatic double\n m_log10(double x)\n {\n if (Py_IS_FINITE(x)) {\n Return the logarithm of x to the given base.\\n\\\n If the base not specified, returns the natural logarithm (base e) of x.\");\n static PyObject *\nmath_log2(PyObject *self, PyObject *arg)\n{\nreturn loghelper(arg, m_log2, \"log2\");\n}\nPyDoc_STRVAR(math_log2_doc,\n\"log2(x)\\n\\nReturn the base 2 logarithm of x.\");\nstatic PyObject *\n math_log10(PyObject *self, PyObject *arg)\n {\n return loghelper(arg, m_log10, \"log10\");\n {\"log\",             math_log,       METH_VARARGS,   math_log_doc},\n {\"log1p\",           math_log1p,     METH_O,         math_log1p_doc},\n {\"log10\",           math_log10,     METH_O,         math_log10_doc},\n{\"log2\",            math_log2,      METH_O,         math_log2_doc},\n {\"modf\",            math_modf,      METH_O,         math_modf_doc},\n {\"pow\",             math_pow,       METH_VARARGS,   math_pow_doc},\n {\"radians\",         math_radians,   METH_O,         math_radians_doc},"}
{"scenario": "php-bug-2012-03-19-53e3467ff2-9a460497da.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Loop", "Adds Method"], "lines": 61, "problem": " }\n return bufstart;\n }\n PHPAPI char *php_stream_get_record(php_stream *stream, size_t maxlen, size_t *returned_len, char *delim, size_t delim_len TSRMLS_DC)\n {\nchar *e, *buf;\nsize_t toread, len;\nint skip = 0;\nlen = stream->writepos - stream->readpos;\nwhile (len < maxlen) {\nsize_t just_read;\ntoread = MIN(maxlen - len, stream->chunk_size);\nphp_stream_fill_read_buffer(stream, len + toread TSRMLS_CC);\njust_read = (stream->writepos - stream->readpos) - len;\nlen += just_read;\n if (just_read == 0) {\n break;\n }\n }\nif (delim_len == 0 || !delim) {\ntoread = maxlen;\n} else {\nsize_t seek_len;\nseek_len = stream->writepos - stream->readpos;\nif (seek_len > maxlen) {\nseek_len = maxlen;\n }\nif (delim_len == 1) {\ne = memchr(stream->readbuf + stream->readpos, *delim, seek_len);\n} else {\ne = php_memnstr(stream->readbuf + stream->readpos, delim, delim_len, (stream->readbuf + stream->readpos + seek_len));\n }\nif (!e) {\nif (seek_len < maxlen && !stream->eof) {\n return NULL;\n}\ntoread = maxlen;\n } else {\ntoread = e - (char *) stream->readbuf - stream->readpos;\nskip = 1;\n }\n }\nif (toread > maxlen && maxlen > 0) {\ntoread = maxlen;\n}\nbuf = emalloc(toread + 1);\n*returned_len = php_stream_read(stream, buf, toread);\nif (skip) {\n stream->readpos += delim_len;\n stream->position += delim_len;\n }\nbuf[*returned_len] = '\\0';\nreturn buf;\n }\n static size_t _php_stream_write_buffer(php_stream *stream, const char *buf, size_t count TSRMLS_DC)\n {", "fixed": " }\n return bufstart;\n }\n((size_t)(((stream)->writepos) - (stream)->readpos))\nstatic char *_php_stream_search_delim(php_stream *stream,\nsize_t maxlen,\nsize_t skiplen,\nchar *delim,\nsize_t delim_len TSRMLS_DC)\n{\nsize_t\tseek_len;\nseek_len = MIN(STREAM_BUFFERED_AMOUNT(stream), maxlen);\nif (seek_len <= skiplen) {\nreturn NULL;\n}\nif (delim_len == 1) {\nreturn memchr(&stream->readbuf[stream->readpos + skiplen],\ndelim[0], seek_len - skiplen);\n} else {\nreturn php_memnstr((char*)&stream->readbuf[stream->readpos + skiplen],\ndelim, delim_len,\n(char*)&stream->readbuf[stream->readpos + seek_len]);\n}\n}\n PHPAPI char *php_stream_get_record(php_stream *stream, size_t maxlen, size_t *returned_len, char *delim, size_t delim_len TSRMLS_DC)\n {\nchar\t*ret_buf,\n*found_delim = NULL;\nsize_t\tbuffered_len,\ntent_ret_len;\nint\t\thas_delim\t = delim_len > 0 && delim[0] != '\\0';\nif (maxlen == 0) {\nreturn NULL;\n}\nif (has_delim) {\nfound_delim = _php_stream_search_delim(\nstream, maxlen, 0, delim, delim_len TSRMLS_CC);\n}\nbuffered_len = STREAM_BUFFERED_AMOUNT(stream);\nwhile (!found_delim && buffered_len < maxlen) {\nsize_t\tjust_read,\nto_read_now;\nto_read_now = MIN(maxlen - buffered_len, stream->chunk_size);\nphp_stream_fill_read_buffer(stream, buffered_len + to_read_now TSRMLS_CC);\njust_read = STREAM_BUFFERED_AMOUNT(stream) - buffered_len;\n if (just_read == 0) {\n break;\n }\nif (has_delim) {\nfound_delim = _php_stream_search_delim(\nstream, maxlen, buffered_len, delim, delim_len TSRMLS_CC);\nif (found_delim) {\nbreak;\n }\n }\nbuffered_len += just_read;\n }\nif (has_delim && found_delim) {\ntent_ret_len = found_delim - (char*)&stream->readbuf[stream->readpos];\n} else if (!has_delim && STREAM_BUFFERED_AMOUNT(stream) >= maxlen) {\ntent_ret_len = maxlen;\n} else {\nif (STREAM_BUFFERED_AMOUNT(stream) < maxlen && !stream->eof) {\n return NULL;\n} else if (STREAM_BUFFERED_AMOUNT(stream) == 0 && stream->eof) {\nreturn NULL;\n } else {\ntent_ret_len = MIN(STREAM_BUFFERED_AMOUNT(stream), maxlen);\n }\n }\nret_buf = emalloc(tent_ret_len + 1);\n*returned_len = php_stream_read(stream, ret_buf, tent_ret_len);\nif (found_delim) {\n stream->readpos += delim_len;\n stream->position += delim_len;\n }\nret_buf[*returned_len] = '\\0';\nreturn ret_buf;\n }\n static size_t _php_stream_write_buffer(php_stream *stream, const char *buf, size_t count TSRMLS_DC)\n {"}
{"scenario": "php-bug-2011-11-22-ecc6c335c5-b548293b99.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 2, "problem": " string_write(str, \"...\", sizeof(\"...\")-1);\n }\n string_write(str, \"'\", sizeof(\"'\")-1);\n } else {\n zend_make_printable_zval(zv, &zv_copy, &use_copy);\n string_write(str, Z_STRVAL(zv_copy), Z_STRLEN(zv_copy));", "fixed": " string_write(str, \"...\", sizeof(\"...\")-1);\n }\n string_write(str, \"'\", sizeof(\"'\")-1);\n} else if (Z_TYPE_P(zv) == IS_ARRAY) {\nstring_write(str, \"Array\", sizeof(\"Array\")-1);\n } else {\n zend_make_printable_zval(zv, &zv_copy, &use_copy);\n string_write(str, Z_STRVAL(zv_copy), Z_STRLEN(zv_copy));"}
{"scenario": "php-bug-2011-10-15-0a1cc5f01c-05c5c8958e.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " }\n if (function_ptr) {\n if (ARG_MAY_BE_SENT_BY_REF(function_ptr, (zend_uint) offset)) {\nif (param->op_type & (IS_VAR|IS_CV)) {\n send_by_reference = 1;\n if (op == ZEND_SEND_VAR && zend_is_function_or_method_call(param)) {\n op = ZEND_SEND_VAR_NO_REF;", "fixed": " }\n if (function_ptr) {\n if (ARG_MAY_BE_SENT_BY_REF(function_ptr, (zend_uint) offset)) {\nif (param->op_type & (IS_VAR|IS_CV) && original_op != ZEND_SEND_VAL) {\n send_by_reference = 1;\n if (op == ZEND_SEND_VAR && zend_is_function_or_method_call(param)) {\n op = ZEND_SEND_VAR_NO_REF;"}
{"scenario": "php-bug-2011-01-18-95388b7cda-b9b1fb1827.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Adds If Statement"], "lines": 8, "problem": " php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not fetch buffer\");\n RETURN_FALSE;\n }\nhtmlNodeDumpFormatOutput(buf, docp, node, 0, format);\n mem = (xmlChar*) xmlBufferContent(buf);\n if (!mem) {\n RETVAL_FALSE;\n } else {\nRETVAL_STRING(mem, 1);\n }\n xmlBufferFree(buf);\n } else {\n if (!size) {\n RETVAL_FALSE;\n } else {\nRETVAL_STRINGL(mem, size, 1);\n }\n if (mem)\n xmlFree(mem);", "fixed": " php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not fetch buffer\");\n RETURN_FALSE;\n }\nsize = htmlNodeDump(buf, docp, node);\nif (size >= 0) {\n mem = (xmlChar*) xmlBufferContent(buf);\n if (!mem) {\n RETVAL_FALSE;\n } else {\nRETVAL_STRINGL((const char*) mem, size, 1);\n }\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error dumping HTML node\");\nRETVAL_FALSE;\n}\n xmlBufferFree(buf);\n } else {\n if (!size) {\n RETVAL_FALSE;\n } else {\nRETVAL_STRINGL((const char*) mem, size, 1);\n }\n if (mem)\n xmlFree(mem);"}
{"scenario": "php-bug-2011-11-01-d2881adcbc-4591498df7.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 11, "problem": " add = 1;\n } else if (existing_fn->common.scope != ce) {\n add = 1;\nif ((fn->common.fn_flags & ZEND_ACC_ABSTRACT) == 0) {\nzend_hash_quick_del(&ce->function_table, hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n }\n}\n if (add) {\n zend_function* parent_function;\n if (ce->parent && zend_hash_quick_find(&ce->parent->function_table, hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void**) &parent_function) != FAILURE) {\n }\n if (prototype) {\n do_inheritance_check_on_method(fn, prototype TSRMLS_CC);\n }\n if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\n ce->ce_flags |= ZEND_ACC_IMPLICIT_ABSTRACT_CLASS;", "fixed": " add = 1;\n } else if (existing_fn->common.scope != ce) {\n add = 1;\n }\n if (add) {\n zend_function* parent_function;\n if (ce->parent && zend_hash_quick_find(&ce->parent->function_table, hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void**) &parent_function) != FAILURE) {\n }\n if (prototype) {\n do_inheritance_check_on_method(fn, prototype TSRMLS_CC);\n}\nif (existing_fn && existing_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\ndo_inheritance_check_on_method(fn, existing_fn TSRMLS_CC);\n}\nif (existing_fn\n&& existing_fn->common.scope != ce\n&& (fn->common.fn_flags & ZEND_ACC_ABSTRACT) == 0) {\nzend_hash_quick_del(&ce->function_table, hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n }\n if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\n ce->ce_flags |= ZEND_ACC_IMPLICIT_ABSTRACT_CLASS;"}
{"scenario": "php-bug-2011-02-01-fefe9fc5c7-0927309852.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 1, "problem": " if (ext_len == -2) {\n spprintf(error, 0, \"Cannot create a phar archive from a URL like \\\"%s\\\". Phar objects can only be created from local files\", fname);\n } else {\nspprintf(error, 0, \"Cannot create phar '%s', file extension (or combination) not recognised\", fname);\n }\n }\n return FAILURE;", "fixed": " if (ext_len == -2) {\n spprintf(error, 0, \"Cannot create a phar archive from a URL like \\\"%s\\\". Phar objects can only be created from local files\", fname);\n } else {\nspprintf(error, 0, \"Cannot create phar '%s', file extension (or combination) not recognised or the directory does not exist\", fname);\n }\n }\n return FAILURE;"}
{"scenario": "php-bug-2011-02-01-01745fa657-1f49902999.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " zval **elem;\nif (SUCCESS == zend_hash_find(Z_ARRVAL_P(array),\n convert_to_long(*elem);                                                                   \\\nssb->sb.st_\n }", "fixed": " zval **elem;\nif (SUCCESS == zend_hash_find(Z_ARRVAL_P(array),\nSEPARATE_ZVAL(elem);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\\n convert_to_long(*elem);                                                                   \\\nssb->sb.st_\n }"}
{"scenario": "gzip-bug-2009-08-16-3fe0caeada-39a362ae9d.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 4, "problem": " } while (--i);\n if (c[0] == n)\n {\nq = (struct huft *) malloc (2 * sizeof *q);\n if (!q)\n return 3;\nhufts += 2;\n q[0].v.t = (struct huft *) NULL;\n q[1].e = 99;\n q[1].b = 1;\n *t = q + 1;\n *m = 1;\n return 0;", "fixed": " } while (--i);\n if (c[0] == n)\n {\nq = (struct huft *) malloc (3 * sizeof *q);\n if (!q)\n return 3;\nhufts += 3;\n q[0].v.t = (struct huft *) NULL;\n q[1].e = 99;\n q[1].b = 1;\nq[2].e = 99;\nq[2].b = 1;\n *t = q + 1;\n *m = 1;\n return 0;"}
{"scenario": "php-bug-2011-02-04-793cfe1376-109b8e99e0.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 12, "problem": " memcpy(port_buf, p, (pp-p));\n port_buf[pp-p] = '\\0';\n ret->port = atoi(port_buf);\n } else {\n goto just_path;\n }\n memcpy(port_buf, p, (e-p));\n port_buf[e-p] = '\\0';\n ret->port = atoi(port_buf);\n }\n p--;\n }", "fixed": " memcpy(port_buf, p, (pp-p));\n port_buf[pp-p] = '\\0';\n ret->port = atoi(port_buf);\nif (!ret->port && (pp - p) > 0) {\nSTR_FREE(ret->scheme);\nefree(ret);\nreturn NULL;\n}\n } else {\n goto just_path;\n }\n memcpy(port_buf, p, (e-p));\n port_buf[e-p] = '\\0';\n ret->port = atoi(port_buf);\nif (!ret->port && (e - p)) {\nSTR_FREE(ret->scheme);\nSTR_FREE(ret->user);\nSTR_FREE(ret->pass);\nefree(ret);\nreturn NULL;\n}\n }\n p--;\n }"}
{"scenario": "php-bug-2012-01-17-e76c1cc03c-ebddf8a975.tar.gz", "repairActions": [], "lines": 38, "problem": " GET_REFLECTION_OBJECT_PTR(mptr);\n RETURN_LONG(mptr->common.fn_flags);\n }\nZEND_METHOD(reflection_method, setFinal)\n{\nreflection_object *intern;\nzend_function *mptr;\nzend_bool isFinal = 1;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &isFinal) == FAILURE) {\nreturn;\n}\nGET_REFLECTION_OBJECT_PTR(mptr);\nif (isFinal) {\nmptr->common.fn_flags |= ZEND_ACC_FINAL;\n} else {\nmptr->common.fn_flags &= ~ZEND_ACC_FINAL;\n}\n}\n ZEND_METHOD(reflection_method, getDeclaringClass)\n {\n reflection_object *intern;\n {\n _class_check_flag(INTERNAL_FUNCTION_PARAM_PASSTHRU, ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);\n }\nZEND_METHOD(reflection_class, setFinal)\n{\nreflection_object *intern;\nzend_class_entry *ce;\nzend_bool isFinal = 1;\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &isFinal) == FAILURE) {\nreturn;\n}\nGET_REFLECTION_OBJECT_PTR(ce);\nif (isFinal) {\nce->ce_flags |= ZEND_ACC_FINAL_CLASS;\n} else {\nce->ce_flags &= ~ZEND_ACC_FINAL_CLASS;\n}\n}\n ZEND_METHOD(reflection_class, getModifiers)\n {\n reflection_object *intern;\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_method_setAccessible, 0)\n ZEND_ARG_INFO(0, value)\n ZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO(arginfo_reflection_method_setFinal, 0)\nZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_method_getClosure, 0)\n ZEND_ARG_INFO(0, object)\n ZEND_END_ARG_INFO()\n ZEND_ME(reflection_method, isProtected, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isAbstract, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isFinal, arginfo_reflection__void, 0)\nZEND_ME(reflection_method, setFinal, arginfo_reflection_method_setFinal, 0)\n ZEND_ME(reflection_method, isStatic, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isConstructor, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isDestructor, arginfo_reflection__void, 0)\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_class_isInstance, 0)\n ZEND_ARG_INFO(0, object)\n ZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO(arginfo_reflection_class_setFinal, 0)\nZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_class_newInstance, 0)\n ZEND_ARG_INFO(0, args)\n ZEND_END_ARG_INFO()\n ZEND_ME(reflection_class, isTrait, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, isAbstract, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, isFinal, arginfo_reflection__void, 0)\nZEND_ME(reflection_class, setFinal, arginfo_reflection_class_setFinal, 0)\n ZEND_ME(reflection_class, getModifiers, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, isInstance, arginfo_reflection_class_isInstance, 0)\n ZEND_ME(reflection_class, newInstance, arginfo_reflection_class_newInstance, 0)", "fixed": " GET_REFLECTION_OBJECT_PTR(mptr);\n RETURN_LONG(mptr->common.fn_flags);\n }\n ZEND_METHOD(reflection_method, getDeclaringClass)\n {\n reflection_object *intern;\n {\n _class_check_flag(INTERNAL_FUNCTION_PARAM_PASSTHRU, ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);\n }\n ZEND_METHOD(reflection_class, getModifiers)\n {\n reflection_object *intern;\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_method_setAccessible, 0)\n ZEND_ARG_INFO(0, value)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_method_getClosure, 0)\n ZEND_ARG_INFO(0, object)\n ZEND_END_ARG_INFO()\n ZEND_ME(reflection_method, isProtected, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isAbstract, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isFinal, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isStatic, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isConstructor, arginfo_reflection__void, 0)\n ZEND_ME(reflection_method, isDestructor, arginfo_reflection__void, 0)\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_class_isInstance, 0)\n ZEND_ARG_INFO(0, object)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO(arginfo_reflection_class_newInstance, 0)\n ZEND_ARG_INFO(0, args)\n ZEND_END_ARG_INFO()\n ZEND_ME(reflection_class, isTrait, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, isAbstract, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, isFinal, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, getModifiers, arginfo_reflection__void, 0)\n ZEND_ME(reflection_class, isInstance, arginfo_reflection_class_isInstance, 0)\n ZEND_ME(reflection_class, newInstance, arginfo_reflection_class_newInstance, 0)"}
{"scenario": "php-bug-2011-12-17-db63456a8d-3dc9f0abe6.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable"], "lines": 4, "problem": " ulong prop_hash;\n const char* class_name_unused;\n zend_bool prop_found;\n zend_bool not_compatible;\n zval* prop_value;\n for (i = 0; i < ce->num_traits; i++) {\n if (prop_found) {\n if (coliding_prop->flags & ZEND_ACC_SHADOW) {\n zend_hash_quick_find(&coliding_prop->ce->properties_info, prop_name, prop_name_length+1, prop_hash, (void **) &coliding_prop);\n }\n if (   (coliding_prop->flags & (ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC))\n == (property_info->flags & (ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC))) {\n if (property_info->flags & ZEND_ACC_STATIC) {\n property_info->ce->name,\n prop_name,\n ce->name);\n }\n }\n if (property_info->flags & ZEND_ACC_STATIC) {", "fixed": " ulong prop_hash;\n const char* class_name_unused;\n zend_bool prop_found;\nzend_bool parent_prop_is_private = 0;\n zend_bool not_compatible;\n zval* prop_value;\n for (i = 0; i < ce->num_traits; i++) {\n if (prop_found) {\n if (coliding_prop->flags & ZEND_ACC_SHADOW) {\n zend_hash_quick_find(&coliding_prop->ce->properties_info, prop_name, prop_name_length+1, prop_hash, (void **) &coliding_prop);\nparent_prop_is_private = (coliding_prop->flags & ZEND_ACC_PRIVATE) == ZEND_ACC_PRIVATE;\n }\nif (!parent_prop_is_private) {\n if (   (coliding_prop->flags & (ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC))\n == (property_info->flags & (ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC))) {\n if (property_info->flags & ZEND_ACC_STATIC) {\n property_info->ce->name,\n prop_name,\n ce->name);\n}\n }\n }\n if (property_info->flags & ZEND_ACC_STATIC) {"}
{"scenario": "libtiff-bug-2007-11-02-371336d-865f7b2.tar.gz", "repairActions": ["Changes Condition"], "lines": 2, "problem": " return (1);\n if (imagedone)\n {\ntmsize_t orig_rawcc = tif->tif_rawcc;\n if (tif->tif_flags & TIFF_POSTENCODE)\n {\n tif->tif_flags &= ~TIFF_POSTENCODE;\n }\n }\n (*tif->tif_close)(tif);\nif (tif->tif_rawcc > 0 && tif->tif_rawcc != orig_rawcc\n && (tif->tif_flags & TIFF_BEENWRITING) != 0\n && !TIFFFlushData1(tif))\n {", "fixed": " return (1);\n if (imagedone)\n {\n if (tif->tif_flags & TIFF_POSTENCODE)\n {\n tif->tif_flags &= ~TIFF_POSTENCODE;\n }\n }\n (*tif->tif_close)(tif);\nif (tif->tif_rawcc > 0\n && (tif->tif_flags & TIFF_BEENWRITING) != 0\n && !TIFFFlushData1(tif))\n {"}
{"scenario": "php-bug-2011-02-05-c50b3d7add-426f31e790.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable"], "lines": 15, "problem": " while (pp-p < 6 && isdigit(*pp)) {\n pp++;\n }\nif (pp-p < 6 && (*pp == '/' || *pp == '\\0')) {\nmemcpy(port_buf, p, (pp-p));\nport_buf[pp-p] = '\\0';\nret->port = atoi(port_buf);\nif (!ret->port && (pp - p) > 0) {\n STR_FREE(ret->scheme);\n efree(ret);\n return NULL;\n efree(ret);\n return NULL;\n } else if (e - p > 0) {\nmemcpy(port_buf, p, (e-p));\nport_buf[e-p] = '\\0';\nret->port = atoi(port_buf);\nif (!ret->port && (e - p)) {\n STR_FREE(ret->scheme);\n STR_FREE(ret->user);\n STR_FREE(ret->pass);", "fixed": " while (pp-p < 6 && isdigit(*pp)) {\n pp++;\n }\nif (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\\0')) {\nlong port;\nmemcpy(port_buf, p, (pp - p));\nport_buf[pp - p] = '\\0';\nport = strtol(port_buf, NULL, 10);\nif (port > 0 && port <= 65535) {\nret->port = (unsigned short) port;\n} else {\n STR_FREE(ret->scheme);\n efree(ret);\n return NULL;\n efree(ret);\n return NULL;\n } else if (e - p > 0) {\nlong port;\nmemcpy(port_buf, p, (e - p));\nport_buf[e - p] = '\\0';\nport = strtol(port_buf, NULL, 10);\nif (port > 0 && port <= 65535) {\nret->port = (unsigned short)port;\n} else {\n STR_FREE(ret->scheme);\n STR_FREE(ret->user);\n STR_FREE(ret->pass);"}
{"scenario": "php-bug-2012-01-27-544e36dfff-acaf9c5227.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 5, "problem": " {\n zval *args[2];\n STDVARS;\n SESS_ZVAL_STRING((char*)save_path, args[0]);\n SESS_ZVAL_STRING((char*)session_name, args[1]);\n retval = ps_call_handler(PSF(open), 2, args TSRMLS_CC);", "fixed": " {\n zval *args[2];\n STDVARS;\nif (PSF(open) == NULL) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\"user session functions not defined\");\nreturn FAILURE;\n}\n SESS_ZVAL_STRING((char*)save_path, args[0]);\n SESS_ZVAL_STRING((char*)session_name, args[1]);\n retval = ps_call_handler(PSF(open), 2, args TSRMLS_CC);"}
{"scenario": "php-bug-2011-12-18-beda5efd41-622412d8e6.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 18, "problem": " if (Z_TYPE_P(dim) != IS_LONG) {\n switch(Z_TYPE_P(dim)) {\n case IS_STRING:\n case IS_DOUBLE:\n case IS_NULL:\n case IS_BOOL:\n break;\n default:\n zend_error(E_WARNING, \"Illegal offset type\");\n if (Z_TYPE_P(dim) != IS_LONG) {\n switch(Z_TYPE_P(dim)) {\n case IS_STRING:\n case IS_DOUBLE:\n case IS_NULL:\n case IS_BOOL:\n break;\n default:\n zend_error(E_WARNING, \"Illegal offset type\");", "fixed": " if (Z_TYPE_P(dim) != IS_LONG) {\n switch(Z_TYPE_P(dim)) {\n case IS_STRING:\nif (IS_LONG == is_numeric_string(Z_STRVAL_P(dim), Z_STRLEN_P(dim), NULL, NULL, -1)) {\nbreak;\n}\nif (type != BP_VAR_UNSET) {\nzend_error(E_WARNING, \"Illegal string offset '%s'\", dim->value.str.val);\n}\nbreak;\n case IS_DOUBLE:\n case IS_NULL:\n case IS_BOOL:\nzend_error(E_NOTICE, \"String offset cast occured\");\n break;\n default:\n zend_error(E_WARNING, \"Illegal offset type\");\n if (Z_TYPE_P(dim) != IS_LONG) {\n switch(Z_TYPE_P(dim)) {\n case IS_STRING:\nif (IS_LONG == is_numeric_string(Z_STRVAL_P(dim), Z_STRLEN_P(dim), NULL, NULL, -1)) {\nbreak;\n}\nif (type != BP_VAR_IS) {\nzend_error(E_WARNING, \"Illegal string offset '%s'\", dim->value.str.val);\n}\nbreak;\n case IS_DOUBLE:\n case IS_NULL:\n case IS_BOOL:\nif (type != BP_VAR_IS) {\nzend_error(E_NOTICE, \"String offset cast occured\");\n}\n break;\n default:\n zend_error(E_WARNING, \"Illegal offset type\");"}
{"scenario": "php-bug-2011-02-27-e65d361fde-1d984a7ffd.tar.gz", "repairActions": ["Adds If Statement"], "lines": 3, "problem": " }\n ZVAL_NULL(&token);\n token_line = CG(zend_lineno);\n }\n }\n PHP_FUNCTION(token_get_all)", "fixed": " }\n ZVAL_NULL(&token);\n token_line = CG(zend_lineno);\nif (token_type == T_HALT_COMPILER) {\nbreak;\n}\n }\n }\n PHP_FUNCTION(token_get_all)"}
{"scenario": "php-bug-2012-03-04-60dfd64bf2-34fe62619d.tar.gz", "repairActions": ["Changes Method Call Args"], "lines": 1, "problem": " opline->op2_type = IS_CONST;\n if (doing_inheritance) {\n if ((new_class_entry->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) {\nzend_error(E_COMPILE_ERROR, \"A trait (%s) cannot extend a class\", new_class_entry->name);\n }\n opline->extended_value = parent_class_name->u.op.var;\n opline->opcode = ZEND_DECLARE_INHERITED_CLASS;", "fixed": " opline->op2_type = IS_CONST;\n if (doing_inheritance) {\n if ((new_class_entry->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) {\nzend_error(E_COMPILE_ERROR, \"A trait (%s) cannot extend a class. Traits can only be composed from other traits with the 'use' keyword. Error\", new_class_entry->name);\n }\n opline->extended_value = parent_class_name->u.op.var;\n opline->opcode = ZEND_DECLARE_INHERITED_CLASS;"}
{"scenario": "php-bug-2011-11-15-2568672691-13ba2da5f6.tar.gz", "repairActions": ["Adds Method Call"], "lines": 2, "problem": " PHP_FE(get_cfg_var,\t\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_get_cfg_var)\n PHP_DEP_FALIAS(magic_quotes_runtime,\tset_magic_quotes_runtime,\t\targinfo_set_magic_quotes_runtime)\n PHP_DEP_FE(set_magic_quotes_runtime,\t\t\t\t\t\t\t\t\targinfo_set_magic_quotes_runtime)\nPHP_DEP_FE(get_magic_quotes_gpc,\t\t\t\t\t\t\t\t\t\targinfo_get_magic_quotes_gpc)\nPHP_DEP_FE(get_magic_quotes_runtime,\t\t\t\t\t\t\t\t\targinfo_get_magic_quotes_runtime)\n PHP_FE(error_log,\t\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_error_log)\n PHP_FE(error_get_last,\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_error_get_last)\n PHP_FE(call_user_func,\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_call_user_func)", "fixed": " PHP_FE(get_cfg_var,\t\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_get_cfg_var)\n PHP_DEP_FALIAS(magic_quotes_runtime,\tset_magic_quotes_runtime,\t\targinfo_set_magic_quotes_runtime)\n PHP_DEP_FE(set_magic_quotes_runtime,\t\t\t\t\t\t\t\t\targinfo_set_magic_quotes_runtime)\nPHP_FE(get_magic_quotes_gpc,\t\t\t\t\t\t\t\t\t\targinfo_get_magic_quotes_gpc)\nPHP_FE(get_magic_quotes_runtime,\t\t\t\t\t\t\t\t\targinfo_get_magic_quotes_runtime)\n PHP_FE(error_log,\t\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_error_log)\n PHP_FE(error_get_last,\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_error_get_last)\n PHP_FE(call_user_func,\t\t\t\t\t\t\t\t\t\t\t\t\targinfo_call_user_func)"}
{"scenario": "php-bug-2011-11-26-7c2946f80e-dc6ecd21ee.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable"], "lines": 28, "problem": " switch (*fptr) {\n case 'D':\n case 'l':\nif (!timelib_lookup_relunit((char **) &ptr)) {\n add_pbf_error(s, \"A textual day could not be found\", string, begin);\n }\n break;\n case 'd':\n case 'j':\n }\n break;\n case 'i':\n TIMELIB_CHECK_NUMBER;\nif ((s->time->i = timelib_get_nr((char **) &ptr, 2)) == TIMELIB_UNSET) {\n add_pbf_error(s, \"A two digit minute could not be found\", string, begin);\n }\n break;\n case 's':\n TIMELIB_CHECK_NUMBER;\nif ((s->time->s = timelib_get_nr((char **) &ptr, 2)) == TIMELIB_UNSET) {\nadd_pbf_error(s, \"A two digit second could not be found\", string, begin);\n }\n break;\n case 'u':", "fixed": " switch (*fptr) {\n case 'D':\n case 'l':\n{\nconst timelib_relunit* tmprel = 0;\ntmprel = timelib_lookup_relunit((char **) &ptr);\nif (!tmprel) {\n add_pbf_error(s, \"A textual day could not be found\", string, begin);\nbreak;\n} else {\nin.time->have_relative = 1;\nin.time->relative.have_weekday_relative = 1;\nin.time->relative.weekday = tmprel->multiplier;\nin.time->relative.weekday_behavior = 1;\n }\n}\n break;\n case 'd':\n case 'j':\n }\n break;\n case 'i':\n{\nint length;\ntimelib_sll min;\n TIMELIB_CHECK_NUMBER;\nmin = timelib_get_nr_ex((char **) &ptr, 2, &length);\nif (min == TIMELIB_UNSET || length != 2) {\n add_pbf_error(s, \"A two digit minute could not be found\", string, begin);\n} else {\ns->time->i = min;\n }\n}\n break;\n case 's':\n{\nint length;\ntimelib_sll sec;\n TIMELIB_CHECK_NUMBER;\nsec = timelib_get_nr_ex((char **) &ptr, 2, &length);\nif (sec == TIMELIB_UNSET || length != 2) {\nadd_pbf_error(s, \"A two second minute could not be found\", string, begin);\n} else {\ns->time->s = sec;\n}\n }\n break;\n case 'u':"}
{"scenario": "php-bug-2012-02-12-3d898cfa3f-af92365239.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition"], "lines": 6, "problem": " }\n array_init_size(return_value, num);\n num--;\n zval_add_ref(&val);\nif (zend_hash_index_update(Z_ARRVAL_P(return_value), start_key, &val, sizeof(zval *), NULL) == FAILURE) {\nzval_ptr_dtor(&val);\n}\n while (num--) {\n zval_add_ref(&val);\nif (zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &val, sizeof(zval *), NULL) == FAILURE) {\nzval_ptr_dtor(&val);\n }\n }\n }", "fixed": " }\n array_init_size(return_value, num);\n num--;\nzend_hash_index_update(Z_ARRVAL_P(return_value), start_key, &val, sizeof(zval *), NULL);\n zval_add_ref(&val);\n while (num--) {\nif (zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &val, sizeof(zval *), NULL) == SUCCESS) {\n zval_add_ref(&val);\n} else {\nzval_dtor(return_value);\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot add element to the array as the next element is already occupied\");\nRETURN_FALSE;\n }\n }\n }"}
{"scenario": "php-bug-2011-11-19-eeba0b5681-f330c8ab4e.tar.gz", "repairActions": [], "lines": 1, "problem": " const char gz_magic[] = \"\\x1f\\x8b\\x08\";\n const char bz_magic[] = \"BZh\";\n char *pos, test = '\\0';\nconst int window_size = 1024 + sizeof(token);\n char buffer[1024 + sizeof(token)];\n const long readsize = sizeof(buffer) - sizeof(token);\n const long tokenlen = sizeof(token) - 1;", "fixed": " const char gz_magic[] = \"\\x1f\\x8b\\x08\";\n const char bz_magic[] = \"BZh\";\n char *pos, test = '\\0';\nconst int window_size = 1024;\n char buffer[1024 + sizeof(token)];\n const long readsize = sizeof(buffer) - sizeof(token);\n const long tokenlen = sizeof(token) - 1;"}
{"scenario": "php-bug-2012-01-01-80dd931d40-7c3177e5ab.tar.gz", "repairActions": ["Adds If Statement"], "lines": 3, "problem": " }\n tmp++;\n }\n }\n total_bytes = cancel_upload = 0;\n temp_filename = NULL;", "fixed": " }\n tmp++;\n }\nif(c != 0) {\nskip_upload = 1;\n}\n }\n total_bytes = cancel_upload = 0;\n temp_filename = NULL;"}
{"scenario": "php-bug-2011-11-02-de50e98a07-8d520d6296.tar.gz", "repairActions": [], "lines": 1, "problem": " {\n zend_class_entry *ce = va_arg(args, zend_class_entry*);\n int add = 0;\nzend_function* existing_fn;\n zend_function fn_copy, *fn_copy_p;\n zend_function* prototype = NULL;\n if (zend_hash_quick_find(&ce->function_table, hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void**) &existing_fn) == FAILURE) {", "fixed": " {\n zend_class_entry *ce = va_arg(args, zend_class_entry*);\n int add = 0;\nzend_function* existing_fn = NULL;\n zend_function fn_copy, *fn_copy_p;\n zend_function* prototype = NULL;\n if (zend_hash_quick_find(&ce->function_table, hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void**) &existing_fn) == FAILURE) {"}
{"scenario": "php-bug-2011-11-19-eeba0b5681-d3b20b4058.tar.gz", "repairActions": [], "lines": 2, "problem": " const char gz_magic[] = \"\\x1f\\x8b\\x08\";\n const char bz_magic[] = \"BZh\";\n char *pos, test = '\\0';\nconst int window_size = 1024 + sizeof(token);\nchar buffer[1024 + sizeof(token)];\n const long readsize = sizeof(buffer) - sizeof(token);\n const long tokenlen = sizeof(token) - 1;\n long halt_offset;", "fixed": " const char gz_magic[] = \"\\x1f\\x8b\\x08\";\n const char bz_magic[] = \"BZh\";\n char *pos, test = '\\0';\nconst int window_size = 1024;\nchar buffer[window_size + sizeof(token)];\n const long readsize = sizeof(buffer) - sizeof(token);\n const long tokenlen = sizeof(token) - 1;\n long halt_offset;"}
{"scenario": "php-bug-2011-11-16-55acfdf7bd-3c7a573a2c.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 3, "problem": " char *name, *cfilename;\n char haltoff[] = \"__COMPILER_HALT_OFFSET__\";\n int len, clen;\n cfilename = zend_get_compiled_filename(TSRMLS_C);\n clen = strlen(cfilename);\n zend_mangle_property_name(&name, &len, haltoff, sizeof(haltoff) - 1, cfilename, clen, 0);", "fixed": " char *name, *cfilename;\n char haltoff[] = \"__COMPILER_HALT_OFFSET__\";\n int len, clen;\nif (CG(has_bracketed_namespaces) && CG(in_namespace)) {\nzend_error(E_COMPILE_ERROR, \"__HALT_COMPILER() can only be used from the outermost scope\");\n}\n cfilename = zend_get_compiled_filename(TSRMLS_C);\n clen = strlen(cfilename);\n zend_mangle_property_name(&name, &len, haltoff, sizeof(haltoff) - 1, cfilename, clen, 0);"}
{"scenario": "python-bug-70120-70124.tar.gz", "repairActions": ["Changes Type", "Adds Method Call"], "lines": 23, "problem": " static PyObject *\n PyZlib_objcompress(compobject *self, PyObject *args)\n {\nint err;\nunsigned int inplen;\n Py_ssize_t length = DEFAULTALLOC;\nPyObject *RetVal = NULL;\n Py_buffer pinput;\n Byte *input;\n unsigned long start_total_out;\n if (!PyArg_ParseTuple(args, \"y*:compress\", &pinput))\n return NULL;\nif (pinput.len > UINT_MAX) {\nPyErr_SetString(PyExc_OverflowError,\n\"Size does not fit in an unsigned int\");\ngoto error_outer;\n}\n input = pinput.buf;\n inplen = pinput.len;\nif (!(RetVal = PyBytes_FromStringAndSize(NULL, length)))\ngoto error_outer;\n ENTER_ZLIB(self);\n start_total_out = self->zst.total_out;\n self->zst.avail_in = inplen;\n }\n error:\n LEAVE_ZLIB(self);\nerror_outer:\n PyBuffer_Release(&pinput);\n return RetVal;\n }\n static PyObject *\n PyZlib_objdecompress(compobject *self, PyObject *args)\n {\nint err, max_length = 0;\nunsigned int inplen;\n Py_ssize_t old_length, length = DEFAULTALLOC;\nPyObject *RetVal = NULL;\n Py_buffer pinput;\n Byte *input;\n unsigned long start_total_out;\n if (!PyArg_ParseTuple(args, \"y*|i:decompress\", &pinput,\n &max_length))\n return NULL;\nif (pinput.len > UINT_MAX) {\nPyErr_SetString(PyExc_OverflowError,\n\"Size does not fit in an unsigned int\");\ngoto error_outer;\n}\n input = pinput.buf;\n inplen = pinput.len;\n if (max_length < 0) {\n PyErr_SetString(PyExc_ValueError,\n \"max_length must be greater than zero\");\ngoto error_outer;\n }\n if (max_length && length > max_length)\n length = max_length;\nif (!(RetVal = PyBytes_FromStringAndSize(NULL, length)))\ngoto error_outer;\n ENTER_ZLIB(self);\n start_total_out = self->zst.total_out;\n self->zst.avail_in = inplen;\n }\n error:\n LEAVE_ZLIB(self);\nerror_outer:\n PyBuffer_Release(&pinput);\n return RetVal;\n }", "fixed": " static PyObject *\n PyZlib_objcompress(compobject *self, PyObject *args)\n {\nint err, inplen;\n Py_ssize_t length = DEFAULTALLOC;\nPyObject *RetVal;\n Py_buffer pinput;\n Byte *input;\n unsigned long start_total_out;\n if (!PyArg_ParseTuple(args, \"y*:compress\", &pinput))\n return NULL;\n input = pinput.buf;\n inplen = pinput.len;\nif (!(RetVal = PyBytes_FromStringAndSize(NULL, length))) {\nPyBuffer_Release(&pinput);\nreturn NULL;\n}\n ENTER_ZLIB(self);\n start_total_out = self->zst.total_out;\n self->zst.avail_in = inplen;\n }\n error:\n LEAVE_ZLIB(self);\n PyBuffer_Release(&pinput);\n return RetVal;\n }\n static PyObject *\n PyZlib_objdecompress(compobject *self, PyObject *args)\n {\nint err, inplen, max_length = 0;\n Py_ssize_t old_length, length = DEFAULTALLOC;\nPyObject *RetVal;\n Py_buffer pinput;\n Byte *input;\n unsigned long start_total_out;\n if (!PyArg_ParseTuple(args, \"y*|i:decompress\", &pinput,\n &max_length))\n return NULL;\n input = pinput.buf;\n inplen = pinput.len;\n if (max_length < 0) {\nPyBuffer_Release(&pinput);\n PyErr_SetString(PyExc_ValueError,\n \"max_length must be greater than zero\");\nreturn NULL;\n }\n if (max_length && length > max_length)\n length = max_length;\nif (!(RetVal = PyBytes_FromStringAndSize(NULL, length))) {\nPyBuffer_Release(&pinput);\nreturn NULL;\n}\n ENTER_ZLIB(self);\n start_total_out = self->zst.total_out;\n self->zst.avail_in = inplen;\n }\n error:\n LEAVE_ZLIB(self);\n PyBuffer_Release(&pinput);\n return RetVal;\n }"}
{"scenario": "php-bug-2012-02-25-c1322d2505-cfa9c90b20.tar.gz", "repairActions": ["Adds Method Call", "Adds Variable"], "lines": 7, "problem": " static int parse_arg_object_to_string(zval **arg, char **p, int *pl, int type TSRMLS_DC)\n {\n if (Z_OBJ_HANDLER_PP(arg, cast_object)) {\nSEPARATE_ZVAL_IF_NOT_REF(arg);\nif (Z_OBJ_HANDLER_PP(arg, cast_object)(*arg, *arg, type TSRMLS_CC) == SUCCESS) {\n *pl = Z_STRLEN_PP(arg);\n *p = Z_STRVAL_PP(arg);\n return SUCCESS;\n }\n }\n if (Z_OBJ_HT_PP(arg) == &std_object_handlers || !Z_OBJ_HANDLER_PP(arg, cast_object)) {\n SEPARATE_ZVAL_IF_NOT_REF(arg);", "fixed": " static int parse_arg_object_to_string(zval **arg, char **p, int *pl, int type TSRMLS_DC)\n {\n if (Z_OBJ_HANDLER_PP(arg, cast_object)) {\nzval *obj;\nALLOC_ZVAL(obj);\nMAKE_COPY_ZVAL(arg, obj);\nif (Z_OBJ_HANDLER_P(*arg, cast_object)(*arg, obj, type TSRMLS_CC) == SUCCESS) {\nzval_ptr_dtor(arg);\n*arg = obj;\n *pl = Z_STRLEN_PP(arg);\n *p = Z_STRVAL_PP(arg);\n return SUCCESS;\n }\nzval_ptr_dtor(&obj);\n }\n if (Z_OBJ_HT_PP(arg) == &std_object_handlers || !Z_OBJ_HANDLER_PP(arg, cast_object)) {\n SEPARATE_ZVAL_IF_NOT_REF(arg);"}
{"scenario": "valgrind-bug-11817-11818.tar.gz", "repairActions": [], "lines": 5, "problem": " fatal(\"error writing %d bytes to shared mem %s\\n\",\n (int) sizeof(VgdbShared), shared_mem);\n }\nshared_mem_fd = VG_(safe_fd)(shared_mem_fd);\nif (shared_mem_fd == -1) {\nfatal(\"safe_fd for vgdb shared_mem %s failed\\n\", shared_mem);\n}\n {\n SysRes res = VG_(am_shared_mmap_file_float_valgrind)\n (sizeof(VgdbShared), VKI_PROT_READ|VKI_PROT_WRITE,\n addr_shared = sr_Res (res);\n }\n shared = (VgdbShared*) addr_shared;\n }\n remote_desc = open_fifo (\"read\", from_gdb, VKI_O_RDONLY|VKI_O_NONBLOCK);\n save_fcntl_flags = VG_(fcntl) (remote_desc, VKI_F_GETFL, 0);", "fixed": " fatal(\"error writing %d bytes to shared mem %s\\n\",\n (int) sizeof(VgdbShared), shared_mem);\n }\n {\n SysRes res = VG_(am_shared_mmap_file_float_valgrind)\n (sizeof(VgdbShared), VKI_PROT_READ|VKI_PROT_WRITE,\n addr_shared = sr_Res (res);\n }\n shared = (VgdbShared*) addr_shared;\nVG_(close) (shared_mem_fd);\n }\n remote_desc = open_fifo (\"read\", from_gdb, VKI_O_RDONLY|VKI_O_NONBLOCK);\n save_fcntl_flags = VG_(fcntl) (remote_desc, VKI_F_GETFL, 0);"}
{"scenario": "libtiff-bug-2010-12-13-96a5fb4-bdba15c.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 61, "problem": "static   char tiffcrop_version_id[] = \"2.3\";\nstatic   char tiffcrop_rev_date[] = \"07-12-2010\";\n extern int getopt(int, char**, char*);\n break;\n default:\n TIFFError(TIFFFileName(in),\n\"Data type %d is not supported, tag %d skipped.\",\n tag, type);\n }\n }\n export_ext[5] = '\\0';\n if (findex > MAX_EXPORT_PAGES)\n {\nTIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded.\\n\", MAX_EXPORT_PAGES);\n return 1;\n }\n sprintf (filenum, \"-%03d%s\", findex, export_ext);\n *tiffout = TIFFOpen(exportname, mode);\n if (*tiffout == NULL)\n {\nTIFFError(\"update_output_file\", \"Unable to open output file %s\\n\", exportname);\n return 1;\n }\n *page = 0;\n unsigned int  end_of_input = FALSE;\n int    seg, length;\n char   temp_filename[PATH_MAX + 1];\nmemset (temp_filename, '\\0', PATH_MAX + 1);\n little_endian = *((unsigned char *)&little_endian) & '1';\n initImageData(&image);\n initCropMasks(&crop);\n {\n if (dump.infile != NULL)\n fclose (dump.infile);\n sprintf (temp_filename, \"%s-read-%03d.%s\", dump.infilename, dump_images,\n (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)\n {\n if (dump.outfile != NULL)\n fclose (dump.outfile);\n sprintf (temp_filename, \"%s-write-%03d.%s\", dump.outfilename, dump_images,\n (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\\n\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (data, 1, count, dumpfile)) != count)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\\n\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\\n\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 1, 1, dumpfile)) != 1)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\\n\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\\n\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 2, 1, dumpfile)) != 2)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\\n\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\\n\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 4, 1, dumpfile)) != 4)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\\n\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\\n\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 8, 1, dumpfile)) != 8)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\\n\");\n return (1);\n }\n }\n unsigned char * dump_ptr;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\\n\");\n return (1);\n }\n for (i = 0; i < rows; i++)\n {\n struct offset offsets;\n int    i;\nint32  test2;\nuint32 test, seg, total, need_buff = 0;\n uint32 buffsize;\n uint32 zwidth, zlength;\n memset(&offsets, '\\0', sizeof(struct offset));\n crop->regionlist[i].y2 = offsets.endy;\n crop->regionlist[i].x1 = offsets.startx +\n (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);\ntest = offsets.startx +\n(uint32)(offsets.crop_width * 1.0 * seg / total);\nif (test > image->width - 1)\n crop->regionlist[i].x2 = image->width - 1;\n else\n crop->regionlist[i].x2 = test - 1;\n zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n crop->combined_length = (uint32)zlength;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n zwidth = offsets.crop_width;\n crop->regionlist[i].x1 = offsets.startx;\n crop->regionlist[i].x2 = offsets.endx;\ntest2 = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);\nif (test2 < 1 )\n crop->regionlist[i].y1 = 0;\n else\ncrop->regionlist[i].y1 = test2 + 1;\ntest = offsets.endy - (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);\nif (test > (image->length - 1))\n crop->regionlist[i].y2 = image->length - 1;\n else\n crop->regionlist[i].y2 = test;\n zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n crop->combined_length += (uint32)zlength;\n crop->regionlist[i].x1 = offsets.startx +\n (uint32)(offsets.crop_width  * (total - seg) * 1.0 / total);\n test = offsets.startx +\n(uint32)(offsets.crop_width * (total - seg + 1) * 1.0 / total);\nif (test > image->width - 1)\n crop->regionlist[i].x2 = image->width - 1;\n else\n crop->regionlist[i].x2 = test - 1;\n zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n crop->combined_length = (uint32)zlength;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n crop->regionlist[i].x2 = offsets.endx;\n crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);\n test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);\nif (test > image->length - 1)\n crop->regionlist[i].y2 = image->length - 1;\n else\n crop->regionlist[i].y2 = test - 1;\n zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n crop->combined_length += (uint32)zlength;\n if (dump->debug)\n {\n TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n\"Hmargin: %3.2f, Vmargin: %3.2f\\n\",\n page->name, page->vres, page->hres,\n page->hmargin, page->vmargin);\nTIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\\n\",\n page->res_unit, scale, pwidth, plength);\n }\n if (page->mode & PAGE_MODE_MARGINS)\n if (subsampling_horiz != 1 || subsampling_vert != 1)\n {\n TIFFError(\"loadImage\",\n\"Can't copy/convert subsampled image with subsampling %d horiz %d vert.\\n\",\n subsampling_horiz, subsampling_vert);\n return (-1);\n }\n {\n if ((bitarray = (char *)malloc(img_width)) == NULL)\n {\nTIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\\n\");\n return (-1);\n }\n }\n row_offset = row * img_rowsize;\n src_offset = row_offset + col_offset;\nTIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\\n\", src_offset, dst_offset);\n _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n dst_offset += full_bytes;\n }\n else\n {\nTIFFError(\"writeCroppedImage\",\n \"JPEG compression requires 8 or 12 bits per sample\");\n return (-1);\n }", "fixed": "static   char tiffcrop_version_id[] = \"2.4\";\nstatic   char tiffcrop_rev_date[] = \"12-13-2010\";\n extern int getopt(int, char**, char*);\n break;\n default:\n TIFFError(TIFFFileName(in),\n\"Data type %d is not supported, tag %d skipped\",\n tag, type);\n }\n }\n export_ext[5] = '\\0';\n if (findex > MAX_EXPORT_PAGES)\n {\nTIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded\", MAX_EXPORT_PAGES);\n return 1;\n }\n sprintf (filenum, \"-%03d%s\", findex, export_ext);\n *tiffout = TIFFOpen(exportname, mode);\n if (*tiffout == NULL)\n {\nTIFFError(\"update_output_file\", \"Unable to open output file %s\", exportname);\n return 1;\n }\n *page = 0;\n unsigned int  end_of_input = FALSE;\n int    seg, length;\n char   temp_filename[PATH_MAX + 1];\n little_endian = *((unsigned char *)&little_endian) & '1';\n initImageData(&image);\n initCropMasks(&crop);\n {\n if (dump.infile != NULL)\n fclose (dump.infile);\nmemset (temp_filename, '\\0', PATH_MAX + 1);\n sprintf (temp_filename, \"%s-read-%03d.%s\", dump.infilename, dump_images,\n (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)\n {\n if (dump.outfile != NULL)\n fclose (dump.outfile);\nmemset (temp_filename, '\\0', PATH_MAX + 1);\n sprintf (temp_filename, \"%s-write-%03d.%s\", dump.outfilename, dump_images,\n (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (data, 1, count, dumpfile)) != count)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 1, 1, dumpfile)) != 1)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 2, 1, dumpfile)) != 2)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 4, 1, dumpfile)) != 4)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\");\n return (1);\n }\n }\n unsigned char bitset;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\");\n return (1);\n }\n if (format == DUMP_TEXT)\n {\n if ((fwrite (&data, 8, 1, dumpfile)) != 8)\n {\nTIFFError (\"\", \"Unable to write binary data to dump file\");\n return (1);\n }\n }\n unsigned char * dump_ptr;\n if (dumpfile == NULL)\n {\nTIFFError (\"\", \"Invalid FILE pointer for dump file\");\n return (1);\n }\n for (i = 0; i < rows; i++)\n {\n struct offset offsets;\n int    i;\nint32  test;\nuint32 seg, total, need_buff = 0;\n uint32 buffsize;\n uint32 zwidth, zlength;\n memset(&offsets, '\\0', sizeof(struct offset));\n crop->regionlist[i].y2 = offsets.endy;\n crop->regionlist[i].x1 = offsets.startx +\n (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);\ntest = (int32)offsets.startx +\n(int32)(offsets.crop_width * 1.0 * seg / total);\nif (test < 1 )\ncrop->regionlist[i].x2 = 0;\nelse\n{\nif (test > (int32)(image->width - 1))\n crop->regionlist[i].x2 = image->width - 1;\n else\n crop->regionlist[i].x2 = test - 1;\n}\n zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n crop->combined_length = (uint32)zlength;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n zwidth = offsets.crop_width;\n crop->regionlist[i].x1 = offsets.startx;\n crop->regionlist[i].x2 = offsets.endx;\ntest = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);\nif (test < 1 )\n crop->regionlist[i].y1 = 0;\n else\ncrop->regionlist[i].y1 = test + 1;\ntest = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);\nif (test < 1 )\ncrop->regionlist[i].y2 = 0;\nelse\n{\nif (test > (int32)(image->length - 1))\n crop->regionlist[i].y2 = image->length - 1;\n else\n crop->regionlist[i].y2 = test;\n}\n zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n crop->combined_length += (uint32)zlength;\n crop->regionlist[i].x1 = offsets.startx +\n (uint32)(offsets.crop_width  * (total - seg) * 1.0 / total);\n test = offsets.startx +\n(offsets.crop_width * (total - seg + 1) * 1.0 / total);\nif (test < 1 )\ncrop->regionlist[i].x2 = 0;\nelse\n{\nif (test > (int32)(image->width - 1))\n crop->regionlist[i].x2 = image->width - 1;\n else\n crop->regionlist[i].x2 = test - 1;\n}\n zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n crop->combined_length = (uint32)zlength;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n crop->regionlist[i].x2 = offsets.endx;\n crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);\n test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);\nif (test < 1 )\ncrop->regionlist[i].y2 = 0;\nelse\n{\nif (test > (int32)(image->length - 1))\n crop->regionlist[i].y2 = image->length - 1;\n else\n crop->regionlist[i].y2 = test - 1;\n}\n zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n if (crop->exp_mode == COMPOSITE_IMAGES)\n crop->combined_length += (uint32)zlength;\n if (dump->debug)\n {\n TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n\"Hmargin: %3.2f, Vmargin: %3.2f\",\n page->name, page->vres, page->hres,\n page->hmargin, page->vmargin);\nTIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\",\n page->res_unit, scale, pwidth, plength);\n }\n if (page->mode & PAGE_MODE_MARGINS)\n if (subsampling_horiz != 1 || subsampling_vert != 1)\n {\n TIFFError(\"loadImage\",\n\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n subsampling_horiz, subsampling_vert);\n return (-1);\n }\n {\n if ((bitarray = (char *)malloc(img_width)) == NULL)\n {\nTIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");\n return (-1);\n }\n }\n row_offset = row * img_rowsize;\n src_offset = row_offset + col_offset;\nTIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset);\n _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n dst_offset += full_bytes;\n }\n else\n {\nTIFFError(\"writeSingleSection\",\n \"JPEG compression requires 8 or 12 bits per sample\");\n return (-1);\n }"}
{"scenario": "php-bug-2011-11-02-c1d520d19d-9b86852d6e.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetcsv, 0, 0, 0)\n ZEND_ARG_INFO(0, delimiter)\n ZEND_ARG_INFO(0, enclosure)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)\n ZEND_ARG_INFO(0, fields)", "fixed": " ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetcsv, 0, 0, 0)\n ZEND_ARG_INFO(0, delimiter)\n ZEND_ARG_INFO(0, enclosure)\nZEND_ARG_INFO(0, escape)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)\n ZEND_ARG_INFO(0, fields)"}
{"scenario": "php-bug-2011-02-21-2a6968e43a-ecb9d8019c.tar.gz", "repairActions": [], "lines": 2, "problem": " }\n PHP_JSON_API void php_json_encode(smart_str *buf, zval *val, int options TSRMLS_DC)\n {\nJSON_G(error_code) = PHP_JSON_ERROR_NONE;\n switch (Z_TYPE_P(val))\n {\n case IS_NULL:\n if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|l\", &parameter, &options) == FAILURE) {\n return;\n }\n php_json_encode(&buf, parameter, options TSRMLS_CC);\n ZVAL_STRINGL(return_value, buf.c, buf.len, 1);\n smart_str_free(&buf);", "fixed": " }\n PHP_JSON_API void php_json_encode(smart_str *buf, zval *val, int options TSRMLS_DC)\n {\n switch (Z_TYPE_P(val))\n {\n case IS_NULL:\n if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|l\", &parameter, &options) == FAILURE) {\n return;\n }\nJSON_G(error_code) = PHP_JSON_ERROR_NONE;\n php_json_encode(&buf, parameter, options TSRMLS_CC);\n ZVAL_STRINGL(return_value, buf.c, buf.len, 1);\n smart_str_free(&buf);"}
{"scenario": "php-bug-2011-11-11-fcbfbea8d2-c1e510aea8.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 4, "problem": " }\n zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\nif (!IS_ABSOLUTE_PATH(intern->file_name, intern->file_name_len)) {\n char expanded_path[MAXPATHLEN];\n if (!expand_filepath_with_mode(intern->file_name, expanded_path, NULL, 0, CWD_EXPAND  TSRMLS_CC)) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"No such file or directory\");", "fixed": " }\n zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\nif (intern->file_name == NULL) {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename\");\nRETURN_FALSE;\n} else if (!IS_ABSOLUTE_PATH(intern->file_name, intern->file_name_len)) {\n char expanded_path[MAXPATHLEN];\n if (!expand_filepath_with_mode(intern->file_name, expanded_path, NULL, 0, CWD_EXPAND  TSRMLS_CC)) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"No such file or directory\");"}
{"scenario": "php-bug-2011-11-15-236120d80e-fb37f3b20d.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition"], "lines": 1, "problem": " p[63] = '\\0';\n }\n RETVAL_FALSE;\nif ((fd = php_open_temporary_fd(dir, p, &opened_path TSRMLS_CC)) >= 0) {\n close(fd);\n RETVAL_STRING(opened_path, 0);\n }", "fixed": " p[63] = '\\0';\n }\n RETVAL_FALSE;\nif ((fd = php_open_temporary_fd_ex(dir, p, &opened_path, 1 TSRMLS_CC)) >= 0) {\n close(fd);\n RETVAL_STRING(opened_path, 0);\n }"}
{"scenario": "php-bug-2011-01-30-5bb0a44e06-1e91069eb4.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " dateobj->time->y = y;\n dateobj->time->m = 1;\n dateobj->time->d = 1;\n dateobj->time->relative.d = timelib_daynr_from_weeknr(y, w, d);\n dateobj->time->have_relative = 1;\n timelib_update_ts(dateobj->time, NULL);", "fixed": " dateobj->time->y = y;\n dateobj->time->m = 1;\n dateobj->time->d = 1;\nmemset(&dateobj->time->relative, 0, sizeof(dateobj->time->relative));\n dateobj->time->relative.d = timelib_daynr_from_weeknr(y, w, d);\n dateobj->time->have_relative = 1;\n timelib_update_ts(dateobj->time, NULL);"}
{"scenario": "libtiff-bug-2006-02-23-b2ce5d8-207c78a.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 5, "problem": " }\n break;\n default:\nif (!TIFFWriteNormalTag(tif, dir, fip))\n goto bad;\n break;\n }", "fixed": " }\n break;\n default:\nif (fip->field_tag == TIFFTAG_DOTRANGE) {\nif (!TIFFSetupShortPair(tif, fip->field_tag, dir))\ngoto bad;\n}\nelse if (!TIFFWriteNormalTag(tif, dir, fip))\n goto bad;\n break;\n }"}
{"scenario": "php-bug-2012-01-13-583292ab22-d74a258f24.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement", "Adds Variable"], "lines": 45, "problem": " if (ZEND_LOG_XOR(fe->common.arg_info[i].class_name, proto->common.arg_info[i].class_name)) {\n return 0;\n }\nif (fe->common.arg_info[i].class_name\n&& strcasecmp(fe->common.arg_info[i].class_name, proto->common.arg_info[i].class_name)!=0) {\n const char *colon;\n if (fe->common.type != ZEND_USER_FUNCTION) {\n return 0;\n} else if (strchr(proto->common.arg_info[i].class_name, '\\\\') != NULL ||\n(colon = zend_memrchr(fe->common.arg_info[i].class_name, '\\\\', fe->common.arg_info[i].class_name_len)) == NULL ||\nstrcasecmp(colon+1, proto->common.arg_info[i].class_name) != 0) {\n zend_class_entry **fe_ce, **proto_ce;\n int found, found2;\nfound = zend_lookup_class(fe->common.arg_info[i].class_name, fe->common.arg_info[i].class_name_len, &fe_ce TSRMLS_CC);\nfound2 = zend_lookup_class(proto->common.arg_info[i].class_name, proto->common.arg_info[i].class_name_len, &proto_ce TSRMLS_CC);\n if (found != SUCCESS || found2 != SUCCESS ||\n (*fe_ce)->type == ZEND_INTERNAL_CLASS ||\n (*proto_ce)->type == ZEND_INTERNAL_CLASS ||\n }\n }\n }\n if (fe->common.arg_info[i].type_hint != proto->common.arg_info[i].type_hint) {\n return 0;\n }\n required = fptr->common.required_num_args;\n for (i = 0; i < fptr->common.num_args;) {\n if (arg_info->class_name) {\nREALLOC_BUF_IF_EXCEED(buf, offset, length, arg_info->class_name_len);\nmemcpy(offset, arg_info->class_name, arg_info->class_name_len);\noffset += arg_info->class_name_len;\n *(offset++) = ' ';\n } else if (arg_info->type_hint) {\n zend_uint type_name_len;", "fixed": " if (ZEND_LOG_XOR(fe->common.arg_info[i].class_name, proto->common.arg_info[i].class_name)) {\n return 0;\n }\nif (fe->common.arg_info[i].class_name) {\nconst char *fe_class_name, *proto_class_name;\nzend_uint fe_class_name_len, proto_class_name_len;\nif (!strcasecmp(fe->common.arg_info[i].class_name, \"parent\") && proto->common.scope) {\nfe_class_name = proto->common.scope->name;\nfe_class_name_len = proto->common.scope->name_length;\n} else if (!strcasecmp(fe->common.arg_info[i].class_name, \"self\") && fe->common.scope) {\nfe_class_name = fe->common.scope->name;\nfe_class_name_len = fe->common.scope->name_length;\n} else {\nfe_class_name = fe->common.arg_info[i].class_name;\nfe_class_name_len = fe->common.arg_info[i].class_name_len;\n}\nif (!strcasecmp(proto->common.arg_info[i].class_name, \"parent\") && proto->common.scope && proto->common.scope->parent) {\nproto_class_name = proto->common.scope->parent->name;\nproto_class_name_len = proto->common.scope->parent->name_length;\n} else if (!strcasecmp(proto->common.arg_info[i].class_name, \"self\") && proto->common.scope) {\nproto_class_name = proto->common.scope->name;\nproto_class_name_len = proto->common.scope->name_length;\n} else {\nproto_class_name = proto->common.arg_info[i].class_name;\nproto_class_name_len = proto->common.arg_info[i].class_name_len;\n}\nif (strcasecmp(fe_class_name, proto_class_name)!=0) {\n const char *colon;\n if (fe->common.type != ZEND_USER_FUNCTION) {\n return 0;\n} else if (strchr(proto_class_name, '\\\\') != NULL ||\n(colon = zend_memrchr(fe_class_name, '\\\\', fe_class_name_len)) == NULL ||\nstrcasecmp(colon+1, proto_class_name) != 0) {\n zend_class_entry **fe_ce, **proto_ce;\n int found, found2;\nfound = zend_lookup_class(fe_class_name, fe_class_name_len, &fe_ce TSRMLS_CC);\nfound2 = zend_lookup_class(proto_class_name, proto_class_name_len, &proto_ce TSRMLS_CC);\n if (found != SUCCESS || found2 != SUCCESS ||\n (*fe_ce)->type == ZEND_INTERNAL_CLASS ||\n (*proto_ce)->type == ZEND_INTERNAL_CLASS ||\n }\n }\n }\n}\n if (fe->common.arg_info[i].type_hint != proto->common.arg_info[i].type_hint) {\n return 0;\n }\n required = fptr->common.required_num_args;\n for (i = 0; i < fptr->common.num_args;) {\n if (arg_info->class_name) {\nconst char *class_name;\nzend_uint class_name_len;\nif (!strcasecmp(arg_info->class_name, \"self\") && fptr->common.scope ) {\nclass_name = fptr->common.scope->name;\nclass_name_len = fptr->common.scope->name_length;\n} else if (!strcasecmp(arg_info->class_name, \"parent\") && fptr->common.scope->parent) {\nclass_name = fptr->common.scope->parent->name;\nclass_name_len = fptr->common.scope->parent->name_length;\n} else {\nclass_name = arg_info->class_name;\nclass_name_len = arg_info->class_name_len;\n}\nREALLOC_BUF_IF_EXCEED(buf, offset, length, class_name_len);\nmemcpy(offset, class_name, class_name_len);\noffset += class_name_len;\n *(offset++) = ' ';\n } else if (arg_info->type_hint) {\n zend_uint type_name_len;"}
{"scenario": "libtiff-bug-2007-07-19-ce4b7af-7d6e298.tar.gz", "repairActions": ["Changes Condition"], "lines": 7, "problem": " void\n _TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n {\nif (tif->tif_fields && tif->tif_nfields > 0) {\n uint32 i;\n for (i = 0; i < tif->tif_nfields; i++) {\n TIFFField *fld = tif->tif_fields[i];\n }\n }\n _TIFFfree(tif->tif_fields);\ntif->tif_fields = NULL;\n tif->tif_nfields = 0;\n }\n if (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n }\n }\n tif->tif_foundfield = NULL;\nif (tif->tif_fields && tif->tif_nfields > 0) {\n tif->tif_fields = (TIFFField**)\n _TIFFCheckRealloc(tif, tif->tif_fields,\n (tif->tif_nfields + n),\n if (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n return tif->tif_foundfield;\nif (!tif->tif_fields)\n return NULL;\n key.field_tag = tag;\n key.field_type = dt;\n ret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n && streq(tif->tif_foundfield->field_name, field_name)\n && (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n return (tif->tif_foundfield);\nif (!tif->tif_fields)\n return NULL;\n key.field_name = (char *)field_name;\n key.field_type = dt;\n ret = (const TIFFField **) lfind(&pkey, tif->tif_fields,", "fixed": " void\n _TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n {\nif (tif->tif_fields) {\n uint32 i;\n for (i = 0; i < tif->tif_nfields; i++) {\n TIFFField *fld = tif->tif_fields[i];\n }\n }\n _TIFFfree(tif->tif_fields);\n tif->tif_nfields = 0;\n }\n if (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n }\n }\n tif->tif_foundfield = NULL;\nif (tif->tif_nfields > 0) {\n tif->tif_fields = (TIFFField**)\n _TIFFCheckRealloc(tif, tif->tif_fields,\n (tif->tif_nfields + n),\n if (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n return tif->tif_foundfield;\nif ( !tif->tif_fields ) {\n return NULL;\n}\n key.field_tag = tag;\n key.field_type = dt;\n ret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n && streq(tif->tif_foundfield->field_name, field_name)\n && (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n return (tif->tif_foundfield);\nif ( !tif->tif_fields ) {\n return NULL;\n}\n key.field_name = (char *)field_name;\n key.field_type = dt;\n ret = (const TIFFField **) lfind(&pkey, tif->tif_fields,"}
{"scenario": "php-bug-2011-10-30-c1a4a36c14-5921e73a37.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Adds If Statement"], "lines": 4, "problem": " *(offset++) = '.';\n }\n *(offset++) = '\\'';\n } else {\n zend_make_printable_zval(zv, &zv_copy, &use_copy);\n REALLOC_BUF_IF_EXCEED(buf, offset, length, Z_STRLEN(zv_copy));\n *(offset++) = ' ';\n }\n arg_info++;\nREALLOC_BUF_IF_EXCEED(buf, offset, length, 23);\n }\n }\n *(offset++) = ')';", "fixed": " *(offset++) = '.';\n }\n *(offset++) = '\\'';\n} else if (Z_TYPE_P(zv) == IS_ARRAY) {\nmemcpy(offset, \"Array\", 5);\noffset += 5;\n } else {\n zend_make_printable_zval(zv, &zv_copy, &use_copy);\n REALLOC_BUF_IF_EXCEED(buf, offset, length, Z_STRLEN(zv_copy));\n *(offset++) = ' ';\n }\n arg_info++;\nREALLOC_BUF_IF_EXCEED(buf, offset, length, 32);\n }\n }\n *(offset++) = ')';"}
{"scenario": "php-bug-2011-04-09-db01e840c2-09b990f499.tar.gz", "repairActions": ["Adds Method Call"], "lines": 3, "problem": " return NULL;\n }\n }\nif (LIBXML(stream_context)) {\ncontext = zend_fetch_resource(&LIBXML(stream_context) TSRMLS_CC, -1, \"Stream-Context\", NULL, 1, php_le_stream_context(TSRMLS_C));\n}\n ret_val = php_stream_open_wrapper_ex(path_to_open, (char *)mode, REPORT_ERRORS, NULL, context);\n if (isescaped) {\n xmlFree(resolved_path);", "fixed": " return NULL;\n }\n }\ncontext = php_stream_context_from_zval(LIBXML(stream_context), 0);\n ret_val = php_stream_open_wrapper_ex(path_to_open, (char *)mode, REPORT_ERRORS, NULL, context);\n if (isescaped) {\n xmlFree(resolved_path);"}
{"scenario": "gzip-bug-2009-09-26-a1d3d4019d-f17cbd13a1.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " clear_bufs();\n to_stdout = 1;\n part_nb = 0;\n if (decompress) {\n method = get_method(ifd);\n if (method < 0) {", "fixed": " clear_bufs();\n to_stdout = 1;\n part_nb = 0;\nifd = fileno(stdin);\n if (decompress) {\n method = get_method(ifd);\n if (method < 0) {"}
{"scenario": "php-bug-2011-01-09-7c6310852e-478e5d1dd0.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Method"], "lines": 40, "problem": " static ZEND_FUNCTION(property_exists);\n static ZEND_FUNCTION(class_exists);\n static ZEND_FUNCTION(interface_exists);\n static ZEND_FUNCTION(function_exists);\n static ZEND_FUNCTION(class_alias);\n ZEND_ARG_INFO(0, classname)\n ZEND_ARG_INFO(0, autoload)\n ZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO_EX(arginfo_function_exists, 0, 0, 1)\n ZEND_ARG_INFO(0, function_name)\n ZEND_END_ARG_INFO()\n ZEND_FE(property_exists,\targinfo_property_exists)\n ZEND_FE(class_exists,\t\targinfo_class_exists)\n ZEND_FE(interface_exists,\targinfo_class_exists)\n ZEND_FE(function_exists,\targinfo_function_exists)\n ZEND_FE(class_alias,\t\targinfo_class_alias)\n }\n found = zend_hash_find(EG(class_table), name, len+1, (void **) &ce);\n free_alloca(lc_name, use_heap);\nRETURN_BOOL(found == SUCCESS && !((*ce)->ce_flags & ZEND_ACC_INTERFACE));\n }\n if (zend_lookup_class(class_name, class_name_len, &ce TSRMLS_CC) == SUCCESS) {\nRETURN_BOOL(((*ce)->ce_flags & ZEND_ACC_INTERFACE) == 0);\n } else {\n RETURN_FALSE;\n }\n }\n if (zend_lookup_class(iface_name, iface_name_len, &ce TSRMLS_CC) == SUCCESS) {\n RETURN_BOOL(((*ce)->ce_flags & ZEND_ACC_INTERFACE) > 0);\n } else {\n RETURN_FALSE;\n }", "fixed": " static ZEND_FUNCTION(property_exists);\n static ZEND_FUNCTION(class_exists);\n static ZEND_FUNCTION(interface_exists);\nstatic ZEND_FUNCTION(trait_exists);\n static ZEND_FUNCTION(function_exists);\n static ZEND_FUNCTION(class_alias);\n ZEND_ARG_INFO(0, classname)\n ZEND_ARG_INFO(0, autoload)\n ZEND_END_ARG_INFO()\nZEND_BEGIN_ARG_INFO_EX(arginfo_trait_exists, 0, 0, 1)\nZEND_ARG_INFO(0, traitname)\nZEND_ARG_INFO(0, autoload)\nZEND_END_ARG_INFO()\n ZEND_BEGIN_ARG_INFO_EX(arginfo_function_exists, 0, 0, 1)\n ZEND_ARG_INFO(0, function_name)\n ZEND_END_ARG_INFO()\n ZEND_FE(property_exists,\targinfo_property_exists)\n ZEND_FE(class_exists,\t\targinfo_class_exists)\n ZEND_FE(interface_exists,\targinfo_class_exists)\nZEND_FE(trait_exists,\t\targinfo_trait_exists)\n ZEND_FE(function_exists,\targinfo_function_exists)\n ZEND_FE(class_alias,\t\targinfo_class_alias)\n }\n found = zend_hash_find(EG(class_table), name, len+1, (void **) &ce);\n free_alloca(lc_name, use_heap);\nRETURN_BOOL(found == SUCCESS && !((*ce)->ce_flags & (ZEND_ACC_INTERFACE | ZEND_ACC_TRAIT) > ZEND_ACC_EXPLICIT_ABSTRACT_CLASS));\n }\n if (zend_lookup_class(class_name, class_name_len, &ce TSRMLS_CC) == SUCCESS) {\nRETURN_BOOL(((*ce)->ce_flags & (ZEND_ACC_INTERFACE | (ZEND_ACC_TRAIT - ZEND_ACC_EXPLICIT_ABSTRACT_CLASS))) == 0);\n } else {\n RETURN_FALSE;\n }\n }\n if (zend_lookup_class(iface_name, iface_name_len, &ce TSRMLS_CC) == SUCCESS) {\n RETURN_BOOL(((*ce)->ce_flags & ZEND_ACC_INTERFACE) > 0);\n} else {\nRETURN_FALSE;\n}\n}\nZEND_FUNCTION(trait_exists)\n{\nchar *trait_name, *lc_name;\nzend_class_entry **ce;\nint trait_name_len;\nint found;\nzend_bool autoload = 1;\nALLOCA_FLAG(use_heap)\nif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|b\", &trait_name, &trait_name_len, &autoload) == FAILURE) {\nreturn;\n}\nif (!autoload) {\nchar *name;\nint len;\nlc_name = do_alloca(trait_name_len + 1, use_heap);\nzend_str_tolower_copy(lc_name, trait_name, trait_name_len);\nname = lc_name;\nlen = trait_name_len;\nif (lc_name[0] == '\\\\') {\nname = &lc_name[1];\nlen--;\n}\nfound = zend_hash_find(EG(class_table), name, len+1, (void **) &ce);\nfree_alloca(lc_name, use_heap);\nRETURN_BOOL(found == SUCCESS && (((*ce)->ce_flags & ZEND_ACC_TRAIT) > ZEND_ACC_EXPLICIT_ABSTRACT_CLASS));\n}\nif (zend_lookup_class(trait_name, trait_name_len, &ce TSRMLS_CC) == SUCCESS) {\nRETURN_BOOL(((*ce)->ce_flags & ZEND_ACC_TRAIT) > ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);\n } else {\n RETURN_FALSE;\n }"}
{"scenario": "python-bug-70056-70059.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " avail = Py_SAFE_DOWNCAST(self->buffer_size - self->pos, Py_off_t, Py_ssize_t);\n if (buf.len <= avail) {\n memcpy(self->buffer + self->pos, buf.buf, buf.len);\nif (!VALID_WRITE_BUFFER(self)) {\n self->write_pos = self->pos;\n }\n ADJUST_POSITION(self, self->pos + buf.len);", "fixed": " avail = Py_SAFE_DOWNCAST(self->buffer_size - self->pos, Py_off_t, Py_ssize_t);\n if (buf.len <= avail) {\n memcpy(self->buffer + self->pos, buf.buf, buf.len);\nif (!VALID_WRITE_BUFFER(self) || self->write_pos > self->pos) {\n self->write_pos = self->pos;\n }\n ADJUST_POSITION(self, self->pos + buf.len);"}
{"scenario": "php-bug-2011-02-14-86efc8e55e-d1d61ce612.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable"], "lines": 17, "problem": " {\n char *tmp2;\n php_stream_wrapper *wrap;\nstruct stat sb;\n if (buffer == NULL || !*buffer) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename or path\");\n RETVAL_FALSE;\n goto clean;\n }\nif (php_sys_stat(buffer, &sb) == 0) {\nif (sb.st_mode & _S_IFDIR) {\nret_val = mime_directory;\ngoto common;\n}\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"File or path not found '%s'\", buffer);\nRETVAL_FALSE;\ngoto clean;\n}\n wrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);\n if (wrap) {\n php_stream_context *context = php_stream_context_from_zval(zcontext, 0);\n RETVAL_FALSE;\n goto clean;\n }\n ret_val = (char *)magic_stream(magic, stream);\n php_stream_close(stream);\n }\n break;", "fixed": " {\n char *tmp2;\n php_stream_wrapper *wrap;\nphp_stream_statbuf ssb;\n if (buffer == NULL || !*buffer) {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename or path\");\n RETVAL_FALSE;\n goto clean;\n }\n wrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);\n if (wrap) {\n php_stream_context *context = php_stream_context_from_zval(zcontext, 0);\n RETVAL_FALSE;\n goto clean;\n }\nif (php_stream_stat(stream, &ssb) == SUCCESS) {\nif (ssb.sb.st_mode & S_IFDIR) {\nret_val = mime_directory;\n} else {\n ret_val = (char *)magic_stream(magic, stream);\n}\n}\n php_stream_close(stream);\n }\n break;"}
{"scenario": "php-bug-2011-02-16-eb0dd2b8ab-9bbc114b59.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds If Statement"], "lines": 43, "problem": " static php_stream *user_wrapper_opener(php_stream_wrapper *wrapper, char *filename, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC)\n {\n struct php_user_stream_wrapper *uwrap = (struct php_user_stream_wrapper*)wrapper->abstract;\n } else {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s::\" USERSTREAM_LOCK \" is not implemented!\",\n us->wrapper->classname);\n }\n }\n break;", "fixed": " static php_stream *user_wrapper_opener(php_stream_wrapper *wrapper, char *filename, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC)\n {\n struct php_user_stream_wrapper *uwrap = (struct php_user_stream_wrapper*)wrapper->abstract;\n } else {\n php_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s::\" USERSTREAM_LOCK \" is not implemented!\",\n us->wrapper->classname);\n}\n}\nbreak;\ncase PHP_STREAM_OPTION_TRUNCATE_API:\nZVAL_STRINGL(&func_name, USERSTREAM_TRUNCATE, sizeof(USERSTREAM_TRUNCATE)-1, 0);\nswitch (value) {\ncase PHP_STREAM_TRUNCATE_SUPPORTED:\nif (zend_is_callable_ex(&func_name, us->object, IS_CALLABLE_CHECK_SILENT,\nNULL, NULL, NULL, NULL TSRMLS_CC))\nret = PHP_STREAM_OPTION_RETURN_OK;\nelse\nret = PHP_STREAM_OPTION_RETURN_ERR;\nbreak;\ncase PHP_STREAM_TRUNCATE_SET_SIZE: {\nptrdiff_t new_size = *(ptrdiff_t*) ptrparam;\nif (new_size >= 0 && new_size <= (ptrdiff_t)LONG_MAX) {\nMAKE_STD_ZVAL(zvalue);\nZVAL_LONG(zvalue, (long)new_size);\nargs[0] = &zvalue;\ncall_result = call_user_function_ex(NULL,\n&us->object,\n&func_name,\n&retval,\n1, args, 0, NULL TSRMLS_CC);\nif (call_result == SUCCESS && retval != NULL) {\nif (Z_TYPE_P(retval) == IS_BOOL) {\nret = Z_LVAL_P(retval) ? PHP_STREAM_OPTION_RETURN_OK :\nPHP_STREAM_OPTION_RETURN_ERR;\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\"%s::\" USERSTREAM_TRUNCATE \" did not return a boolean!\",\nus->wrapper->classname);\n}\n} else {\nphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\"%s::\" USERSTREAM_TRUNCATE \" is not implemented!\",\nus->wrapper->classname);\n}\n} else {\nret = PHP_STREAM_OPTION_RETURN_ERR;\n}\nbreak;\n }\n }\n break;"}
{"scenario": "libtiff-bug-2006-03-03-a72cf60-0a36d7f.tar.gz", "repairActions": ["Changes Condition"], "lines": 1, "problem": " {\n int w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\n tsize_t cc = dir->tdir_count * w;\nif (!dir->tdir_count || !w || (tsize_t)dir->tdir_count / w != cc)\n goto bad;\n if (!isMapped(tif)) {\n if (!SeekOK(tif, dir->tdir_offset))", "fixed": " {\n int w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\n tsize_t cc = dir->tdir_count * w;\nif (!dir->tdir_count || !w || cc / w != (tsize_t)dir->tdir_count)\n goto bad;\n if (!isMapped(tif)) {\n if (!SeekOK(tif, dir->tdir_offset))"}
{"scenario": "php-bug-2011-03-11-d890ece3fc-6e74d95f34.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 4, "problem": " if ((p = memchr(s, '?', (ue - s)))) {\npp = strchr(s, '\n if (pp && pp < p) {\n p = pp;\n goto label_parse;\n }", "fixed": " if ((p = memchr(s, '?', (ue - s)))) {\npp = strchr(s, '\n if (pp && pp < p) {\nif (pp - s) {\nret->path = estrndup(s, (pp-s));\nphp_replace_controlchars_ex(ret->path, (pp - s));\n}\n p = pp;\n goto label_parse;\n }"}
{"scenario": "libtiff-bug-2006-02-27-6074705-e6d0c32.tar.gz", "repairActions": ["Changes Method Call Args", "Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Loop", "Adds Method"], "lines": 67, "problem": " static\tuint16 predictor = 0;\n static\tint quality = 75;\n static\tint jpegcolormode = JPEGCOLORMODE_RGB;\n static\tvoid usage(void);\n static\tint processCompressOptions(char*);\n static void\n uint32 rowsperstrip = (uint32) -1;\n double resolution = -1;\n unsigned char *buf = NULL;\ntsize_t linebytes;\n uint16 spp = 1;\n TIFF *out;\n FILE *in;\n unsigned int w, h, prec, row;\n int c;\n extern int optind;\n extern char* optarg;\nif ( argc < 2 ) {\n fprintf(stderr, \"%s: Too few arguments\\n\", argv[0]);\n usage();\n }\n case '?':\n usage();\n }\nif ( optind + 2 < argc ) {\n fprintf(stderr, \"%s: Too many arguments\\n\", argv[0]);\n usage();\n }\n if (fgetc(in) != 'P')\n BadPPM(infile);\n switch (fgetc(in)) {\n case '5':\n spp = 1;\n photometric = PHOTOMETRIC_MINISBLACK;\n break;\n case '6':\n spp = 3;\n photometric = PHOTOMETRIC_RGB;\n if (compression == COMPRESSION_JPEG &&\n ungetc(c, in);\n break;\n }\n if (fscanf(in, \" %u %u %u\", &w, &h, &prec) != 3)\n BadPPM(infile);\n if (fgetc(in) != '\\n' || prec != 255)\n BadPPM(infile);\n out = TIFFOpen(argv[optind], \"w\");\n if (out == NULL)\n return (-4);\n TIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h);\n TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\nTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n if (predictor != 0)\n TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n break;\n }\n linebytes = spp * w;\n if (TIFFScanlineSize(out) > linebytes)\n buf = (unsigned char *)_TIFFmalloc(linebytes);\n else\n buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\nTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\nTIFFDefaultStripSize(out, rowsperstrip));\n if (resolution > 0) {\n TIFFSetField(out, TIFFTAG_XRESOLUTION, resolution);\n TIFFSetField(out, TIFFTAG_YRESOLUTION, resolution);\n _TIFFfree(buf);\n return (0);\n }\n static int\n processCompressOptions(char* opt)\n {\n else if (strneq(opt, \"jpeg\", 4)) {\n char* cp = strchr(opt, ':');\n compression = COMPRESSION_JPEG;\nwhile( cp )\n {\n if (isdigit((int)cp[1]))\n quality = atoi(cp+1);\n usage();\n cp = strchr(cp+1,':');\n }\n } else if (strneq(opt, \"lzw\", 3)) {\n char* cp = strchr(opt, ':');\n if (cp)\n \" -c lzw[:opts]\tcompress output with Lempel-Ziv & Welch encoding\",\n \" -c zip[:opts]\tcompress output with deflate encoding\",\n \" -c packbits\tcompress output with packbits encoding (the default)\",\n \" -c none\tuse no compression algorithm on output\",\n \"\",\n \"JPEG options:\",", "fixed": " static\tuint16 predictor = 0;\n static\tint quality = 75;\n static\tint jpegcolormode = JPEGCOLORMODE_RGB;\nstatic  uint32 g3opts;\n static\tvoid usage(void);\n static\tint processCompressOptions(char*);\n static void\n uint32 rowsperstrip = (uint32) -1;\n double resolution = -1;\n unsigned char *buf = NULL;\ntsize_t linebytes = 0;\n uint16 spp = 1;\nuint16 bpp = 8;\n TIFF *out;\n FILE *in;\n unsigned int w, h, prec, row;\n int c;\n extern int optind;\n extern char* optarg;\nif (argc < 2) {\n fprintf(stderr, \"%s: Too few arguments\\n\", argv[0]);\n usage();\n }\n case '?':\n usage();\n }\nif (optind + 2 < argc) {\n fprintf(stderr, \"%s: Too many arguments\\n\", argv[0]);\n usage();\n }\n if (fgetc(in) != 'P')\n BadPPM(infile);\n switch (fgetc(in)) {\ncase '4':\nbpp = 1;\nspp = 1;\nphotometric = PHOTOMETRIC_MINISWHITE;\nbreak;\n case '5':\nbpp = 8;\n spp = 1;\n photometric = PHOTOMETRIC_MINISBLACK;\n break;\n case '6':\nbpp = 8;\n spp = 3;\n photometric = PHOTOMETRIC_RGB;\n if (compression == COMPRESSION_JPEG &&\n ungetc(c, in);\n break;\n }\nswitch (bpp) {\ncase 1:\nif (fscanf(in, \" %u %u\", &w, &h) != 2)\nBadPPM(infile);\nif (fgetc(in) != '\\n')\nBadPPM(infile);\nbreak;\ncase 8:\n if (fscanf(in, \" %u %u %u\", &w, &h, &prec) != 3)\n BadPPM(infile);\n if (fgetc(in) != '\\n' || prec != 255)\n BadPPM(infile);\nbreak;\n}\n out = TIFFOpen(argv[optind], \"w\");\n if (out == NULL)\n return (-4);\n TIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h);\n TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\nTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bpp);\n TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n if (predictor != 0)\n TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n break;\ncase COMPRESSION_CCITTFAX3:\nTIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\nbreak;\n }\nswitch (bpp) {\ncase 1:\nlinebytes = (spp * w + (8 - 1)) / 8;\nif (rowsperstrip == (uint32) -1) {\nTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, h);\n} else {\nTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\nTIFFDefaultStripSize(out, rowsperstrip));\n}\nbreak;\ncase 8:\n linebytes = spp * w;\nTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\nTIFFDefaultStripSize(out, rowsperstrip));\nbreak;\n}\n if (TIFFScanlineSize(out) > linebytes)\n buf = (unsigned char *)_TIFFmalloc(linebytes);\n else\n buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n if (resolution > 0) {\n TIFFSetField(out, TIFFTAG_XRESOLUTION, resolution);\n TIFFSetField(out, TIFFTAG_YRESOLUTION, resolution);\n _TIFFfree(buf);\n return (0);\n }\nstatic void\nprocessG3Options(char* cp)\n{\ng3opts = 0;\nif( (cp = strchr(cp, ':')) ) {\ndo {\ncp++;\nif (strneq(cp, \"1d\", 2))\ng3opts &= ~GROUP3OPT_2DENCODING;\nelse if (strneq(cp, \"2d\", 2))\ng3opts |= GROUP3OPT_2DENCODING;\nelse if (strneq(cp, \"fill\", 4))\ng3opts |= GROUP3OPT_FILLBITS;\nelse\nusage();\n} while( (cp = strchr(cp, ':')) );\n}\n}\n static int\n processCompressOptions(char* opt)\n {\n else if (strneq(opt, \"jpeg\", 4)) {\n char* cp = strchr(opt, ':');\n compression = COMPRESSION_JPEG;\nwhile (cp)\n {\n if (isdigit((int)cp[1]))\n quality = atoi(cp+1);\n usage();\n cp = strchr(cp+1,':');\n }\n} else if (strneq(opt, \"g3\", 2)) {\nprocessG3Options(opt);\ncompression = COMPRESSION_CCITTFAX3;\n} else if (streq(opt, \"g4\")) {\ncompression = COMPRESSION_CCITTFAX4;\n } else if (strneq(opt, \"lzw\", 3)) {\n char* cp = strchr(opt, ':');\n if (cp)\n \" -c lzw[:opts]\tcompress output with Lempel-Ziv & Welch encoding\",\n \" -c zip[:opts]\tcompress output with deflate encoding\",\n \" -c packbits\tcompress output with packbits encoding (the default)\",\n\" -c g3[:opts]  compress output with CCITT Group 3 encoding\",\n\" -c g4         compress output with CCITT Group 4 encoding\",\n \" -c none\tuse no compression algorithm on output\",\n \"\",\n \"JPEG options:\","}
{"scenario": "libtiff-bug-2006-03-03-eec4c06-ee65c74.tar.gz", "repairActions": ["Changes Condition"], "lines": 8, "problem": " {\n int w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\n tsize_t cc = dir->tdir_count * w;\nif (!dir->tdir_count || !w || (tsize_t)dir->tdir_count / w != cc)\ngoto bad;\n if (!isMapped(tif)) {\n if (!SeekOK(tif, dir->tdir_offset))\n goto bad;\n if (!ReadOK(tif, cp, cc))\n goto bad;\n } else {\ntsize_t offset = dir->tdir_offset + cc;\nif ((tsize_t)dir->tdir_offset != offset - cc\n|| offset > (tsize_t)tif->tif_size)\n goto bad;\n _TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\n }\n }\n return (cc);\n bad:\nTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\"Error fetching data for field \\\"%s\\\"\",\n _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\nreturn (tsize_t) 0;\n }\n static tsize_t\n TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)", "fixed": " {\n int w = TIFFDataWidth((TIFFDataType) dir->tdir_type);\n tsize_t cc = dir->tdir_count * w;\n if (!isMapped(tif)) {\n if (!SeekOK(tif, dir->tdir_offset))\n goto bad;\n if (!ReadOK(tif, cp, cc))\n goto bad;\n } else {\nif (dir->tdir_offset + cc > tif->tif_size)\n goto bad;\n _TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\n }\n }\n return (cc);\n bad:\nTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error fetching data for field \\\"%s\\\"\",\n _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\nreturn ((tsize_t) 0);\n }\n static tsize_t\n TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)"}
{"scenario": "php-bug-2012-03-04-bda5ea7111-60dfd64bf2.tar.gz", "repairActions": ["Adds Method Call", "Changes Condition", "Adds Variable", "Adds Method"], "lines": 17, "problem": " ce->traits[ce->num_traits++] = trait;\n }\n }\n static int zend_traits_merge_functions(zend_function *fn TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)\n {\n size_t current;\n }\n if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {\n if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\nif (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\nif (   !zend_do_perform_implementation_check(fn, other_trait_fn TSRMLS_CC)\n|| !zend_do_perform_implementation_check(other_trait_fn, fn TSRMLS_CC)) {\n zend_get_function_declaration(fn TSRMLS_CC),\n zend_get_function_declaration(other_trait_fn TSRMLS_CC));\n }\n} else {\ndo_inheritance_check_on_method(fn, other_trait_fn TSRMLS_CC);\n}\n zend_function_dtor(other_trait_fn);\n zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n } else {\n if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\ndo_inheritance_check_on_method(other_trait_fn, fn TSRMLS_CC);\n abstract_solved = 1;\n } else {\n collision++;", "fixed": " ce->traits[ce->num_traits++] = trait;\n }\n }\nstatic zend_bool zend_traits_method_compatibility_check(zend_function *fn, zend_function *other_fn TSRMLS_DC)\n{\nzend_uint    fn_flags = fn->common.scope->ce_flags;\nzend_uint other_flags = other_fn->common.scope->ce_flags;\nreturn zend_do_perform_implementation_check(fn, other_fn TSRMLS_CC)\n&& zend_do_perform_implementation_check(other_fn, fn TSRMLS_CC)\n&& ((fn_flags & ZEND_ACC_FINAL) == (other_flags & ZEND_ACC_FINAL))\n&& ((fn_flags & ZEND_ACC_STATIC)== (other_flags & ZEND_ACC_STATIC));\n}\n static int zend_traits_merge_functions(zend_function *fn TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)\n {\n size_t current;\n }\n if (zend_hash_quick_find(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h, (void **)&other_trait_fn) == SUCCESS) {\n if (other_trait_fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\nif (!zend_traits_method_compatibility_check(fn, other_trait_fn TSRMLS_CC)) {\nzend_error(E_COMPILE_ERROR, \"Declaration of %s must be compatible with %s\",\n zend_get_function_declaration(fn TSRMLS_CC),\n zend_get_function_declaration(other_trait_fn TSRMLS_CC));\n }\n zend_function_dtor(other_trait_fn);\n zend_hash_quick_del(function_tables[i], hash_key->arKey, hash_key->nKeyLength, hash_key->h);\n } else {\n if (fn->common.fn_flags & ZEND_ACC_ABSTRACT) {\nif (!zend_traits_method_compatibility_check(fn, other_trait_fn TSRMLS_CC)) {\nzend_error(E_COMPILE_ERROR, \"Declaration of %s must be compatible with %s\",\nzend_get_function_declaration(fn TSRMLS_CC),\nzend_get_function_declaration(other_trait_fn TSRMLS_CC));\n}\n abstract_solved = 1;\n } else {\n collision++;"}
{"scenario": "valgrind-bug-12474-12473.tar.gz", "repairActions": ["Adds Method Call", "Adds Variable"], "lines": 22, "problem": " static void drd_report_race(const Addr addr, const SizeT size,\n const BmAccessTypeT access_type)\n {\nThreadId vg_tid;\nvg_tid = VG_(get_running_tid)();\nif (DRD_(thread_address_on_any_stack)(addr)) {\nGenericErrInfo GEI = {\n.tid = DRD_(thread_get_running_tid)(),\n.addr = addr,\n};\nVG_(maybe_record_error)(vg_tid, GenericErr, VG_(get_IP)(vg_tid),\n\"--check-stack-var=no skips checking stack\"\n\" variables shared over threads\",\n&GEI);\n} else {\nDataRaceErrInfo drei = {\n.tid  = DRD_(thread_get_running_tid)(),\n.addr = addr,\n.size = size,\n.access_type = access_type,\n};\nVG_(maybe_record_error)(vg_tid, DataRaceErr, VG_(get_IP)(vg_tid),\n\"Conflicting access\", &drei);\n if (s_first_race_only)\n DRD_(start_suppression)(addr, addr + size, \"first race only\");\n }\n }", "fixed": " static void drd_report_race(const Addr addr, const SizeT size,\n const BmAccessTypeT access_type)\n {\nDataRaceErrInfo drei;\ndrei.tid  = DRD_(thread_get_running_tid)();\ndrei.addr = addr;\ndrei.size = size;\ndrei.access_type = access_type;\nVG_(maybe_record_error)(VG_(get_running_tid)(),\nDataRaceErr,\nVG_(get_IP)(VG_(get_running_tid)()),\n\"Conflicting access\",\n&drei);\n if (s_first_race_only)\n{\n DRD_(start_suppression)(addr, addr + size, \"first race only\");\n }\n }"}
{"scenario": "valgrind-bug-11620-11619.tar.gz", "repairActions": ["Adds Method Call", "Adds Variable"], "lines": 15, "problem": " static WordSetU* univ_tsets = NULL; \n static WordSetU* univ_lsets = NULL; \n static WordSetU* univ_laog  = NULL; \n \n \n \n map_locks = VG_(newFM)( HG_(zalloc), \"hg.ids.2\", HG_(free),\n NULL);\n tl_assert(map_locks != NULL);\n tl_assert(univ_tsets == NULL);\n univ_tsets = HG_(newWordSetU)( HG_(zalloc), \"hg.ids.3\", HG_(free),\n 8 );\n tl_assert(thr->coretid != VG_INVALID_THREADID);\n map_threads[thr->coretid] = thr;\n tl_assert(VG_INVALID_THREADID == 0);\n all__sanity_check(\"initialise_data_structures\");\n }\n static Thread* map_threads_maybe_lookup ( ThreadId coretid )\n all_except_Locks__sanity_check(who);\n locks__sanity_check(who);\n }", "fixed": " static WordSetU* univ_tsets = NULL; \n static WordSetU* univ_lsets = NULL; \n static WordSetU* univ_laog  = NULL; \nstatic Int   __bus_lock = 0;\nstatic Lock* __bus_lock_Lock = NULL;\n \n \n \n map_locks = VG_(newFM)( HG_(zalloc), \"hg.ids.2\", HG_(free),\n NULL);\n tl_assert(map_locks != NULL);\n__bus_lock_Lock = mk_LockN( LK_nonRec, (Addr)&__bus_lock );\ntl_assert(HG_(is_sane_LockN)(__bus_lock_Lock));\nVG_(addToFM)( map_locks, (Word)&__bus_lock, (Word)__bus_lock_Lock );\n tl_assert(univ_tsets == NULL);\n univ_tsets = HG_(newWordSetU)( HG_(zalloc), \"hg.ids.3\", HG_(free),\n 8 );\n tl_assert(thr->coretid != VG_INVALID_THREADID);\n map_threads[thr->coretid] = thr;\n tl_assert(VG_INVALID_THREADID == 0);\ntl_assert( sizeof(__bus_lock) == 4 );\n all__sanity_check(\"initialise_data_structures\");\n }\n static Thread* map_threads_maybe_lookup ( ThreadId coretid )\n all_except_Locks__sanity_check(who);\n locks__sanity_check(who);\n }"}
{"scenario": "libtiff-bug-2008-09-05-d59e7df-5f42dba.tar.gz", "repairActions": ["Changes Type"], "lines": 6, "problem": " static int\n cpStrips(TIFF* in, TIFF* out)\n {\ntsize_t bufsize  = TIFFStripSize(in);\n unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n if (buf) {\n tstrip_t s, ns = TIFFNumberOfStrips(in);\nuint32 *bytecounts;\n TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n for (s = 0; s < ns; s++) {\nif (bytecounts[s] > (uint32)bufsize) {\n buf = (unsigned char *)_TIFFrealloc(buf, bytecounts[s]);\n if (!buf)\n return (0);\n static int\n cpTiles(TIFF* in, TIFF* out)\n {\ntsize_t bufsize = TIFFTileSize(in);\n unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n if (buf) {\n ttile_t t, nt = TIFFNumberOfTiles(in);\nuint32 *bytecounts;\n TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);\n for (t = 0; t < nt; t++) {\nif (bytecounts[t] > (uint32) bufsize) {\n buf = (unsigned char *)_TIFFrealloc(buf, bytecounts[t]);\n if (!buf)\n return (0);", "fixed": " static int\n cpStrips(TIFF* in, TIFF* out)\n {\ntmsize_t bufsize  = TIFFStripSize(in);\n unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n if (buf) {\n tstrip_t s, ns = TIFFNumberOfStrips(in);\nuint64 *bytecounts;\n TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n for (s = 0; s < ns; s++) {\nif (bytecounts[s] > (uint64)bufsize) {\n buf = (unsigned char *)_TIFFrealloc(buf, bytecounts[s]);\n if (!buf)\n return (0);\n static int\n cpTiles(TIFF* in, TIFF* out)\n {\ntmsize_t bufsize = TIFFTileSize(in);\n unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n if (buf) {\n ttile_t t, nt = TIFFNumberOfTiles(in);\nuint64 *bytecounts;\n TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);\n for (t = 0; t < nt; t++) {\nif (bytecounts[t] > (uint64) bufsize) {\n buf = (unsigned char *)_TIFFrealloc(buf, bytecounts[t]);\n if (!buf)\n return (0);"}
{"scenario": "php-bug-2012-03-10-23e65a9dcc-e6ec1fb166.tar.gz", "repairActions": ["Changes Method Call Args", "Changes Condition", "Adds Variable"], "lines": 10, "problem": " }\n switch(Z_TYPE_P(offset)) {\n case IS_STRING:\nif (check_empty) {\nif (zend_symtable_find(spl_array_get_hash_table(intern, 0 TSRMLS_CC), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {\n switch (check_empty) {\n case 0:\n return Z_TYPE_PP(tmp) != IS_NULL;\n return zend_is_true(*tmp);\n }\n }\nreturn 0;\n} else {\nreturn zend_symtable_exists(spl_array_get_hash_table(intern, 0 TSRMLS_CC), Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);\n }\n case IS_DOUBLE:\n case IS_RESOURCE:\n case IS_BOOL:\n case IS_LONG:\n if (offset->type == IS_DOUBLE) {\n index = (long)Z_DVAL_P(offset);\n } else {\n index = Z_LVAL_P(offset);\n }\nif (check_empty) {\nHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n if (zend_hash_index_find(ht, index, (void **)&tmp) != FAILURE) {\n switch (check_empty) {\n case 0:\n }\n }\n return 0;\n} else {\nreturn zend_hash_index_exists(spl_array_get_hash_table(intern, 0 TSRMLS_CC), index);\n }\n default:\n zend_error(E_WARNING, \"Illegal offset type\");", "fixed": " }\n switch(Z_TYPE_P(offset)) {\n case IS_STRING:\n{\nHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\nif (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {\n switch (check_empty) {\n case 0:\n return Z_TYPE_PP(tmp) != IS_NULL;\n return zend_is_true(*tmp);\n }\n }\n }\nreturn 0;\n case IS_DOUBLE:\n case IS_RESOURCE:\n case IS_BOOL:\n case IS_LONG:\n{\nHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n if (offset->type == IS_DOUBLE) {\n index = (long)Z_DVAL_P(offset);\n } else {\n index = Z_LVAL_P(offset);\n }\n if (zend_hash_index_find(ht, index, (void **)&tmp) != FAILURE) {\n switch (check_empty) {\n case 0:\n }\n }\n return 0;\n }\n default:\n zend_error(E_WARNING, \"Illegal offset type\");"}
{"scenario": "php-bug-2011-02-11-f912a2d087-b84967d3e2.tar.gz", "repairActions": ["Adds If Statement"], "lines": 2, "problem": " INIT_PZVAL(ptr);\n Z_TYPE_P(ptr) = IS_STRING;\n if (Z_LVAL_P(dim) < 0 || Z_STRLEN_P(container) <= Z_LVAL_P(dim)) {\n zend_error(E_NOTICE, \"Uninitialized string offset: %ld\", Z_LVAL_P(dim));\n Z_STRVAL_P(ptr) = STR_EMPTY_ALLOC();\n Z_STRLEN_P(ptr) = 0;\n } else {", "fixed": " INIT_PZVAL(ptr);\n Z_TYPE_P(ptr) = IS_STRING;\n if (Z_LVAL_P(dim) < 0 || Z_STRLEN_P(container) <= Z_LVAL_P(dim)) {\nif (type != BP_VAR_IS) {\n zend_error(E_NOTICE, \"Uninitialized string offset: %ld\", Z_LVAL_P(dim));\n}\n Z_STRVAL_P(ptr) = STR_EMPTY_ALLOC();\n Z_STRLEN_P(ptr) = 0;\n } else {"}
{"scenario": "php-bug-2011-04-06-187eb235fe-2e25ec9eb7.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 4, "problem": " } else {\n retval = &EG(uninitialized_zval_ptr);\n }\n zval_ptr_dtor(&object);\n } else {\n if (zobj->ce->__get && guard && guard->in_get == 1) {\n if (Z_STRVAL_P(member)[0] == '\\0') {", "fixed": " } else {\n retval = &EG(uninitialized_zval_ptr);\n }\nif (EXPECTED(*retval != object)) {\n zval_ptr_dtor(&object);\n} else {\nZ_DELREF_P(object);\n}\n } else {\n if (zobj->ce->__get && guard && guard->in_get == 1) {\n if (Z_STRVAL_P(member)[0] == '\\0') {"}
{"scenario": "python-bug-69223-69224.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement"], "lines": 5, "problem": " \"timeout period too long\");\n return NULL;\n }\n seconds = (long)timeout;\n timeout = timeout - (double)seconds;\n tv.tv_sec = seconds;", "fixed": " \"timeout period too long\");\n return NULL;\n }\nif (timeout < 0) {\nPyErr_SetString(PyExc_ValueError,\n\"timeout must be non-negative\");\nreturn NULL;\n}\n seconds = (long)timeout;\n timeout = timeout - (double)seconds;\n tv.tv_sec = seconds;"}
{"scenario": "libtiff-bug-2009-02-05-764dbba-2e42d63.tar.gz", "repairActions": ["Adds Method Call"], "lines": 1, "problem": " TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length);\n TIFFGetField(in, TIFFTAG_XRESOLUTION, &xres);\n TIFFGetField(in, TIFFTAG_YRESOLUTION, &yres);\nTIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit);\n scanlinesize = TIFFScanlineSize(in);\n image->bps = bps;\n image->spp = spp;", "fixed": " TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length);\n TIFFGetField(in, TIFFTAG_XRESOLUTION, &xres);\n TIFFGetField(in, TIFFTAG_YRESOLUTION, &yres);\nTIFFGetField(in, TIFFTAG_RESOLUTIONUNIT, &res_unit);\n scanlinesize = TIFFScanlineSize(in);\n image->bps = bps;\n image->spp = spp;"}
{"scenario": "php-bug-2012-03-08-d54e6ce832-23e65a9dcc.tar.gz", "repairActions": ["Adds Method Call", "Adds If Statement", "Adds Variable", "Adds Method"], "lines": 21, "problem": " }\n std_object_handlers.unset_property(object, member, key TSRMLS_CC);\n }\n static int spl_array_skip_protected(spl_array_object *intern, HashTable *aht TSRMLS_DC)\n {\n char *string_key;\n spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n spl_handler_ArrayObject.has_property = spl_array_has_property;\n spl_handler_ArrayObject.unset_property = spl_array_unset_property;\n REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);", "fixed": " }\n std_object_handlers.unset_property(object, member, key TSRMLS_CC);\n }\nstatic int spl_array_compare_objects(zval *o1, zval *o2 TSRMLS_DC)\n{\nHashTable\t\t\t*ht1,\n*ht2;\nspl_array_object\t*intern1,\n*intern2;\nint\t\t\t\t\tresult\t= 0;\nzval\t\t\t\ttemp_zv;\nintern1\t= (spl_array_object*)zend_object_store_get_object(o1 TSRMLS_CC);\nintern2\t= (spl_array_object*)zend_object_store_get_object(o2 TSRMLS_CC);\nht1\t\t= spl_array_get_hash_table(intern1, 0 TSRMLS_CC);\nht2\t\t= spl_array_get_hash_table(intern2, 0 TSRMLS_CC);\nzend_compare_symbol_tables(&temp_zv, ht1, ht2 TSRMLS_CC);\nresult = (int)Z_LVAL(temp_zv);\nif (result == 0 &&\n!(ht1 == intern1->std.properties && ht2 == intern2->std.properties)) {\nresult = std_object_handlers.compare_objects(o1, o2 TSRMLS_CC);\n}\nreturn result;\n}\n static int spl_array_skip_protected(spl_array_object *intern, HashTable *aht TSRMLS_DC)\n {\n char *string_key;\n spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n spl_handler_ArrayObject.has_property = spl_array_has_property;\n spl_handler_ArrayObject.unset_property = spl_array_unset_property;\nspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);"}
{"scenario": "php-bug-2012-01-17-032d140fd6-877f97cde1.tar.gz", "repairActions": ["Adds Method Call"], "lines": 5, "problem": " if (CG(active_class_entry)\n && (ZEND_ACC_TRAIT ==\n (CG(active_class_entry)->ce_flags & ZEND_ACC_TRAIT))) {\nzendlval->value.lval = ZEND_ACC_TRAIT;\nzendlval->type = IS_NULL;\n } else {\n if (CG(active_class_entry)) {\n class_name = CG(active_class_entry)->name;", "fixed": " if (CG(active_class_entry)\n && (ZEND_ACC_TRAIT ==\n (CG(active_class_entry)->ce_flags & ZEND_ACC_TRAIT))) {\nzendlval->value.str.len = sizeof(\"__CLASS__\")-1;\nzendlval->value.str.val = estrndup(\"__CLASS__\", zendlval->value.str.len);\nzendlval->type = IS_CONSTANT;\n } else {\n if (CG(active_class_entry)) {\n class_name = CG(active_class_entry)->name;"}
{"scenario": "fbc-bug-5458-5459.tar.gz", "repairActions": ["Changes Condition"], "lines": 2, "problem": " }\n src_len = FB_STRSIZE( src );\n dst_len = FB_STRSIZE( dst );\nif( (start > 0) && (start <= dst_len) )\n {\n --start;\nif( (len < 1) || (len > src_len) )\n len = src_len;\n if( start + len > dst_len )\n len = (dst_len - start);", "fixed": " }\n src_len = FB_STRSIZE( src );\n dst_len = FB_STRSIZE( dst );\nif( (start > 0) && (start <= dst_len) && (len != 0) )\n {\n --start;\nif( (len < 0) || (len > src_len) )\n len = src_len;\n if( start + len > dst_len )\n len = (dst_len - start);"}
{"scenario": "php-bug-2012-02-18-0a91432828-032bbc3164.tar.gz", "repairActions": [], "lines": 3, "problem": " {\n sapi_header_line ctr = {0};\n ctr.response_code = 403;\nctr.line_len = sizeof(\"HTTP/1.0 403 Access Denied\");\n ctr.line = \"HTTP/1.0 403 Access Denied\";\n sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n sapi_send_headers(TSRMLS_C);\n }\n }\n ctr.response_code = 404;\nctr.line_len = sizeof(\"HTTP/1.0 404 Not Found\")+1;\n ctr.line = \"HTTP/1.0 404 Not Found\";\n sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n sapi_send_headers(TSRMLS_C);\n char *tmp = NULL, sa = '\\0';\n sapi_header_line ctr = {0};\n ctr.response_code = 301;\nctr.line_len = sizeof(\"HTTP/1.1 301 Moved Permanently\")+1;\n ctr.line = \"HTTP/1.1 301 Moved Permanently\";\n sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n if (not_cgi) {", "fixed": " {\n sapi_header_line ctr = {0};\n ctr.response_code = 403;\nctr.line_len = sizeof(\"HTTP/1.0 403 Access Denied\")-1;\n ctr.line = \"HTTP/1.0 403 Access Denied\";\n sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n sapi_send_headers(TSRMLS_C);\n }\n }\n ctr.response_code = 404;\nctr.line_len = sizeof(\"HTTP/1.0 404 Not Found\")-1;\n ctr.line = \"HTTP/1.0 404 Not Found\";\n sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n sapi_send_headers(TSRMLS_C);\n char *tmp = NULL, sa = '\\0';\n sapi_header_line ctr = {0};\n ctr.response_code = 301;\nctr.line_len = sizeof(\"HTTP/1.1 301 Moved Permanently\")-1;\n ctr.line = \"HTTP/1.1 301 Moved Permanently\";\n sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);\n if (not_cgi) {"}
