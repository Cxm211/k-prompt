{"project": "Closure", "bugId": 60, "problem": " static TernaryValue getImpureBooleanValue(Node n) {\n         return TernaryValue.TRUE;\n       default:\n         return getPureBooleanValue(n);", "fixed": " static TernaryValue getImpureBooleanValue(Node n) {\n         return TernaryValue.TRUE;\n      case Token.VOID:\n        return TernaryValue.FALSE;\n       default:\n         return getPureBooleanValue(n);", "observations": "", "repairActions": ["condBranCaseAdd", "condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIf"]}
{"project": "Math", "bugId": 94, "problem": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Lang", "bugId": 12, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n         if (start == 0 && end == 0) {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n         if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n                 double lmNorm = 0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n            zone = timeZone;\n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Closure", "bugId": 47, "problem": " public void addMapping(\n     generator.addMapping(\n         sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }", "fixed": " public void addMapping(\n    int lineBaseOffset = 1;\n    if (generator instanceof SourceMapGeneratorV1\n        || generator instanceof SourceMapGeneratorV2) {\n      lineBaseOffset = 0;\n    }\n     generator.addMapping(\n         sourceFile, originalName,\n        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcParValChange", "objInstMod", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "initFix"]}
{"project": "Closure", "bugId": 108, "problem": " private void findAliases(NodeTraversal t) {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n           }", "fixed": " private void findAliases(NodeTraversal t) {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n            injectedDecls.add(newDecl.getFirstChild());\n           }", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Closure", "bugId": 93, "problem": " void replace() {\n         } else {\n          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "fixed": " void replace() {\n         } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "observations": "Same change/commit as #92.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 15, "problem": " public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r", "fixed": " public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n                        }\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r", "observations": "Instantiated a BeanPropertySetter object", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Lang", "bugId": 49, "problem": " public double doubleValue() {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;", "fixed": " public double doubleValue() {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;", "observations": "", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeMultiply(RealVector v) {\n     public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v[iter.key()]);", "fixed": " public OpenMapRealVector ebeMultiply(RealVector v) {\n     public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v[iter.key()]);", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Closure", "bugId": 65, "problem": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "fixed": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\000\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Lang", "bugId": 58, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {", "observations": "", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod"]}
{"project": "Mockito", "bugId": 19, "problem": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "fixed": " public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 66, "problem": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "fixed": " public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 133, "problem": " private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n     return result;\n   }", "fixed": " private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n     return result;\n   }", "observations": "It seems that the variable is reseted by method.", "repairActions": ["assignAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n             incrementIterationsCounter();", "fixed": " protected VectorialPointValuePair doOptimize()\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n            for (int i=0;i<rows;i++) {\n                qtf[i]=residuals[i];\n            }\n             incrementIterationsCounter();", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Chart", "bugId": 15, "problem": " public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r", "fixed": " public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n        if (this.dataset == null) {\r\n            return 0.0;\r\n        }\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "missNullCheckP", "wrapsIf"]}
{"project": "Mockito", "bugId": 30, "problem": " public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n    public void smartNullPointerException(Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"", "fixed": " public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n    public void smartNullPointerException(Object obj, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n                obj,\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"", "observations": "Adds new parameter to method signature, ajust code.", "repairActions": ["mcParAdd", "mcRepl", "mdParAdd", "objInstMod"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Mockito", "bugId": 4, "problem": " public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));", "fixed": " public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Math", "bugId": 47, "problem": " public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n     }\n     ", "fixed": " public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n        isZero = real == 0 && imaginary == 0;\n     }\n     ", "observations": "The \"WrapWith\" condition is in the form \"exp?a:b\". The added variable is a class attribute.", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "retExpChange", "varAdd"], "repairPatterns": ["copyPaste", "expLogicMod", "wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 40, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n          }\n         }\n       }\n     }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n         }\n       }\n     }", "observations": "Removed a null check, maintaining the branch code.", "repairActions": ["condBranRem", "mcParValChange"], "repairPatterns": ["constChange", "unwrapIfElse"]}
{"project": "Math", "bugId": 61, "problem": " public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));", "fixed": " public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));", "observations": "Replaces Exception Thrown. Changed the type of exception thrown. Changed the imported type.", "repairActions": ["mcRem", "objInstAdd"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Chart", "bugId": 9, "problem": " public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\nendIndex = -(endIndex + 1);\nendIndex = endIndex - 1;\n         }\r\n        if (endIndex < 0) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r", "fixed": " public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\nendIndex = -(endIndex + 1);\nendIndex = endIndex - 1;\n         }\r\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 100, "problem": " public double getChiSquare(EstimationProblem problem) {\n         final int rows = problem.getMeasurements().length;\n        final int cols = problem.getAllParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {", "fixed": " public double getChiSquare(EstimationProblem problem) {\n         final int rows = problem.getMeasurements().length;\n        final int cols = problem.getUnboundParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {", "observations": "Apply the same replace of methods in three different places.", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 81, "problem": " Node processFunctionNode(FunctionNode functionNode) {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;", "fixed": " Node processFunctionNode(FunctionNode functionNode) {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Lang", "bugId": 62, "problem": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "fixed": " public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n                            if (entityValue > 0xFFFF) {\n                                entityValue = -1;\n                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }", "observations": "Added a \"break\" in \"case\" branch.", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Lang", "bugId": 65, "problem": " private static void modify(Calendar val, int field, boolean round) {\n                 roundUp = offset > ((max - min) / 2);\n             }\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");", "fixed": " private static void modify(Calendar val, int field, boolean round) {\n                 roundUp = offset > ((max - min) / 2);\n             }\n            if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "wrapsIf"]}
{"project": "Chart", "bugId": 12, "problem": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        this.dataset = dataset;\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "fixed": " public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n        setDataset(dataset);\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r", "observations": "It involves a \"wrap with method\", but the real change is converting from a class attribute assignment to a \"set\" method call.", "repairActions": ["assignRem", "mcAdd", "varReplMc"], "repairPatterns": ["singleLine", "wrapsMethod", "wrongVarRef"]}
{"project": "Chart", "bugId": 13, "problem": " protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n         h[3] = h[2];\r\n         if (this.rightBlock != null) {\r\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                     LengthConstraintType.RANGE, h[2], null,\r\n                     LengthConstraintType.FIXED);\r\n             Size2D size = this.rightBlock.arrange(g2, c4);\r", "fixed": " protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n         h[3] = h[2];\r\n         if (this.rightBlock != null) {\r\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\r\n                     LengthConstraintType.RANGE, h[2], null,\r\n                     LengthConstraintType.FIXED);\r\n             Size2D size = this.rightBlock.arrange(g2, c4);\r", "observations": "", "repairActions": ["assignExpChange", "mcAdd", "mcParAdd", "mcParValChange", "mcRepl", "objInstMod"], "repairPatterns": ["initFix", "missComp", "singleLine", "wrapsMethod", "wrongMethodRef"]}
{"project": "Closure", "bugId": 99, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;", "observations": "Changed condition in expression, adds an extra computing in line 131.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "expLogicMod", "wrapsIf"]}
{"project": "Chart", "bugId": 4, "problem": " public Range getDataRange(ValueAxis axis) {\n                             includedAnnotations.add(a);\r\n                         }\r\n                     }\r\n             }\r\n         }\r", "fixed": " public Range getDataRange(ValueAxis axis) {\n                             includedAnnotations.add(a);\r\n                         }\r\n                     }\r\n                }\r\n             }\r\n         }\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Math", "bugId": 15, "problem": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }", "fixed": " public static double pow(double x, double y) {\n         \n         if (x < 0) {\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;", "fixed": " public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Math", "bugId": 3, "problem": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "fixed": " public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Mockito", "bugId": 2, "problem": " public void start() {\n         startTime = System.currentTimeMillis();\n     }\n }", "fixed": " public void start() {\n         startTime = System.currentTimeMillis();\n     }\n    private void validateInput(long durationMillis) {\n        if (durationMillis < 0) {\n            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n        }\n    }\n }", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 93, "problem": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "fixed": " public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );", "fixed": " public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 37, "problem": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "fixed": " public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Math", "bugId": 62, "problem": " public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, 0);\n     }\n     ", "fixed": " public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n     }\n     ", "observations": "Changes the way to compute \"optima[i]\", changing params for call to \"optimize\". Removed if-branch is in the form \"exp?a:b\".", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcAdd", "mcParAdd", "mcParValChange", "mcRem", "mcRepl", "retExpChange", "varAdd", "varRem"], "repairPatterns": ["expArithMod", "wrongComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 13, "problem": " private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n        traverse(c);\n         Node next = c.getNext();\n         c = next;\n       }", "fixed": " private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         Node next = c.getNext();\n        traverse(c);\n         c = next;\n       }", "observations": "Only one line of code was moved.", "repairActions": ["mcMove"], "repairPatterns": ["codeMove", "singleLine"]}
{"project": "Closure", "bugId": 110, "problem": " public Node getChildBefore(Node child) {\n       return null;\n     }\n     Node n = first;\n     while (n.next != child) {\n       n = n.next;", "fixed": " public Node getChildBefore(Node child) {\n       return null;\n     }\n     Node n = first;\n    if (n == null) {\n      throw new RuntimeException(\"node is not a child\");\n    }\n     while (n.next != child) {\n       n = n.next;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 96, "problem": " public boolean equals(Object other) {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {", "fixed": " public boolean equals(Object other) {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                 }\n             } catch (ClassCastException ex) {", "observations": "Changes logical expression in assignment", "repairActions": ["assignExpChange", "mcRem"], "repairPatterns": ["expLogicMod", "singleLine", "unwrapMethod"]}
{"project": "Closure", "bugId": 23, "problem": " private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n     Node current = left.getFirstChild();\n     Node elem = null;\n    for (int i = 0; current != null && i < intIndex; i++) {\n         elem = current;\n       current = current.getNext();\n     }", "fixed": " private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n     Node current = left.getFirstChild();\n     Node elem = null;\n    for (int i = 0; current != null; i++) {\n      if (i != intIndex) {\n        if (mayHaveSideEffects(current)) {\n          return n;\n        }\n      } else {\n         elem = current;\n      }\n       current = current.getNext();\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopCondChange", "mcAdd", "retBranchAdd"], "repairPatterns": ["expLogicReduce", "wrapsIfElse"]}
{"project": "Chart", "bugId": 22, "problem": " public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n                rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r", "fixed": " public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n            int i = rowData.getIndex(columnKey);\r\n            if (i >= 0) {\r\n                rowData.removeValue(i);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 92, "problem": " void replace() {\n         } else {\n          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "fixed": " void replace() {\n         } else {\n          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             compiler.getNodeForCodeInsertion(minimumModule)", "observations": "", "repairActions": ["assignExpChange", "mcRepl"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Closure", "bugId": 64, "problem": " public Void call() throws Exception {\n        String code = toSource(root, sourceMap);\n         if (!code.isEmpty()) {\n           cb.append(code);", "fixed": " public Void call() throws Exception {\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n         if (!code.isEmpty()) {\n           cb.append(code);", "observations": "New parameters are added in three method calls (call to overloaded methods). A logic expression passed to a method call is changed.", "repairActions": ["mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Closure", "bugId": 19, "problem": " protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +", "fixed": " protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n      case Token.THIS:\n        break;\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +", "observations": "", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 75, "problem": " public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n     }\n     /**", "fixed": " public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n        return getPct((Comparable<?>) v);\n     }\n     /**", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }", "fixed": " private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                     fu = -fu;\n                 }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 120, "problem": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n           break;\n         } else if (block.isLoop) {\n           return false;", "fixed": " boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n           break;\n         } else if (block.isLoop) {\n           return false;", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 67, "problem": " public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n     \n     public double getFunctionValue() {\n        return optimizer.getFunctionValue();\n     }\n     \n     public double getResult() {\n        return optimizer.getResult();\n     }\n     ", "fixed": " public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n     \n     public double getFunctionValue() {\n        return optimaValues[0];\n     }\n     \n     public double getResult() {\n        return optima[0];\n     }\n     ", "observations": "A direct access to a vector was added in place of a value returned from a call to an object method. The change was similar in structure in two different places.", "repairActions": ["mcRem", "retExpChange"], "repairPatterns": ["wrongMethodRef"]}
{"project": "Math", "bugId": 42, "problem": " protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n          if (basicRows.contains(basicRow)) {\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);", "fixed": " protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);", "observations": "", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckN", "wrapsIfElse", "wrongComp"]}
{"project": "Math", "bugId": 10, "problem": " public void atan2(final double[] y, final int yOffset,\n         }\n     }", "fixed": " public void atan2(final double[] y, final int yOffset,\n         }\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n     }", "observations": "", "repairActions": ["assignAdd", "mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Closure", "bugId": 103, "problem": " public JSTypeSystem(AbstractCompiler compiler) {\n       }\n       return foundType;\n     }", "fixed": " public JSTypeSystem(AbstractCompiler compiler) {\n       }\n      if (foundType == null) {\n        ObjectType maybeType = ObjectType.cast(\n            registry.getGreatestSubtypeWithProperty(type, field));\n        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n          foundType = maybeType;\n        }\n      }\n       return foundType;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN", "missNullCheckP"]}
{"project": "Math", "bugId": 76, "problem": " public RealMatrix getV()\n                 final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n                }\n                         for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }", "fixed": " public RealMatrix getV()\n                 final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n                    } else {\n                         for (int j = 0; j < p; ++j) {\n                            wi[j] = mi * ei0[j] / singularValues[j];\n                         }\n                    }\n                }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }", "observations": "The structure of the changes are similar and applied in two different methods.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "loopCondChange", "mcParValChange", "varReplVar"], "repairPatterns": ["copyPaste", "expArithMod", "expLogicMod", "wrapsIfElse", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar) {\n           Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n               null;\n          Node varNode = parent;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "fixed": " private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n           Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n               null;\n          Node varNode = null;\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Closure", "bugId": 30, "problem": " boolean dependsOnOuterScopeVars(String name, Node useNode) {\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {", "fixed": " boolean dependsOnOuterScopeVars(String name, Node useNode) {\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    if (def.unknownDependencies) {\n      return true;\n    }\n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 8, "problem": " public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();", "fixed": " public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n        final Object[] out = new Object[sampleSize];\n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();", "observations": "Ajust the object initialization to reflect type changed.", "repairActions": ["mcRem", "mdRetTyChange", "varTyChange"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 53, "problem": " private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n       Node replacement;\n         nodes.add(new Node(Token.TRUE));", "fixed": " private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n       Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = new Node(Token.TRUE);\n      } else {\n         nodes.add(new Node(Token.TRUE));", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n            if (iter % n == 0 ||\n                 beta < 0) {\n                 searchDirection = steepestDescent.clone();", "fixed": " protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n            if (getIterations() % n == 0 ||\n                 beta < 0) {\n                 searchDirection = steepestDescent.clone();", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 24, "problem": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n        }\n       }\n     }", "fixed": " private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n        } else if (parent.getType() == Token.LP) {\n         } else {\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n       }\n     }", "observations": "Again, a kind of Wrap-with-IfElse where some conditionals were missing.", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Lang", "bugId": 19, "problem": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n             }\n             int end = start;\n            while(input.charAt(end) != ';') \n             {\n                 end++;\n             }", "fixed": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n                if(start == seqEnd) {\n                    return 0;\n                }\n             }\n             int end = start;\n            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n             {\n                 end++;\n             }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 19, "problem": " public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n     }\n }", "fixed": " public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n     }\n }", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Chart", "bugId": 18, "problem": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n        if (index < this.keys.size()) {\n         rebuildIndex();\n        }\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n\t\t\treturn;\n         }\n         removeValue(index);\n     }\n     ", "fixed": " private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n         rebuildIndex();\n     }\n     \n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n            throw new UnknownKeyException(\"The key (\" + key \n                    + \") is not recognised.\");\n         }\n         removeValue(index);\n     }\n     ", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Time", "bugId": 1, "problem": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +", "fixed": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                if (loopUnitField.isSupported() == false) {\n                    if (lastUnitField.isSupported()) {\n                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                        types[i - 1].getName() + \" < \" + loopType.getName());\n                    } else {\n                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n                                        types[i - 1].getName() + \" and \" + loopType.getName());\n                    }\n                }\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +", "observations": "", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "exThrowsAdd", "mcAdd", "objInstAdd", "retRem"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRem", "expLogicExpand"]}
{"project": "Closure", "bugId": 103, "problem": " private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n         return true;\n       case Token.FUNCTION:\n         return false;", "fixed": " private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n      case Token.INSTANCEOF:\n         return true;\n       case Token.FUNCTION:\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN", "missNullCheckP"]}
{"project": "Mockito", "bugId": 24, "problem": " public Object answer(InvocationOnMock invocation) {\n            return 1;\n         }\n         Class<?> returnType = invocation.getMethod().getReturnType();", "fixed": " public Object answer(InvocationOnMock invocation) {\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n         }\n         Class<?> returnType = invocation.getMethod().getReturnType();", "observations": "If-Else implicit in \"exp?x:y\" format", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Lang", "bugId": 45, "problem": " public static String abbreviate(String str, int lower, int upper, String appendT\n         if (upper == -1 || upper > str.length()) {", "fixed": " public static String abbreviate(String str, int lower, int upper, String appendT\n        if (lower > str.length()) {\n            lower = str.length();    \n        }\n         if (upper == -1 || upper > str.length()) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            if (searchChars.indexOf(ch) < 0) {\n                     return i;\n             }\n         }\n         return INDEX_NOT_FOUND;", "fixed": " public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n            boolean chFound = searchChars.indexOf(ch) >= 0;\n            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n                char ch2 = str.charAt(i + 1);\n                if (chFound && searchChars.indexOf(ch2) < 0) {\n                     return i;\n                }\n            } else {\n                if (!chFound) {\n                    return i;\n                }\n             }\n         }\n         return INDEX_NOT_FOUND;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 2, "problem": "     private long startTime = -1;\n     public Timer(long durationMillis) {\n         this.durationMillis = durationMillis;\n     }", "fixed": "     private long startTime = -1;\n     public Timer(long durationMillis) {\n        validateInput(durationMillis);\n         this.durationMillis = durationMillis;\n     }", "observations": "import and instantiate a new Reporter object. It appears as an validation object/procedure.", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Lang", "bugId": 65, "problem": " private static void modify(Calendar val, int field, boolean round) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }", "fixed": " private static void modify(Calendar val, int field, boolean round) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n        if (field == Calendar.MILLISECOND) {\n            return;\n        }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "wrapsIf"]}
{"project": "Chart", "bugId": 11, "problem": " public static boolean equal(GeneralPath p1, GeneralPath p2) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();", "fixed": " public static boolean equal(GeneralPath p1, GeneralPath p2) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();", "observations": "Replaces var referencing of target object of a call.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 62, "problem": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "fixed": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "observations": "Just changed the operator in \"if\" condition", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 6, "problem": " public int compare(final PointValuePair o1,\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n\t\t\t++iteration;\n         }\n     }", "fixed": " public int compare(final PointValuePair o1,\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n            incrementIterationCount();\n         }\n     }", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 33, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n    if (hasReferenceName()) {\n      return;\n    }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 108, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         JSDocInfo info = n.getJSDocInfo();\n        if (info != null && !injectedDecls.contains(n)) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Lang", "bugId": 51, "problem": " public static boolean toBoolean(String str) {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n             }\n             case 4: {\n                 char ch = str.charAt(0);", "fixed": " public static boolean toBoolean(String str) {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);", "observations": "Adds a return statement that does the role of an \"else\" branch.", "repairActions": ["retBranchAdd"], "repairPatterns": ["singleLine"]}
{"project": "Chart", "bugId": 15, "problem": " public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n         PiePlotState state = new PiePlotState(info);\r\n         state.setPassesRequired(2);\r\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\r\n                     plot.getDataset()));\r\n         state.setLatestAngle(plot.getStartAngle());\r\n         return state;\r", "fixed": " public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n         PiePlotState state = new PiePlotState(info);\r\n         state.setPassesRequired(2);\r\n        if (this.dataset != null) {\r\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\r\n                     plot.getDataset()));\r\n        }\r\n         state.setLatestAngle(plot.getStartAngle());\r\n         return state;\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "missNullCheckP", "wrapsIf"]}
{"project": "Lang", "bugId": 37, "problem": " public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n     }", "fixed": " public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n            }\nthrow ase;\n        }\n         return joinedArray;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "exTryCatchAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "wrapsTryCatch"]}
{"project": "Lang", "bugId": 62, "problem": " public void unescape(Writer writer, String string) throws IOException {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n                             } catch (NumberFormatException e) {\n                             }\n                         }\n} else {", "fixed": " public void unescape(Writer writer, String string) throws IOException {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n                                        break;\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n                                if (entityValue > 0xFFFF) {\n                                    entityValue = -1;\n                                }\n                             } catch (NumberFormatException e) {\n                                entityValue = -1;\n                             }\n                         }\n} else {", "observations": "Added a \"break\" in \"case\" branch.", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n        return reportMatcher(new InstanceOf(Long.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 54, "problem": " public double toDouble() {\n         Dfp y = this;\n         boolean negate = false;\n        if (lessThan(getZero())) {\n             y = negate();\n             negate = true;\n         }", "fixed": " public double toDouble() {\n         Dfp y = this;\n         boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n             y = negate();\n             negate = true;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "wrapsIfElse"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {", "fixed": " private void findAliases(NodeTraversal t) {\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Closure", "bugId": 108, "problem": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();", "fixed": " public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n    private final Set<Node> injectedDecls = Sets.newHashSet();", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                return new VectorialPointValuePair(point, objective);\n             }", "fixed": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                return current;\n             }", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Math", "bugId": 77, "problem": " public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n         }\n         return max;\n     }", "fixed": " public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }", "observations": "Fix a assignment. Removes a method (aparently, unrelated changes).", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcRem", "mdOverride", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Chart", "bugId": 5, "problem": " public XYDataItem addOrUpdate(Number x, Number y) {\n         if (x == null) {\r\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n         }\r\n         XYDataItem overwritten = null;\r\n         int index = indexOf(x);\r\n        if (index >= 0 && !this.allowDuplicateXValues) {\r\n             XYDataItem existing = (XYDataItem) this.data.get(index);\r\n             try {\r\n                 overwritten = (XYDataItem) existing.clone();\r", "fixed": " public XYDataItem addOrUpdate(Number x, Number y) {\n         if (x == null) {\r\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n         }\r\n        if (this.allowDuplicateXValues) {\r\n            add(x, y);\r\n            return null;\r\n        }\r\n         XYDataItem overwritten = null;\r\n         int index = indexOf(x);\r\n        if (index >= 0) {\r\n             XYDataItem existing = (XYDataItem) this.data.get(index);\r\n             try {\r\n                 overwritten = (XYDataItem) existing.clone();\r", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce"]}
{"project": "Math", "bugId": 81, "problem": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "fixed": " private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n                if (end - start > 3) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Lang", "bugId": 23, "problem": "  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";", "fixed": "  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n    private static final int HASH_SEED = 31;\n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";", "observations": "Implements equals and hascode to work with hash structures of Collections", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mdAdd", "mdOverride", "varAdd"], "repairPatterns": ["condBlockRetAdd", "fixAPI", "wrongComp"]}
{"project": "Math", "bugId": 12, "problem": "  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n    implements RandomGenerator {\n     \n     \n     private double nextGaussian;", "fixed": "  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n    implements RandomGenerator,\n               Serializable {\n     \n    private static final long serialVersionUID = 20130104L;\n     \n     private double nextGaussian;", "observations": "imports and implements java.io.Serializable.", "repairActions": ["assignAdd", "tyImpInterf", "varAdd"], "repairPatterns": ["notClassified"]}
{"project": "Chart", "bugId": 20, "problem": " public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        super(paint, stroke, paint, stroke, alpha);\r\n         this.value = value;\r\n     }\r", "fixed": " public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\r\n         this.value = value;\r\n     }\r", "observations": "Replaces params value passed to constructor.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Math", "bugId": 69, "problem": " public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }", "fixed": " public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         }", "observations": "Fix assignment operation.", "repairActions": ["assignExpChange", "mcParValChange"], "repairPatterns": ["expArithMod", "singleLine", "wrongComp"]}
{"project": "Closure", "bugId": 50, "problem": " private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();", "fixed": " private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n    if (right != null && right.getType() == Token.STRING\n        && \",\".equals(right.getString())) {\n      n.removeChild(right);\n      reportCodeChange();\n    }\n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missNullCheckN"]}
{"project": "Math", "bugId": 44, "problem": " protected double acceptStep(final AbstractStepInterpolator interpolator,\n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n            resetOccurred = false;\n             if (! statesInitialized) {", "fixed": " protected double acceptStep(final AbstractStepInterpolator interpolator,\n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n             if (! statesInitialized) {", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Closure", "bugId": 34, "problem": " void endCaseBody() {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n        if (getLastChar() != ' ') {\n           append(\" \");\n         }\n         append(op);", "fixed": " void endCaseBody() {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n           append(\" \");\n         }\n         append(op);", "observations": "", "repairActions": ["condExpExpand", "mcAdd", "mcParAdd", "mcRepl", "varReplVar"], "repairPatterns": ["expLogicExpand", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 98, "problem": " public double getTrace() throws IllegalArgumentException {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n        final double[] out = new double[v.length];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;", "fixed": " public double getTrace() throws IllegalArgumentException {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;", "observations": "Changes dimension of two vectors.", "repairActions": ["varReplVar"], "repairPatterns": ["copyPaste", "initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 3, "problem": " public void enterScope(NodeTraversal t) {\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n      if (c.canInline()) {\n         c.inlineVariable();", "fixed": " public void enterScope(NodeTraversal t) {\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n      if (c.canInline(t.getScope())) {\n         c.inlineVariable();", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "condExpMod", "mcAdd", "mcParAdd", "mcRepl", "mdParAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 18, "problem": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                     return false;\n                 }\n                if (x[i] > 1.0) {\n                     return false;\n                 }\n             }", "fixed": " public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n            final double[] bLoEnc = encode(boundaries[0]);\n            final double[] bHiEnc = encode(boundaries[1]);\n             for (int i = 0; i < x.length; i++) {\n                if (x[i] < bLoEnc[i]) {\n                     return false;\n                 }\n                if (x[i] > bHiEnc[i]) {\n                     return false;\n                 }\n             }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Mockito", "bugId": 34, "problem": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "fixed": " public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 86, "problem": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "fixed": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];", "observations": "The condition to throw the exception is moved from one place to another.", "repairActions": ["condBranIfAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "objInstAdd", "objInstRem"], "repairPatterns": ["codeMove"]}
{"project": "Closure", "bugId": 49, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n       case Token.FUNCTION:\n         nameStack.pop();\n         break;\n       case Token.CATCH:", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n       case Token.FUNCTION:\n        nameStack.pop();\n         nameStack.pop();\n         break;\n      case Token.LP:\n        break;\n       case Token.CATCH:", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranCaseAdd", "condBranRem", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Math", "bugId": 66, "problem": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "fixed": " public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 53, "problem": " public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }", "fixed": " public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 101, "problem": " protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n    if (flags.process_closure_primitives) {\n      options.closurePass = true;\n    }\n     initOptionsFromFlags(options);\n     return options;\n   }", "fixed": " protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n    options.closurePass = flags.process_closure_primitives;\n     initOptionsFromFlags(options);\n     return options;\n   }", "observations": "", "repairActions": ["assignExpChange", "condBranRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Chart", "bugId": 21, "problem": " public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r", "fixed": " public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n        else {\r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Time", "bugId": 4, "problem": " public Partial with(DateTimeFieldType fieldType, int value) {\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }", "fixed": " public Partial with(DateTimeFieldType fieldType, int value) {\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }", "observations": "The swap was made on a constructor call.", "repairActions": ["mcParSwap", "mcParValChange", "objInstMod", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static byte anyByte() {\n      * @return <code>0</code>.\r\n      */\r\n     public static char anyChar() {\r\n        return reportMatcher(Any.ANY).returnChar();\r\n     }\r\n     /**\r", "fixed": " public static byte anyByte() {\n      * @return <code>0</code>.\r\n      */\r\n     public static char anyChar() {\r\n        return reportMatcher(new InstanceOf(Character.class)).returnChar();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return \"{...}\";\n     }\n   }", "fixed": " String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n     }\n   }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Time", "bugId": 26, "problem": " public long set(long instant, String text, Locale locale) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false);\n         }\n         public int getDifference(long minuendInstant, long subtrahendInstant) {", "fixed": " public long set(long instant, String text, Locale locale) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n            return iZone.convertLocalToUTC(localInstant, false, instant);\n         }\n         public int getDifference(long minuendInstant, long subtrahendInstant) {", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(Any.ANY).returnFor(clazz);\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 30, "problem": " private void computeDependence(final Definition def, Node rValue) {\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n           Var dep = jsScope.getVar(n.getString());\n             def.depends.add(dep);\n         }\n       }\n     });", "fixed": " private void computeDependence(final Definition def, Node rValue) {\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName()) {\n           Var dep = jsScope.getVar(n.getString());\n          if (dep == null) {\n            def.unknownDependencies = true;\n          } else {\n             def.depends.add(dep);\n          }\n         }\n       }\n     });", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 2, "problem": " private double innerCumulativeProbability(int x0, int x1, int dx) {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n     /**", "fixed": " private double innerCumulativeProbability(int x0, int x1, int dx) {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n     }\n     /**", "observations": "Apply a casting to returned value of an expression.", "repairActions": ["retExpChange"], "repairPatterns": ["expArithMod", "singleLine"]}
{"project": "Mockito", "bugId": 36, "problem": " public int getArgumentsCount() {\n     }\n     public Object callRealMethod() throws Throwable {\n         return realMethod.invoke(mock, rawArguments);\n     }", "fixed": " public int getArgumentsCount() {\n     }\n     public Object callRealMethod() throws Throwable {\n        if (this.getMethod().getDeclaringClass().isInterface()) {\n            new Reporter().cannotCallRealMethodOnInterface();\n        }\n         return realMethod.invoke(mock, rawArguments);\n     }", "observations": "Instantiates an Reporter object", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(residuals);\n             for (int k = 0; k < solvedCols; ++k) {", "fixed": " protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n            qTy(qtf);\n             for (int k = 0; k < solvedCols; ++k) {", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 8, "problem": " public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));", "fixed": " public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n            TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Lang", "bugId": 19, "problem": "     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '\n             int start = index + 2;\n             boolean isHex = false;", "fixed": "     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '\n             int start = index + 2;\n             boolean isHex = false;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static List anyList() {\n      * @return empty List.\r\n      */\r\n     public static <T> List<T> anyListOf(Class<T> clazz) {\r\n        return (List) reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static List anyList() {\n      * @return empty List.\r\n      */\r\n     public static <T> List<T> anyListOf(Class<T> clazz) {\r\n        return anyList();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 26, "problem": " private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n      if (!modulesWithExports.contains(moduleName)) {\n        return;\n      }\n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 39, "problem": " String toStringHelper(boolean forAnnotations) {\n         sb.append(property);\n         sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n         ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }", "fixed": " String toStringHelper(boolean forAnnotations) {\n         sb.append(property);\n         sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n         ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }", "observations": "If-else implicit in \"exp?a:b\" construct", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["expLogicExpand", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Closure", "bugId": 72, "problem": " private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n      if (li.referenced) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {", "fixed": " private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n      if (li.referenced || !removeUnused) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {", "observations": "Instantiates an anonymous object and make a method call on it.", "repairActions": ["condExpExpand", "mcAdd", "objInstAdd"], "repairPatterns": ["expLogicExpand", "missComp"]}
{"project": "Math", "bugId": 49, "problem": " public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));", "fixed": " public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Mockito", "bugId": 23, "problem": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "fixed": " private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n         return mockSettings\r\n\t\t        .serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Math", "bugId": 54, "problem": " protected Dfp(final DfpField field, double x) {\n             if (x == 0) {\n                 return;\n             }", "fixed": " protected Dfp(final DfpField field, double x) {\n             if (x == 0) {\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                 return;\n             }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "wrapsIfElse"]}
{"project": "Closure", "bugId": 98, "problem": " Reference getInitializingReferenceForConstants() {\n     boolean isAssignedOnceInLifetime() {\n       Reference ref = getOneAndOnlyAssignment();\n       if (ref == null) {\n         return false;\n       }\n       return true;\n     }\n     ", "fixed": " Reference getInitializingReferenceForConstants() {\n     boolean isAssignedOnceInLifetime() {\n       Reference ref = getOneAndOnlyAssignment();\n       if (ref == null) {\n         return false;\n       }\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n       return true;\n     }\n     ", "observations": "New class attributes were added.", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN"]}
{"project": "Closure", "bugId": 73, "problem": " static String strEscape(String s, char quote,\n            if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {", "fixed": " static String strEscape(String s, char quote,\n            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {", "observations": "", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 25, "problem": " private FlowScope traverseNew(Node n, FlowScope scope) {\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n         }\n       }\n     }\n     n.setJSType(type);\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n     return scope;\n   }", "fixed": " private FlowScope traverseNew(Node n, FlowScope scope) {\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n          backwardsInferenceFromCallSite(n, ct);\n         }\n       }\n     }\n     n.setJSType(type);\n     return scope;\n   }", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcRem"], "repairPatterns": ["blockRemove", "notClassified"]}
{"project": "Time", "bugId": 10, "problem": " protected static int between(ReadablePartial start, ReadablePartial end, Readabl\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n         return values[0];\n     }", "fixed": " protected static int between(ReadablePartial start, ReadablePartial end, Readabl\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n         return values[0];\n     }", "observations": "Adds new variable and its initialization.", "repairActions": ["assignAdd", "mcParValChange", "varAdd"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Lang", "bugId": 55, "problem": " public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n             stopTime = System.currentTimeMillis();\n         this.runningState = STATE_STOPPED;\n     }", "fixed": " public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n        }\n         this.runningState = STATE_STOPPED;\n     }", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Lang", "bugId": 34, "problem": "      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n     }\n     /**", "fixed": "      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n        return m != null && m.containsKey(value);\n     }\n     /**", "observations": "", "repairActions": ["condBranRem", "mcRem", "retExpChange"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "unwrapIfElse"]}
{"project": "Closure", "bugId": 106, "problem": " public void markName(String name, int lineno, int charno) {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n    if (parseDocumentation) {\n     populated = true;\n    }\n     return currentInfo.documentBlock(description);\n   }", "fixed": " public void markName(String name, int lineno, int charno) {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n     populated = true;\n     return currentInfo.documentBlock(description);\n   }", "observations": "", "repairActions": ["condBranIfAdd", "condBranRem", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 38, "problem": " private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\nthrow new PathIsExploredException();\n             }\n         } while (getEvaluations() < npt);\n}", "fixed": " private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n             }\n         } while (getEvaluations() < npt);\n}", "observations": "Removes Exception Thrown. The throws line is commented in code... maybe the change isn't a final one.", "repairActions": ["assignExpChange", "exThrowsRem", "objInstRem"], "repairPatterns": ["copyPaste", "expArithMod", "initFix", "wrongComp"]}
{"project": "Closure", "bugId": 26, "problem": " private void visitModuleExports(Node prop) {\n       Node exports = prop.getChildAtIndex(1);\n       exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n       exports.setString(\"module$exports\");\n     }\n     /**", "fixed": " private void visitModuleExports(Node prop) {\n       Node exports = prop.getChildAtIndex(1);\n       exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n       exports.setString(\"module$exports\");\n      modulesWithExports.add(moduleName);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n           Node childVal = child.getFirstChild();", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n          validProperties.add(child.getString());\n           Node childVal = child.getFirstChild();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 38, "problem": " private void prelim(double[] lowerBound,\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\nthrow new PathIsExploredException();\n                 }\n                final int iptMinus1 = ipt;\n                final int jptMinus1 = jpt;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }", "fixed": " private void prelim(double[] lowerBound,\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n                 }\n                final int iptMinus1 = ipt - 1;\n                final int jptMinus1 = jpt - 1;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }", "observations": "Removes Exception Thrown. The throws line is commented in code... maybe the change isn't a final one.", "repairActions": ["assignExpChange", "exThrowsRem", "objInstRem"], "repairPatterns": ["copyPaste", "expArithMod", "initFix", "wrongComp"]}
{"project": "Lang", "bugId": 35, "problem": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            return (T[]) new Object[] { null };\n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "fixed": " private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n         }\n@SuppressWarnings(\"unchecked\")\n         final T[] newArray = (T[]) add(array, index, element, clss);", "observations": "Changes return of a null object to throw an Exception. The only statement of an existent \"else block\" is replaced by an exception throw.", "repairActions": ["assignRem", "exThrowsAdd", "objInstAdd", "retRem"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 58, "problem": " private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             lhs = lhs.getLastChild();\n           }\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;", "fixed": " private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             lhs = lhs.getLastChild();\n           }\n          if (NodeUtil.isName(lhs)) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n          } else {\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 7, "problem": " public int compare(EventState es0, EventState es1) {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n                 for (final StepHandler handler : stepHandlers) {", "fixed": " public int compare(EventState es0, EventState es1) {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || state.stop();\n                }\n                 for (final StepHandler handler : stepHandlers) {", "observations": "Changes involving adding and removing of many loops.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "loopRem", "mcRem", "varReplVar"], "repairPatterns": ["copyPaste", "wrapsLoop", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n     }", "fixed": " public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 29, "problem": " public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n        description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }", "fixed": " public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }", "observations": "Wrapping implicit in \"exp?x:y\" format", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckP", "singleLine", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 104, "problem": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "fixed": " JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);", "observations": "A Null-Check was removed and replaced by another condition.", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Lang", "bugId": 15, "problem": " private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n             return typeVarAssigns;\n         }", "fixed": " private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n        if (toClass.equals(cls)) {\n             return typeVarAssigns;\n         }", "observations": "Change local var type.", "repairActions": ["assignExpChange", "condExpRed", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicReduce", "wrongMethodRef"]}
{"project": "Lang", "bugId": 17, "problem": " public final void translate(CharSequence input, Writer out) throws IOException {\n             return;\n         }\n         int pos = 0;\n        int len = Character.codePointCount(input, 0, input.length());\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n             }\n            else {\n             for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n             }\n            pos++;\n         }\n     }", "fixed": " public final void translate(CharSequence input, Writer out) throws IOException {\n             return;\n         }\n         int pos = 0;\n        int len = input.length();\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n                pos+= c.length;\n                continue;\n             }\n             for (int pt = 0; pt < consumed; pt++) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }", "observations": "Unwraps input.length() from \"Character.codePointCount()\" method. Unwraps \"for loop\" from else branch. Unwraps \"pos += ...\" from if-else branch.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcRem"], "repairPatterns": ["initFix", "missComp", "unwrapIfElse", "unwrapMethod"]}
{"project": "Math", "bugId": 31, "problem": " public double evaluate(double x, double epsilon, int maxIterations) {\n         int n = 1;\n         double dPrev = 0.0;\n        double p0 = 1.0;\n        double q1 = 1.0;\n         double cPrev = hPrev;\n         double hN = hPrev;", "fixed": " public double evaluate(double x, double epsilon, int maxIterations) {\n         int n = 1;\n         double dPrev = 0.0;\n         double cPrev = hPrev;\n         double hN = hPrev;", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranRem", "exThrowsRem", "loopRem", "mcAdd", "mcRem", "objInstRem", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "expArithMod", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 127, "problem": " private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);", "fixed": " private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n    private boolean inFinally(Node parent, Node child) {\n      if (parent == null || parent.isFunction()) {\n        return false;\n      } else if (NodeUtil.isTryFinallyNode(parent, child)) {\n        return true;\n      } else {\n        return inFinally(parent.getParent(), parent);\n      }\n    }\n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);", "observations": "", "repairActions": ["condBranIfElseAdd", "condExpExpand", "mcAdd", "mdAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand", "missComp", "missNullCheckP"]}
{"project": "Lang", "bugId": 60, "problem": " public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }", "fixed": " public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }", "observations": "", "repairActions": ["loopCondChange", "varReplVar"], "repairPatterns": ["expLogicMod", "wrongVarRef"]}
{"project": "Mockito", "bugId": 13, "problem": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n             }\r\n         }\r", "fixed": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n            } else {\r\n                mockingProgress.verificationStarted(verificationMode);\r\n             }\r\n         }\r", "observations": "", "repairActions": ["condBranElseAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce"]}
{"project": "Math", "bugId": 106, "problem": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         int startIndex = pos.getIndex();\r", "fixed": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n        if (num.intValue() < 0) {\r\n            pos.setIndex(initialIndex);\r\n            return null;\r\n        }\r\n         int startIndex = pos.getIndex();\r", "observations": "Only one variable is different between the two blocks of code in patch.", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste"]}
{"project": "Mockito", "bugId": 6, "problem": " public static float anyFloat() {\n      * @return <code>0</code>.\r\n      */\r\n     public static double anyDouble() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static float anyFloat() {\n      * @return <code>0</code>.\r\n      */\r\n     public static double anyDouble() {\r\n        return reportMatcher(new InstanceOf(Double.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 85, "problem": " public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +", "fixed": " public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +", "observations": "Changes operator in condition.", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 51, "problem": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 default:\n                 }\n             }", "fixed": " protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                 default:\n                    throw new MathInternalError();\n                 }\n             }", "observations": "Adds an exception throw in default clause of switch-case.", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 69, "problem": " private void visitCall(NodeTraversal t, Node n) {\n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());", "fixed": " private void visitCall(NodeTraversal t, Node n) {\n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !functionType.getTypeOfThis().isNativeObjectType() &&\n          !(child.getType() == Token.GETELEM ||\n            child.getType() == Token.GETPROP)) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Math", "bugId": 36, "problem": " public BigFraction divide(final BigFraction fraction) {\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n         return result;\n     }", "fixed": " public BigFraction divide(final BigFraction fraction) {\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n        if (Double.isNaN(result)) {\n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n            result = numerator.shiftRight(shift).doubleValue() /\n                denominator.shiftRight(shift).doubleValue();\n        }\n         return result;\n     }", "observations": "The change is almost the same in two different places. The only difference between changes is the use of the call \"doubleValue()\" in place of \"floatValue()\" in correspondent methods.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Closure", "bugId": 91, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Mockito", "bugId": 4, "problem": " public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n     private String exceptionCauseMessageIfAvailable(Exception details) {\n         return details.getCause().getMessage();\n     }", "fixed": " public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n     private String exceptionCauseMessageIfAvailable(Exception details) {\n        if (details.getCause() == null) {\n            return details.getMessage();\n        }\n         return details.getCause().getMessage();\n     }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Closure", "bugId": 77, "problem": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "fixed": " static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "singleLine"]}
{"project": "Lang", "bugId": 5, "problem": " public static Locale toLocale(final String str) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n     }", "fixed": " public static Locale toLocale(final String str) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "wrapsIfElse"]}
{"project": "Math", "bugId": 60, "problem": " public double density(double x) {\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n        try {\n         return 0.5 * (1.0 + Erf.erf((dev) /\n                     (standardDeviation * FastMath.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) {\n                return 0;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1;\n            } else {\n                throw ex;\n            }\n        }\n     }\n     /**", "fixed": " public double density(double x) {\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n        if (FastMath.abs(dev) > 40 * standardDeviation) { \n            return dev < 0 ? 0.0d : 1.0d;\n        }\n         return 0.5 * (1.0 + Erf.erf((dev) /\n                     (standardDeviation * FastMath.sqrt(2.0))));\n     }\n     /**", "observations": "Unwraps try-catch.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "condBranRem", "exThrowsRem", "exTryCatchRem", "mcAdd", "retBranchAdd", "retRem"], "repairPatterns": ["blockRemove", "condBlockRem", "condBlockRetAdd", "unwrapTryCatch"]}
{"project": "Closure", "bugId": 31, "problem": " Node parseInputs() {\n       if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {", "fixed": " Node parseInputs() {\n       if (options.dependencyOptions.needsManagement() &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {", "observations": "", "repairActions": ["condExpRed"], "repairPatterns": ["expLogicReduce", "singleLine"]}
{"project": "Mockito", "bugId": 28, "problem": " public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\r\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\r\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n         }\r\n     }\r", "fixed": " public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\r\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\r\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n            mocks.remove(injected);\r\n         }\r\n     }\r", "observations": "Changes method signature adding new parameter.", "repairActions": ["assignAdd", "mcAdd", "varAdd"], "repairPatterns": ["missComp", "singleLine", "wrapsMethod"]}
{"project": "Closure", "bugId": 76, "problem": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\nif (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n      }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "fixed": " private VariableLiveness isVariableReadBeforeKill(\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n     }\n     return VariableLiveness.MAYBE_LIVE;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 7, "problem": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                 if (needReset) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     return eventT;\n                 }\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventY);\n                }\n                 if (needReset) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                     return eventT;\n                 }", "observations": "Changes involving adding and removing of many loops.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "loopRem", "mcRem", "varReplVar"], "repairPatterns": ["copyPaste", "wrapsLoop", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n               grandparent.addChildBefore(newDecl, varNode);\n           }", "fixed": " private void findAliases(NodeTraversal t) {\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n               grandparent.addChildBefore(newDecl, varNode);\n            }\n           }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 70, "problem": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "fixed": " private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);", "observations": "", "repairActions": ["mcParValChange"], "repairPatterns": ["constChange", "singleLine"]}
{"project": "Mockito", "bugId": 17, "problem": "     private Object spiedInstance;\r\n     private Answer<Object> defaultAnswer;\r\n     private MockName mockName;\r\n     public MockSettings serializable() {\r\n        return this.extraInterfaces(java.io.Serializable.class);\r\n     }\r\n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\r", "fixed": "     private Object spiedInstance;\r\n     private Answer<Object> defaultAnswer;\r\n     private MockName mockName;\r\n    private boolean serializable;\r\n     public MockSettings serializable() {\r\n        this.serializable = true;\r\n        return this;\r\n     }\r\n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Lang", "bugId": 30, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            return true;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 10, "problem": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n                withSettingsUsing(returnTypeGenericMetadata)\r\n         );\r\n     }\r\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n        return mockSettings.serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r", "fixed": " private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\r\n        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\r\n         );\r\n     }\r\n    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n        return propagateSerializationSettings(mockSettings, parentMockSettings)\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\r\n        return mockSettings.serializable(parentMockSettings.getSerializableMode());\r\n    }\r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r", "observations": "Changes signature of existent methods, adding new params.", "repairActions": ["mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Closure", "bugId": 64, "problem": " public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n    return toSource(n, null);\n   }\n   \n  private String toSource(Node n, SourceMap sourceMap) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);", "fixed": " public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n   }\n   \n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);", "observations": "New parameters are added in three method calls (call to overloaded methods). A logic expression passed to a method call is changed.", "repairActions": ["mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Lang", "bugId": 19, "problem": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 out.write(entityValue);\n             }\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n     }", "fixed": " public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 out.write(entityValue);\n             }\n            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n         }\n         return 0;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpMod", "loopCondChange", "mcAdd", "mcRem", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "constChange", "expArithMod", "expLogicMod", "wrapsIfElse"]}
{"project": "Closure", "bugId": 57, "problem": " private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n          if (target != null) {\n             className = target.getString();\n           }\n         }", "fixed": " private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n          if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }", "observations": "Altought there is a null check in the conditional expression, the expression is expanded with an extra condition not related to null-check.", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = computeFollowing(n);\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Mockito", "bugId": 35, "problem": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n        return reportMatcher(new Same(value)).<T>returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());\r\n     }\r\n     /**\r", "observations": "", "repairActions": ["mcAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 105, "problem": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n        if (sb.length() > 0) {\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);", "fixed": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n        if (sb != null) {\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = null;\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);", "observations": "Moves the instantiation of StringBuilder to another place.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "condExpMod", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "expLogicMod", "initFix"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n        return (T) anyObject();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 77, "problem": " public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from", "fixed": " public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from", "observations": "Fix a assignment. Removes a method (aparently, unrelated changes).", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcRem", "mdOverride", "mdRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Math", "bugId": 91, "problem": " public Fraction abs() {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }", "fixed": " public Fraction abs() {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }", "observations": "The value of a class attribute is accessed in place of a method to do the assignment.", "repairActions": ["assignExpChange", "mcRem", "varTyChange"], "repairPatterns": ["expArithMod", "initFix", "wrongComp"]}
{"project": "Closure", "bugId": 84, "problem": " Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {", "fixed": " Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "mdAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Lang", "bugId": 26, "problem": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "fixed": " public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }", "observations": "Adds a new parameter to constructor call (call overloaded constructor)", "repairActions": ["objInstMod"], "repairPatterns": ["initFix", "singleLine", "wrongMethodRef"]}
{"project": "Lang", "bugId": 46, "problem": " public static void escapeJavaScript(Writer out, String str) throws IOException {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n             return writer.toString();\n         } catch (IOException ioe) {", "fixed": " public static void escapeJavaScript(Writer out, String str) throws IOException {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n             return writer.toString();\n         } catch (IOException ioe) {", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 12, "problem": " ReachingUses flowThrough(Node n, ReachingUses input) {\n   }\n   private boolean hasExceptionHandler(Node cfgNode) {\n     return false;\n   }", "fixed": " ReachingUses flowThrough(Node n, ReachingUses input) {\n   }\n   private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n     return false;\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 25, "problem": " private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);", "fixed": " private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n                if (c2 == 0) {\n                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n                }\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Time", "bugId": 25, "problem": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n         }\n         return offsetAdjusted;\n     }", "fixed": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n         }\n         return offsetAdjusted;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 65, "problem": " protected void updateResidualsAndCost()\n     public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += residual * residual * residualsWeights[i];\n        }\n        return Math.sqrt(criterion / rows);\n     }\n     \n     public double getChiSquare() {\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n            chiSquare += residual * residual / residualsWeights[i];\n         }\n         return chiSquare;\n     }\n     /**\n      * Get the covariance matrix of optimized parameters.\n      * @return covariance matrix\n      * @exception FunctionEvaluationException if the function jacobian cannot\n      * be evaluated\n      * @exception OptimizationException if the covariance matrix", "fixed": " protected void updateResidualsAndCost()\n     public double getRMS() {\n        return Math.sqrt(getChiSquare() / rows);\n     }\n     \n     public double getChiSquare() {\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }\n     /**\n      * Get the covariance matrix of optimized parameters.\n      * @return covariance matrix\n      * @exception FunctionEvaluationException if the function jacobian cannot\n      * be evaluated\n      * @exception OptimizationException if the covariance matrix", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcParValChange", "varRem", "varReplMc"], "repairPatterns": ["blockRemove", "expArithMod", "wrongVarRef"]}
{"project": "Lang", "bugId": 50, "problem": " public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n        if (locale != null) {\n            key = new Pair(key, locale);\n         }\n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);", "fixed": " public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n        if (locale == null) {\n            locale = Locale.getDefault();\n         }\n        key = new Pair(key, locale);\n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);", "observations": "Replaces some existent Null-Chek, inverting postive by negative.", "repairActions": ["assignAdd", "assignRem", "condBranRem", "condExpMod", "mcAdd", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockRem", "copyPaste", "expLogicMod", "unwrapIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 9, "problem": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "fixed": " private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n             final RealMatrix arz = randn1(dimension, lambda);", "fixed": " protected PointValuePair doOptimize() {\n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n            incrementIterationCount();\n             final RealMatrix arz = randn1(dimension, lambda);", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 99, "problem": " public static int gcd(final int p, final int q) {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }", "fixed": " public static int gcd(final int p, final int q) {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        new Object[] { p, q });\n            }\n             return (Math.abs(u) + Math.abs(v));\n         }", "observations": "Instantiates a vector object as part of the exception creation.", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Math", "bugId": 17, "problem": " public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n             return multiplyFast(x);\n     }\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.", "fixed": " public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n        if (x >= 0 && x < RADIX) {\n             return multiplyFast(x);\n        } else {\n            return multiply(newInstance(x));\n        }\n     }\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 48, "problem": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                     break;\n                 default:", "fixed": " protected final double doSolve() {\n                 case REGULA_FALSI:\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                     break;\n                 default:", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Closure", "bugId": 96, "problem": " private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n           parameters.hasNext()) {\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;", "fixed": " private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      if (parameters.hasNext()) {\n         parameter = parameters.next();\n      }\n       argument = arguments.next();\n       ordinal++;", "observations": "", "repairActions": ["condBranIfAdd", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "wrapsIf"]}
{"project": "Closure", "bugId": 114, "problem": " private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n        } else {", "fixed": " private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["singleLine", "wrapsIf"]}
{"project": "Math", "bugId": 95, "problem": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             ret = d / (d - 2.0);\n         return ret;\n     }", "fixed": " protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n        double ret = 1.0;\n         double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n             ret = d / (d - 2.0);\n        }\n         return ret;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["initFix", "wrapsIf"]}
{"project": "Lang", "bugId": 36, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n        if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand"]}
{"project": "Lang", "bugId": 7, "problem": " public static BigDecimal createBigDecimal(String str) {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         return new BigDecimal(str);\n     }", "fixed": " public static BigDecimal createBigDecimal(String str) {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n        if (str.trim().startsWith(\"--\")) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n         return new BigDecimal(str);\n     }", "observations": "In one of the chunks, removes a conditional block with return.", "repairActions": ["condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem"], "repairPatterns": ["blockRemove", "condBlockExcAdd", "condBlockRem"]}
{"project": "Lang", "bugId": 47, "problem": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missNullCheckP"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 88, "problem": " private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n         return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;", "fixed": " private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n         return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Mockito", "bugId": 22, "problem": " public class Equality {\r\n     public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r", "fixed": " public class Equality {\r\n     public static boolean areEqual(Object o1, Object o2) {\r\n        if (o1 == o2 ) {\r\n            return true;\r\n\t} else if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r", "observations": "", "repairActions": ["condBranIfElseAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 122, "problem": " private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,", "fixed": " private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n    if (p.matcher(comment.getValue()).find()) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,", "observations": "", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 112, "problem": " private boolean inferTemplatedTypesForCall(\n     }\n    Map<TemplateType, JSType> inferred = \n        inferTemplateTypesFromParameters(fnType, n);", "fixed": " private boolean inferTemplatedTypesForCall(\n     }\n    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n        inferTemplateTypesFromParameters(fnType, n),\n        new Predicate<TemplateType>() {\n          @Override\n          public boolean apply(TemplateType key) {\n            return keys.contains(key);\n          }}\n        );", "observations": "Adds an inline interface implementation for a parameter of type Predicate on filterKeys method call.", "repairActions": ["assignExpChange", "mcAdd", "mdAdd", "mdOverride", "objInstAdd", "tyImpInterf"], "repairPatterns": ["wrapsMethod"]}
{"project": "Math", "bugId": 26, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condExpMod", "mcAdd"], "repairPatterns": ["expLogicMod", "wrapsMethod"]}
{"project": "Closure", "bugId": 105, "problem": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n    if (sb.length() > 0) {\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));", "fixed": " void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n    if (sb != null) {\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));", "observations": "Moves the instantiation of StringBuilder to another place.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "condExpMod", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "expLogicMod", "initFix"]}
{"project": "Math", "bugId": 83, "problem": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "fixed": " private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Time", "bugId": 9, "problem": " public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n      * @return the DateTimeZone object for the offset\n      */\n     public static DateTimeZone forOffsetMillis(int millisOffset) {\n         String id = printOffset(millisOffset);\n         return fixedOffsetZone(id, millisOffset);\n     }", "fixed": " public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n      * @return the DateTimeZone object for the offset\n      */\n     public static DateTimeZone forOffsetMillis(int millisOffset) {\n        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n        }\n         String id = printOffset(millisOffset);\n         return fixedOffsetZone(id, millisOffset);\n     }", "observations": "", "repairActions": ["assignExpChange", "condBranIfAdd", "exThrowsAdd", "mcRem", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "expArithMod"]}
{"project": "Closure", "bugId": 38, "problem": " void addNumber(double x) {\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n       add(\" \");\n     }", "fixed": " void addNumber(double x) {\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n       add(\" \");\n     }", "observations": "Parentesis added has no effect on expression evaluation, so a conditional expression expansion was considered only.", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 7, "problem": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "fixed": " public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          return ctorType.getGreatestSubtype(type);\n        } else {\n          return type.isSubtype(ctorType) ? null : type;\n        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "mcRem", "retBranchAdd", "retRem"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "wrongComp"]}
{"project": "Closure", "bugId": 111, "problem": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType;\n         }\n         @Override", "fixed": "       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n         }\n         @Override", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsIfElse"]}
{"project": "Math", "bugId": 74, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n         if (firstTime) {\n          final double[] scale = new double[y0.length];\n           if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n             } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);", "observations": "A vector/object was instantiated.The way to initialize values was changed.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "mcRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Math", "bugId": 1, "problem": " private BigFraction(final double value, final double epsilon,\n             if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private BigFraction(final double value, final double epsilon,\n             if ((p2 > overflow) || (q2 > overflow)) {\n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Closure", "bugId": 124, "problem": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n       node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "fixed": " private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n    while (node.isGetProp()) {\n       node = node.getFirstChild();\n    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;", "observations": "", "repairActions": ["loopAdd", "mcAdd"], "repairPatterns": ["missComp", "wrapsLoop"]}
{"project": "Closure", "bugId": 14, "problem": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "fixed": " private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);", "observations": "Parameter value change.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["constChange", "singleLine", "wrongVarRef"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n         }\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "fixed": "else if (lclip <= 0.0) {\n         }\r\n        Number n = dataset.getStdDevValue(row, column);\r\n        if (n != null) {\r\n            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 72, "problem": " public double solve(final UnivariateRealFunction f,\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n             return result;\n         }", "fixed": " public double solve(final UnivariateRealFunction f,\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n             return result;\n         }", "observations": "Similar changes in two different places, the same melhod is targeted, the same argument is changed, only the new values applied are different.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 78, "problem": " private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;", "fixed": " private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n           return null;\n         }\n         result = lval / rval;", "observations": "Removes error invocation call.", "repairActions": ["mcRem"], "repairPatterns": ["copyPaste"]}
{"project": "Mockito", "bugId": 14, "problem": " public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n        mockingProgress.verificationStarted(mode);\r\n         return mock;\r\n     }\r", "fixed": " public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\r\n         return mock;\r\n     }\r", "observations": "An existing parameter (\"mode\") was wrapped by a constructor call, instantiating MockAwareVerificationMode object", "repairActions": ["condBranIfAdd", "mcAdd", "mcParValChange", "objInstAdd"], "repairPatterns": ["wrapsIf", "wrapsMethod"]}
{"project": "Time", "bugId": 16, "problem": " public int parseInto(ReadWritableInstant instant, String text, int position) {\n         chrono = selectChronology(chrono);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {", "fixed": " public int parseInto(ReadWritableInstant instant, String text, int position) {\n         chrono = selectChronology(chrono);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {", "observations": "Changes parameter for constructor call.", "repairActions": ["mcAdd", "mcParValChange", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Lang", "bugId": 29, "problem": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static float toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "fixed": " static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n    static int toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }", "observations": "Changes return type of method.", "repairActions": ["mdRetTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Closure", "bugId": 71, "problem": " private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n      boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;", "fixed": " private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n      boolean isOverride = parent.getJSDocInfo() != null &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;", "observations": "The null-check is done in a boolean expression assigned to a variable and not to a conditional test.", "repairActions": ["assignExpChange", "mcAdd", "mcRem"], "repairPatterns": ["expLogicMod", "missNullCheckN", "singleLine"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n         int iter = 0;\n         while (true) {", "fixed": " protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        UnivariatePointValuePair best = current;\n         int iter = 0;\n         while (true) {", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Closure", "bugId": 32, "problem": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n           ignoreStar = true;\n           token = next();\n           continue;", "fixed": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n           ignoreStar = true;\n          lineStartChar = 0;\n           token = next();\n           continue;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Math", "bugId": 86, "problem": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] lI = lTData[i];\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n             for (int j = i + 1; j < order; ++j) {\n                 final double[] lJ = lTData[j];", "fixed": " public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] lI = lTData[i];\n             for (int j = i + 1; j < order; ++j) {\n                 final double[] lJ = lTData[j];", "observations": "The condition to throw the exception is moved from one place to another.", "repairActions": ["condBranIfAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "objInstAdd", "objInstRem"], "repairPatterns": ["codeMove"]}
{"project": "Lang", "bugId": 30, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Closure", "bugId": 21, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isExprResult()) {\n       return;\n     }", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isExprResult() || n.isBlock()) {\n       return;\n     }", "observations": "", "repairActions": ["assignRem", "condBranRem", "condExpExpand", "loopRem", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockRem", "expLogicExpand", "expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 90, "problem": " public boolean apply(JSType type) {\n      if (!type.isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;", "fixed": " public boolean apply(JSType type) {\n      if (!type.restrictByNotNullOrUndefined().isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condExpMod", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Lang", "bugId": 36, "problem": " public static boolean isNumber(String str) {\n                 return false;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'", "fixed": " public static boolean isNumber(String str) {\n                 return false;\n             }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    return false;\n                }\n                return foundDigit;\n            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'", "observations": "", "repairActions": ["condBranIfAdd", "condExpExpand", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicExpand"]}
{"project": "Closure", "bugId": 32, "problem": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n             return new ExtractionInfo(multilineText, token);\n           }\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n           builder.append(toString(token));\n           line = stream.getRemainingJSDocLine();", "fixed": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n             return new ExtractionInfo(multilineText, token);\n           }\n           builder.append(toString(token));\n           line = stream.getRemainingJSDocLine();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Math", "bugId": 30, "problem": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final int n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "fixed": " private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n        final double n1n2prod = n1 * n2;\n         final double EU = n1n2prod / 2.0;", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Math", "bugId": 22, "problem": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return false;\n     }\n     /**", "fixed": " public boolean isSupportLowerBoundInclusive() {\n     \n     public boolean isSupportUpperBoundInclusive() {\n        return true;\n     }\n     /**", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Math", "bugId": 46, "problem": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return isZero ? NaN : INF;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "fixed": " public Complex divide(Complex divisor)\n         if (divisor.isZero) {\n            return NaN;\n         }\n         if (divisor.isInfinite() && !isInfinite()) {", "observations": "The removed if-else condition is in the form \"exp?a:b\".", "repairActions": ["condBranRem", "retExpChange"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Mockito", "bugId": 7, "problem": " private void readTypeVariables() {\n             for (Type type : typeVariable.getBounds()) {\r\n                 registerTypeVariablesOn(type);\r\n             }\r\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n         }\r", "fixed": " private void readTypeVariables() {\n             for (Type type : typeVariable.getBounds()) {\r\n                 registerTypeVariablesOn(type);\r\n             }\r\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\r\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n         }\r", "observations": "Instantiates and initializes an TypeVariable vector.", "repairActions": ["mcAdd", "objInstAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Mockito", "bugId": 31, "problem": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \t\tprivate String formatMethodCall() {\r\n\t\t\treturn invocation.getMethod().getName() + \"()\";\r\n \t\t}\r\n     }\r", "fixed": " public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \t\tprivate String formatMethodCall() {\r\n\t\t\tString args = Arrays.toString(invocation.getArguments());\r\n\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\r\n \t\t}\r\n     }\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "retExpChange", "varAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Lang", "bugId": 4, "problem": "      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n        lookupMap = new HashMap<CharSequence, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0], seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;", "fixed": "      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n        lookupMap = new HashMap<String, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0].toString(), seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Math", "bugId": 87, "problem": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                 row = i;\n                } else {\n                 return null;\n                }\n             }\n         }\n         return row;", "fixed": " protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                 return null;\n             }\n         }\n         return row;", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse", "wrongComp"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node block(Node ... stmts) {\n     return block;\n   }\n   public static Node script(Node ... stmts) {", "fixed": " public static Node block(Node ... stmts) {\n     return block;\n   }\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n   public static Node script(Node ... stmts) {", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 70, "problem": " public double solve(double min, double max)\n     \n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n     }\n     ", "fixed": " public double solve(double min, double max)\n     \n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n     }\n     ", "observations": "Call overloaded method without one parameter.", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n         lmPar = 0;\n         boolean firstIteration = true;\n         while (true) {\n             incrementIterationsCounter();\n             updateJacobian();\n             qrDecomposition();", "fixed": " protected VectorialPointValuePair doOptimize()\n         lmPar = 0;\n         boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n             incrementIterationsCounter();\n            VectorialPointValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Closure", "bugId": 44, "problem": " void add(String newcode) {\n       append(\" \");\n     }\n     append(newcode);", "fixed": " void add(String newcode) {\n       append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      append(\" \");\n     }\n     append(newcode);", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 106, "problem": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r", "fixed": " public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n        if (den.intValue() < 0) {\r\n            pos.setIndex(initialIndex);\r\n            return null;\r\n        }\r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r", "observations": "Only one variable is different between the two blocks of code in patch.", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste"]}
{"project": "Closure", "bugId": 72, "problem": " private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n                 \"inline_\",\n                 isCallInLoop)));\n   }\n   static class LabelNameSupplier implements Supplier<String> {", "fixed": " private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n                 \"inline_\",\n                 isCallInLoop)));\n    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n        .process(null, fnNode);\n   }\n   static class LabelNameSupplier implements Supplier<String> {", "observations": "Instantiates an anonymous object and make a method call on it.", "repairActions": ["condExpExpand", "mcAdd", "objInstAdd"], "repairPatterns": ["expLogicExpand", "missComp"]}
{"project": "Lang", "bugId": 52, "problem": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                     default :\n                         out.write(ch);\n                         break;", "fixed": " private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                     default :\n                         out.write(ch);\n                         break;", "observations": "", "repairActions": ["condBranCaseAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 25, "problem": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n     Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "fixed": " private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n   private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n     Node constructor = n.getFirstChild();\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {", "observations": "", "repairActions": ["assignExpChange", "assignRem", "loopRem", "mcAdd", "mcRem"], "repairPatterns": ["blockRemove", "notClassified"]}
{"project": "Mockito", "bugId": 19, "problem": " public OngoingInjecter filterCandidate(Collection<Object> mocks,\n \t\t\t\t\tmockNameMatches.add(mock);\n \t\t\t\t}\n \t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field,\n \t\t\t\t\tfieldInstance);\n \t\t\t/*\n \t\t\t * In this case we have to check whether we have conflicting naming", "fixed": " public OngoingInjecter filterCandidate(Collection<Object> mocks,\n \t\t\t\t\tmockNameMatches.add(mock);\n \t\t\t\t}\n \t\t\t}\n\t\t\treturn next.filterCandidate(mockNameMatches, field, fields,\n \t\t\t\t\tfieldInstance);\n \t\t\t/*\n \t\t\t * In this case we have to check whether we have conflicting naming", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 103, "problem": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n     }\n     /**", "fixed": " public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) {\n                return 0.0d;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1.0d;\n            } else {\n                throw ex;\n            }\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "retBranchAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "wrapsTryCatch", "wrongComp"]}
{"project": "Math", "bugId": 90, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n     /**\n      * Adds 1 to the frequency count for v.", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        addValue((Comparable<?>) v);\n    }\n     /**\n      * Adds 1 to the frequency count for v.", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 123, "problem": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "fixed": " void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);", "observations": "Changes value in assignment from constant to method call.", "repairActions": ["assignExpChange", "mcAdd", "varReplMc"], "repairPatterns": ["initFix", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setWeekyear(final int weekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n     }", "fixed": " public void setWeekyear(final int weekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n        if (weekyears != 0) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isInlinableObject(List<Reference> refs) {\n           continue;\n         }", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n           continue;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 63, "problem": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "fixed": " private String format(JSError error, boolean warning) {\n       if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {", "observations": "Same as bug 62", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Closure", "bugId": 16, "problem": " private void fixTypeNode(Node typeNode) {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n         }\n       }", "fixed": " private void fixTypeNode(Node typeNode) {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n         }\n       }", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcParAdd", "mcParValChange", "mcRepl", "mdParAdd", "objInstMod", "varAdd"], "repairPatterns": ["initFix", "wrapsMethod", "wrongComp"]}
{"project": "Closure", "bugId": 89, "problem": " boolean canCollapseUnannotatedChildNames() {\n       }\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n         return false;\n       }", "fixed": " boolean canCollapseUnannotatedChildNames() {\n       }\n      if (aliasingGets > 0) {\n         return false;\n       }", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missNullCheckN"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                     }\n                 }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best;\n                     }\n                 }", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Chart", "bugId": 21, "problem": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "fixed": " else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n        }\r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r", "observations": "It seems that the functionality wasn't implemented before.", "repairActions": ["assignAdd", "condBranElseAdd", "condBranIfAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrapsElse"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = x[i] / diff;\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Math", "bugId": 29, "problem": " public OpenMapRealVector ebeDivide(RealVector v) {\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n         }\n         return res;\n     }", "fixed": " public OpenMapRealVector ebeDivide(RealVector v) {\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n        final int n = getDimension();\n        for (int i = 0; i < n; i++) {\n            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n         }\n         return res;\n     }", "observations": "Changed a while loop to a for lor loop.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["condBlockOthersAdd", "missComp", "wrongComp"]}
{"project": "Chart", "bugId": 16, "problem": " public void setCategoryKeys(Comparable[] categoryKeys) {\n         if (categoryKeys == null) {\r\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n         }\r\n        if (categoryKeys.length != this.startData[0].length) {\r\n             throw new IllegalArgumentException(\r\n                     \"The number of categories does not match the data.\");\r\n         }\r", "fixed": " public void setCategoryKeys(Comparable[] categoryKeys) {\n         if (categoryKeys == null) {\r\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n         }\r\n        if (categoryKeys.length != getCategoryCount()) {\r\n             throw new IllegalArgumentException(\r\n                     \"The number of categories does not match the data.\");\r\n         }\r", "observations": "Variable initialization in constructor + conditional expression change.", "repairActions": ["assignExpChange", "condExpMod", "mcAdd", "objInstAdd", "varReplMc"], "repairPatterns": ["expLogicMod", "initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 56, "problem": " public String getLine(int lineNumber) {\n         return null;\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }", "fixed": " public String getLine(int lineNumber) {\n      if (pos >= js.length()) {\n         return null;\n      } else {\n        return js.substring(pos, js.length());\n      }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 99, "problem": " public static int lcm(int a, int b) {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n         return lcm;\n     }", "fixed": " public static int lcm(int a, int b) {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE){\n            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n        }\n         return lcm;\n     }", "observations": "Instantiates a vector object as part of the exception creation.", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Lang", "bugId": 20, "problem": " public static String join(Object[] array, char separator, int startIndex, int en\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "fixed": " public static String join(Object[] array, char separator, int startIndex, int en\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "observations": "Null-Check is removed from \"buf\" initialization.", "repairActions": ["assignExpChange", "condBranRem", "mcRem", "objInstMod"], "repairPatterns": ["condBlockRem", "copyPaste", "initFix"]}
{"project": "Lang", "bugId": 43, "problem": " private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;", "fixed": " private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Lang", "bugId": 60, "problem": " public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }", "fixed": " public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }", "observations": "", "repairActions": ["loopCondChange", "varReplVar"], "repairPatterns": ["expLogicMod", "wrongVarRef"]}
{"project": "Mockito", "bugId": 23, "problem": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "fixed": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n    private synchronized void instantiateMockitoCoreIfNeeded() {\r\n        if (mockitoCore == null) {\r\n            mockitoCore = new MockitoCore();\r\n        }\r\n    }\r\n    private synchronized void instantiateDelegateIfNeeded() {\r\n        if (delegate == null) {\r\n            delegate = new ReturnsEmptyValues();\r\n        }\r\n    }\r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Closure", "bugId": 42, "problem": " Node processExpressionStatement(ExpressionStatement statementNode) {\n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),", "fixed": " Node processExpressionStatement(ExpressionStatement statementNode) {\n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n      if (loopNode.isForEach()) {\n        errorReporter.error(\n            \"unsupported language extension: for each\",\n            sourceName,\n            loopNode.getLineno(), \"\", 0);\n        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      }\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 68, "problem": " boolean parse() {\n                         }\n                         break;\n                     }\n                   token = eatTokensUntilEOL();\n                  }\n                   continue retry;\n               }\n             }", "fixed": " boolean parse() {\n                         }\n                         break;\n                     }\n                  }\n                   token = eatTokensUntilEOL();\n                   continue retry;\n               }\n             }", "observations": "An assignment was moved outside a branch.", "repairActions": ["mcAdd"], "repairPatterns": ["codeMove", "copyPaste", "missComp", "unwrapIfElse"]}
{"project": "Closure", "bugId": 66, "problem": " public void visit(NodeTraversal t, Node n, Node parent) {\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n         }\n         break;", "fixed": " public void visit(NodeTraversal t, Node n, Node parent) {\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n        } else {\n          typeable = false;\n         }\n         break;", "observations": "", "repairActions": ["assignAdd", "condBranElseAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Math", "bugId": 22, "problem": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return true;\n     }\n     ", "fixed": " public double getSupportUpperBound() {\n     \n     public boolean isSupportLowerBoundInclusive() {\n        return false;\n     }\n     ", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange"]}
{"project": "Closure", "bugId": 8, "problem": " private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n           && !blacklistedVars.contains(var);\n     }\n   }\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {", "fixed": " private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n          && !isNamedParameter(var)\n           && !blacklistedVars.contains(var);\n     }\n   }\n  private boolean isNamedParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {", "observations": "Adds a new condition in expression and a new method invocated by this condition.", "repairActions": ["mcAdd", "mdAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["expLogicExpand"]}
{"project": "Closure", "bugId": 10, "problem": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "fixed": " static boolean mayBeString(Node n) {\n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }", "observations": "", "repairActions": ["mcRepl", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Lang", "bugId": 46, "problem": " public static String escapeJavaScript(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n        escapeJavaStyleString(out, str, true);\n     }\n     /**", "fixed": " public static String escapeJavaScript(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n        escapeJavaStyleString(out, str, true, true);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Closure", "bugId": 20, "problem": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "fixed": " private Node tryFoldSimpleFunctionCall(Node n) {\n       Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckP", "singleLine"]}
{"project": "Closure", "bugId": 4, "problem": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }", "fixed": " JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n     resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }", "observations": "", "repairActions": ["condExpMod", "mcRepl"], "repairPatterns": ["copyPaste", "expLogicMod", "wrongMethodRef"]}
{"project": "Lang", "bugId": 56, "problem": " public int hashCode() {\n     public String toString() {\n         return \"FastDateFormat[\" + mPattern + \"]\";\n     }\n     \n     private interface Rule {\n         \n         int estimateLength();\n         \n         void appendTo(StringBuffer buffer, Calendar calendar);\n     }\n     \n     private interface NumberRule extends Rule {\n         /**\n          * Appends the specified value to the output buffer based on the rule implementation.\n          * \n          * @param buffer the output buffer", "fixed": " public int hashCode() {\n     public String toString() {\n         return \"FastDateFormat[\" + mPattern + \"]\";\n     }\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        init();\n    }\n     \n     private interface Rule {\n         \n         int estimateLength();\n         \n         void appendTo(StringBuffer buffer, Calendar calendar);\n     }\n     \n     private interface NumberRule extends Rule {\n         /**\n          * Appends the specified value to the output buffer based on the rule implementation.\n          * \n          * @param buffer the output buffer", "observations": "Changes types modifiers and overrides method related to Serialization.", "repairActions": ["mcAdd", "mdAdd", "mdOverride", "varModChange"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n                 }\n                 if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&", "fixed": " protected VectorialPointValuePair doOptimize()\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n                    tmpVec    = objective;\n                    objective = oldObj;\n                    oldObj    = tmpVec;\n                 }\n                 if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Map anyMap() {\n      * @return empty Collection.\r\n      */\r\n     public static Collection anyCollection() {\r\n        return reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static Map anyMap() {\n      * @return empty Collection.\r\n      */\r\n     public static Collection anyCollection() {\r\n        return reportMatcher(new InstanceOf(Collection.class)).returnList();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 80, "problem": " private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];", "fixed": " private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];", "observations": "Fix expression in assignment (added parathesis).", "repairActions": ["assignExpChange"], "repairPatterns": ["expArithMod", "singleLine"]}
{"project": "Closure", "bugId": 79, "problem": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n   }\n   /**", "fixed": " private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n    compiler.reportCodeChange();\n   }\n   /**", "observations": "Calls overloaded method with extra parameters.", "repairActions": ["mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Lang", "bugId": 34, "problem": "      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n     }\n     /**", "fixed": "      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n        return REGISTRY.get();\n     }\n     /**", "observations": "", "repairActions": ["condBranRem", "mcRem", "retExpChange"], "repairPatterns": ["expLogicExpand", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 72, "problem": " public double solve(final UnivariateRealFunction f,\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n             return result;\n         }", "fixed": " public double solve(final UnivariateRealFunction f,\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n             return result;\n         }", "observations": "Similar changes in two different places, the same melhod is targeted, the same argument is changed, only the new values applied are different.", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 68, "problem": " private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n     return reportGenericTypeSyntaxWarning();\n   }", "fixed": " private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }", "observations": "An assignment was moved outside a branch.", "repairActions": ["mcAdd"], "repairPatterns": ["codeMove", "copyPaste", "missComp", "unwrapIfElse"]}
{"project": "Closure", "bugId": 106, "problem": " boolean canCollapseUnannotatedChildNames() {\n       if (isClassOrEnum) {\n         return true;", "fixed": " boolean canCollapseUnannotatedChildNames() {\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n       if (isClassOrEnum) {\n         return true;", "observations": "", "repairActions": ["condBranIfAdd", "condBranRem", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "unwrapIfElse"]}
{"project": "Closure", "bugId": 54, "problem": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          if (!qVar.isTypeInferred()) {", "fixed": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.getType() == Token.OBJECTLIT) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Math", "bugId": 6, "problem": " public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n            if (iteration > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];", "fixed": " public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n            if (getIterations() > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 97, "problem": " private Node tryFoldShift(Node n, Node left, Node right) {\n          result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +", "fixed": " private Node tryFoldShift(Node n, Node left, Node right) {\n          long lvalLong = lvalInt & 0xffffffffL;\n          result = lvalLong >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "varAdd"], "repairPatterns": ["expArithMod", "missComp", "singleLine"]}
{"project": "Lang", "bugId": 64, "problem": " public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n         return iValue - ((ValuedEnum) other).iValue;\n     }", "fixed": " public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n        if (other == this) {\n            return 0;\n        }\n        if (other.getClass() != this.getClass()) {\n            if (other.getClass().getName().equals(this.getClass().getName())) {\n                return iValue - getValueInOtherClassLoader(other);\n            }\n            throw new ClassCastException(\n                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n        }\n         return iValue - ((ValuedEnum) other).iValue;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "exTryCatchAdd", "mcAdd", "mdAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 1, "problem": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }", "fixed": " private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n                    break;\n                }\n                 throw new FractionConversionException(value, p2, q2);\n             }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Lang", "bugId": 20, "problem": " public static String join(Object[] array, String separator, int startIndex, int\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "fixed": " public static String join(Object[] array, String separator, int startIndex, int\n             return EMPTY;\n         }\n        StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {", "observations": "Null-Check is removed from \"buf\" initialization.", "repairActions": ["assignExpChange", "condBranRem", "mcRem", "objInstMod"], "repairPatterns": ["condBlockRem", "copyPaste", "initFix"]}
{"project": "Math", "bugId": 93, "problem": " public static double factorialDouble(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }", "fixed": " public static double factorialDouble(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n        if (n < 21) {\n            return factorial(n);\n        }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Lang", "bugId": 32, "problem": " public static int reflectionHashCode(Object object, String[] excludeFields) {\n      *            The object to register.\n      */\n     static void register(Object value) {\n         getRegistry().add(new IDKey(value));\n     }", "fixed": " public static int reflectionHashCode(Object object, String[] excludeFields) {\n      *            The object to register.\n      */\n     static void register(Object value) {\n        synchronized (HashCodeBuilder.class) {\n            if (getRegistry() == null) {\n                REGISTRY.set(new HashSet<IDKey>());\n            }\n        }\n         getRegistry().add(new IDKey(value));\n     }", "observations": "Applies null check using synchronized block with object lock (HashCodeBuilder.class)", "repairActions": ["condBranIfAdd", "mcAdd", "mdOverride", "mdRem", "objInstMod", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP"]}
{"project": "Lang", "bugId": 57, "problem": " public static Set availableLocaleSet() {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n     }", "fixed": " public static Set availableLocaleSet() {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n     }", "observations": "Changes direct acces of an object to method call.", "repairActions": ["mcAdd", "retExpChange", "varReplMc"], "repairPatterns": ["singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 1, "problem": " private void removeUnreferencedFunctionArgs(Scope fnScope) {\n     Node function = fnScope.getRootNode();", "fixed": " private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    if (!removeGlobals) {\n      return;\n    }\n     Node function = fnScope.getRootNode();", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Lang", "bugId": 39, "problem": " private static String replaceEach(String text, String[] searchList, String[] rep\n         for (int i = 0; i < searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\nincrease += 3 * greater;", "fixed": " private static String replaceEach(String text, String[] searchList, String[] rep\n         for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\nincrease += 3 * greater;", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckP"]}
{"project": "Chart", "bugId": 7, "problem": " private void updateBounds(TimePeriod period, int index) {\n         }\r\n         if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                 .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                 .getTime();\r\n             long maxMiddle = s + (e - s) / 2;\r\n             if (middle > maxMiddle) {\r", "fixed": " private void updateBounds(TimePeriod period, int index) {\n         }\r\n         if (this.maxMiddleIndex >= 0) {\r\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\r\n                 .getTime();\r\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\r\n                 .getTime();\r\n             long maxMiddle = s + (e - s) / 2;\r\n             if (middle > maxMiddle) {\r", "observations": "", "repairActions": ["assignExpChange", "mcParValChange", "varReplVar"], "repairPatterns": ["copyPaste", "expArithMod", "wrongVarRef"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "fixed": " public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n        if (date.getTime() < 0) {\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Time", "bugId": 3, "problem": " public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n     }", "fixed": " public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n        if (amount != 0) {\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 79, "problem": " private void reportCodeChange(String changeDescription) {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverse(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);", "fixed": " private void reportCodeChange(String changeDescription) {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);", "observations": "Calls overloaded method with extra parameters.", "repairActions": ["mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Time", "bugId": 12, "problem": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "fixed": " public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),", "observations": "The if/else added is implicit in the passed parameter format (exp?x:y) for the LocalDate constructor call.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "mcParValChange", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 113, "problem": " private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n      if (provided != null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }", "fixed": " private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n      if (provided != null || requiresLevel.isOn()) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }", "observations": "Again, an existent condition with Null-Check was expanded with other condition.", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Time", "bugId": 3, "problem": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n     }", "fixed": " public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Math", "bugId": 98, "problem": " public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[v.length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {", "fixed": " public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {", "observations": "Changes dimension of two vectors.", "repairActions": ["varReplVar"], "repairPatterns": ["copyPaste", "initFix", "wrongVarRef"]}
{"project": "Math", "bugId": 4, "problem": " public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector3D v1D = line.intersection(subLine.line);\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));", "fixed": " public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector3D v1D = line.intersection(subLine.line);\n        if (v1D == null) {\n            return null;\n        }\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));", "observations": "Almost a copy, the only difference is in involved variable.", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Mockito", "bugId": 37, "problem": " public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n     }\r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r", "fixed": " public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n        if (answer instanceof CallsRealMethods) {\r\n            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\r\n        }\r\n     }\r\n    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\r\n        if (invocation.getMethod().getDeclaringClass().isInterface()) {\r\n            reporter.cannotCallRealMethodOnInterface();\r\n        }\r\n    }\r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "mdAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Closure", "bugId": 60, "problem": " static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n       case Token.VOID:\n           return TernaryValue.FALSE;\n       case Token.NAME:\n         String name = n.getString();", "fixed": " static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n       case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n           return TernaryValue.FALSE;\n        }\n        break;\n       case Token.NAME:\n         String name = n.getString();", "observations": "", "repairActions": ["condBranCaseAdd", "condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIf"]}
{"project": "Mockito", "bugId": 5, "problem": " public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }", "fixed": " public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n            catch (AssertionError e) {\n                 error = handleVerifyException(e);\n             }\n         }", "observations": "Change parameter type in catch command.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n         int searchLen = searchChars.length;\n         outer:\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                         continue outer;\n                 }\n             }\n             return i;", "fixed": " public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n         outer:\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            continue outer;\n                        }\n                    } else {\n                         continue outer;\n                    }\n                 }\n             }\n             return i;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Lang", "bugId": 41, "problem": " public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n        return out;\n     }", "fixed": " public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n        return out + arrayPrefix;\n     }", "observations": "Existent condittional expression with null-check is expanded.", "repairActions": ["assignAdd", "condBranIfAdd", "condExpExpand", "loopAdd", "mcAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Lang", "bugId": 53, "problem": " private static void modify(Calendar val, int field, boolean round) {\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n            }\n         }\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         if (field == Calendar.MINUTE) {\n             done = true;\n            }\n         }", "fixed": " private static void modify(Calendar val, int field, boolean round) {\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n        }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n        }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }", "observations": "", "repairActions": [], "repairPatterns": ["codeMove", "copyPaste", "unwrapIfElse"]}
{"project": "Mockito", "bugId": 23, "problem": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return mock;\r\n     }\r\n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\r", "fixed": " public Object answer(InvocationOnMock invocation) throws Throwable {\n         return mock;\r\n     }\r\n\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\r\n\t}\r\n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n        int iter = 0;\n         for (boolean converged = false; !converged;) {\n            ++iter;\n             PointVectorValuePair previous = current;", "fixed": " public PointVectorValuePair doOptimize() {\n         PointVectorValuePair current = null;\n         for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n             PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 59, "problem": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);", "observations": "", "repairActions": ["mcParValChange", "varReplVar"], "repairPatterns": ["singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Chart", "bugId": 14, "problem": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "fixed": " public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r", "observations": "", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Math", "bugId": 16, "problem": "  */\n public class FastMath {\n     \n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "fixed": "  */\n public class FastMath {\n     \n    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n     \n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Math", "bugId": 14, "problem": "      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n     }\n     /**", "fixed": "      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n        weightMatrix = new DiagonalMatrix(weight);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "missComp", "wrapsIfElse"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                 double actRed = -1.0;", "fixed": " protected VectorialPointValuePair doOptimize()\n                 updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n                 double actRed = -1.0;", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Lang", "bugId": 40, "problem": " public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n        return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }", "fixed": " public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n     }", "observations": "", "repairActions": ["assignAdd", "loopAdd", "mcAdd", "mcRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrongComp"]}
{"project": "Math", "bugId": 68, "problem": " protected VectorialPointValuePair doOptimize()\n                 }\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n                        return new VectorialPointValuePair(point, objective);\n                     }", "fixed": " protected VectorialPointValuePair doOptimize()\n                 }\n                if (checker != null) {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;                        \n                    }\n                } else {\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                     }\n                }", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Closure", "bugId": 53, "problem": " private void replaceAssignmentExpression(Var v, Reference ref,\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);", "fixed": " private void replaceAssignmentExpression(Var v, Reference ref,\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n      }\n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 66, "problem": " private double localMin(boolean isMinim,\n                     }\n                 }\n} else {\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                 return x;\n             }\n            ++count;\n         }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }", "fixed": " private double localMin(boolean isMinim,\n                     }\n                 }\n} else {\n                setFunctionValue(isMinim ? fx : -fx);\n                 return x;\n             }\n            incrementIterationsCounter();\n         }\n     }\n }", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 46, "problem": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "fixed": " private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n            boolean escapeForwardSlash) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 88, "problem": " protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));", "fixed": " protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopRem", "mcAdd", "objInstAdd", "varAdd"], "repairPatterns": ["blockRemove", "condBlockRem", "wrapsIfElse", "wrongComp"]}
{"project": "Time", "bugId": 20, "problem": " public int estimateParsedLength() {\n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                 }\n             }\n             return ~position;\n         }\n     }", "fixed": " public int estimateParsedLength() {\n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n            String best = null;\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                 }\n             }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n             return ~position;\n         }\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missNullCheckN", "missNullCheckP"]}
{"project": "Chart", "bugId": 24, "problem": " public double getUpperBound() {\n     public Paint getPaint(double value) {\r\n         double v = Math.max(value, this.lowerBound);\r\n         v = Math.min(v, this.upperBound);\r\n        int g = (int) ((value - this.lowerBound) / (this.upperBound \r\n                 - this.lowerBound) * 255.0);\r\n         return new Color(g, g, g);\r\n     }\r", "fixed": " public double getUpperBound() {\n     public Paint getPaint(double value) {\r\n         double v = Math.max(value, this.lowerBound);\r\n         v = Math.min(v, this.upperBound);\r\n        int g = (int) ((v - this.lowerBound) / (this.upperBound \r\n                 - this.lowerBound) * 255.0);\r\n         return new Color(g, g, g);\r\n     }\r", "observations": "Replaces variable in an assignment expression.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["expArithMod", "singleLine", "wrongComp", "wrongVarRef"]}
{"project": "Lang", "bugId": 24, "problem": " public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                return foundDigit && !hasExp;\n             }\n             return false;", "fixed": " public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             return false;", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 9, "problem": " public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n         return reverted;\n     }", "fixed": " public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n        final Line reverted = new Line(this);\n        reverted.direction = reverted.direction.negate();\n         return reverted;\n     }", "observations": "Replaced constructor by overloaded version. Changes object attribute value by direct assignment.", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "objInstMod"], "repairPatterns": ["initFix", "wrongMethodRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n             setMillis(getChronology().years().add(getMillis(), years));\n     }", "fixed": " public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n        if (years != 0) {\n             setMillis(getChronology().years().add(getMillis(), years));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Mockito", "bugId": 14, "problem": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n         }\r\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r", "fixed": " public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n            }\r\n         }\r\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r", "observations": "An existing parameter (\"mode\") was wrapped by a constructor call, instantiating MockAwareVerificationMode object", "repairActions": ["condBranIfAdd", "mcAdd", "mcParValChange", "objInstAdd"], "repairPatterns": ["wrapsIf", "wrapsMethod"]}
{"project": "Mockito", "bugId": 6, "problem": " public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n        return reportMatcher(new InstanceOf(Short.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 9, "problem": " private void init() {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }", "fixed": " private void init() {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n        }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Lang", "bugId": 46, "problem": " public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false);\n     }\n     /**", "fixed": " public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false, false);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                     }\n                 }\n                 return minRow;\n         }\n         return minRatioPositions.get(0);\n     }", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                     }\n                 }\n                 return minRow;\n            }\n         }\n         return minRatioPositions.get(0);\n     }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 14, "problem": " private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "loopAdd", "loopRem", "mcAdd", "mcRem", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "missComp", "wrapsIfElse"]}
{"project": "Closure", "bugId": 80, "problem": " static boolean isBooleanResultHelper(Node n) {\n       case Token.NOT:\n         return true;\n       default:\n         return false;", "fixed": " static boolean isBooleanResultHelper(Node n) {\n       case Token.NOT:\n      case Token.DELPROP:\n         return true;\n       default:\n         return false;", "observations": "These blocks are inserted as extra switch clauses. Should be a \"Missing Condition\", \"Missing Block\" or both?", "repairActions": ["condBranCaseAdd"], "repairPatterns": ["expLogicExpand"]}
{"project": "Math", "bugId": 44, "problem": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                     return eventT;\n                 }", "fixed": " public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                     return eventT;\n                 }", "observations": "The variable and assignment adding are part of the for loop.", "repairActions": ["assignAdd", "assignRem", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["copyPaste", "missComp"]}
{"project": "Lang", "bugId": 33, "problem": " private static String toCanonicalName(String className) {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n         }\n         return classes;\n     }", "fixed": " private static String toCanonicalName(String className) {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i] == null ? null : array[i].getClass();\n         }\n         return classes;\n     }", "observations": "Wrap-with applied with IfElse-Expression", "repairActions": ["condBranIfElseAdd"], "repairPatterns": ["missNullCheckP", "singleLine", "wrapsIfElse"]}
{"project": "Math", "bugId": 92, "problem": " public static double binomialCoefficientLog(final int n, final int k) {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n         \n         /*\n          * Sum logs for values that could overflow", "fixed": " public static double binomialCoefficientLog(final int n, final int k) {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n        if (n < 67) {  \n            return Math.log(binomialCoefficient(n,k));\n        }\n         \n        if (n < 1030) { \n            return Math.log(binomialCoefficientDouble(n, k));\n        } \n         /*\n          * Sum logs for values that could overflow", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "exThrowsAdd", "exThrowsRem", "loopAdd", "mcAdd", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "varAdd"], "repairPatterns": ["blockRemove", "condBlockExcAdd", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 43, "problem": " private void identifyNameNode(\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n     \n     final Scope scope;\n     private final List<DeferredSetType> deferredSetTypes =\n         Lists.newArrayList();\n     \n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n     \n     \n     private final List<StubDeclaration> stubDeclarations =\n         Lists.newArrayList();\n     \n     private String sourceName = null;\n     \n     private InputId inputId;", "fixed": " private void identifyNameNode(\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n     \n     final Scope scope;\n     private final List<DeferredSetType> deferredSetTypes =\n         Lists.newArrayList();\n     \n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n     \n    private List<Node> lentObjectLiterals = null;\n     \n     private final List<StubDeclaration> stubDeclarations =\n         Lists.newArrayList();\n     \n     private String sourceName = null;\n     \n     private InputId inputId;", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Closure", "bugId": 76, "problem": " private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {", "fixed": " private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\nif (ControlFlowGraph.isEnteringNewCfgNode(n)) {\n      return VariableLiveness.MAYBE_LIVE;\n    }\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "condExpMod", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp", "missNullCheckN", "unwrapIfElse"]}
{"project": "Math", "bugId": 39, "problem": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n         for (int k = 1; k < stages; ++k) {", "fixed": " public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n         stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n         for (int k = 1; k < stages; ++k) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isLabelName());\n    Preconditions.checkState(finallyBody.isLabelName());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "fixed": " public static Node labelName(String name) {\n   }\n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Lang", "bugId": 16, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n             return null;\n         }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\nif (!stop) {\n                 if (checker != null) {\n                    stop = checker.converged(iter, previous, current);\n                 }\n             }\n             if (stop) {", "fixed": " protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\nif (!stop) {\n                 if (checker != null) {\n                    stop = checker.converged(getIterations(), previous, current);\n                 }\n             }\n             if (stop) {", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Math", "bugId": 15, "problem": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n     \n     private static final double F_1_3 = 1d / 3d;", "fixed": "     \n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     \n    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n     \n     private static final double F_1_3 = 1d / 3d;", "observations": "", "repairActions": ["assignAdd", "condExpMod", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 34, "problem": " public String toString() {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n     }\n }", "fixed": " public String toString() {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n        return getChromosomes().iterator();\n     }\n }", "observations": "A direct class attribute access was replaced by a method call that gives indirect access to the object.", "repairActions": ["mcAdd", "varReplMc"], "repairPatterns": ["missComp", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 129, "problem": " private void annotateCalls(Node n) {\n       Node first = n.getFirstChild();\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);", "fixed": " private void annotateCalls(Node n) {\n       Node first = n.getFirstChild();\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);", "observations": "Adds a loop to iterate over child of nodes.", "repairActions": ["assignAdd", "loopAdd", "mcAdd"], "repairPatterns": ["missComp", "notClassified"]}
{"project": "Math", "bugId": 78, "problem": " public boolean evaluateStep(final StepInterpolator interpolator)\n                 if (g0Positive ^ (gb >= 0)) {", "fixed": " public boolean evaluateStep(final StepInterpolator interpolator)\n                 if (g0Positive ^ (gb >= 0)) {\n                    if (ga * gb > 0) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp"]}
{"project": "Closure", "bugId": 109, "problem": " private Node parseTypeExpression(JsDocToken token) {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n   }\n   /**", "fixed": " private Node parseTypeExpression(JsDocToken token) {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n   }\n   /**", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "mcRepl", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockRetAdd", "wrapsIfElse", "wrongComp", "wrongMethodRef"]}
{"project": "Chart", "bugId": 10, "problem": " public StandardToolTipTagFragmentGenerator() {\n      * @return The formatted HTML area tag attribute(s).\r\n      */\r\n     public String generateToolTipFragment(String toolTipText) {\r\n        return \" title=\\\"\" + toolTipText\r\n             + \"\\\" alt=\\\"\\\"\";\r\n     }\r", "fixed": " public StandardToolTipTagFragmentGenerator() {\n      * @return The formatted HTML area tag attribute(s).\r\n      */\r\n     public String generateToolTipFragment(String toolTipText) {\r\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \r\n             + \"\\\" alt=\\\"\\\"\";\r\n     }\r", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsMethod"]}
{"project": "Closure", "bugId": 107, "problem": " protected CompilerOptions createOptions() {\n       options.messageBundle = new EmptyMessageBundle();\n     }\n     return options;", "fixed": " protected CompilerOptions createOptions() {\n       options.messageBundle = new EmptyMessageBundle();\n      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n     }\n     return options;", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];", "fixed": " protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n        double[] oldObj  = new double[rows];\n        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 116, "problem": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\n     Node cArg = callNode.getFirstChild().getNext();", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\nboolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(\n            stmt.getFirstChild(), compiler);\n      }\n    }\n     Node cArg = callNode.getFirstChild().getNext();", "observations": "Strange... what is removed in 115 is added again in 116.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 52, "problem": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n    if (c == 0) {\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n      if (c == 0) {\n         q0 = 1.0;", "fixed": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n      if (c <= 0) {\n         q0 = 1.0;", "observations": "New variable is added with its initialization.", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Lang", "bugId": 18, "problem": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                     rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\ncase 'M':", "fixed": " private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\ncase 'y':\n                if (tokenLen == 2) {\n                     rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                 }\n                 break;\ncase 'M':", "observations": "An existent if-else structure is removed and a new one is placed in an action that resembles a wrap-with replacement. An aditional wrap-with-IfElse is present in IfElse-CondExp form.", "repairActions": ["condBranIfElseAdd", "condExpMod", "mcParValChange"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static String anyString() {\n      * @return empty List.\r\n      */\r\n     public static List anyList() {\r\n        return reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static String anyString() {\n      * @return empty List.\r\n      */\r\n     public static List anyList() {\r\n        return reportMatcher(new InstanceOf(List.class)).returnList();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 59, "problem": " public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n     }\n     /** Compute the maximum of two values", "fixed": " public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n     /** Compute the maximum of two values", "observations": "", "repairActions": ["retExpChange", "varReplVar"], "repairPatterns": ["singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 30, "problem": "   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n     Definition(Node node) {\n       this.node = node;", "fixed": "   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n    private boolean unknownDependencies = false;\n     Definition(Node node) {\n       this.node = node;", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Math", "bugId": 66, "problem": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n     }\n     /**", "fixed": "      * Construct a solver.\n      */\n     public BrentOptimizer() {\n        setMaxEvaluations(1000);\n         setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1e-11);\n        setRelativeAccuracy(1e-9);\n     }\n     /**", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "condExpMod", "exThrowsRem", "loopCondChange", "mcAdd", "mcParRem", "mcParValChange", "mcRem", "mcRepl", "mdOverride", "mdParRem", "mdRem", "objInstRem", "retExpChange", "retRem", "varAdd", "varRem", "varReplMc"], "repairPatterns": ["constChange", "expLogicMod", "initFix", "wrongComp", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 6, "problem": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, Node owner, String propName) {\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {", "fixed": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, Node owner, String propName) {\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {", "observations": "", "repairActions": ["condBranRem", "mcRem"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Chart", "bugId": 4, "problem": " public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r", "fixed": " public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                if (r != null) {\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Math", "bugId": 52, "problem": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  if (c == 0) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "fixed": " public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);", "observations": "New variable is added with its initialization.", "repairActions": ["assignAdd", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expLogicMod", "initFix"]}
{"project": "Math", "bugId": 6, "problem": " protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n         evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n     }\n     /**", "fixed": " protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n         evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n     }\n     /**", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 24, "problem": " public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');", "fixed": " public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd"]}
{"project": "Mockito", "bugId": 12, "problem": " public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n                 return (Class) actual;\r\n         }\r\n         return Object.class;\r", "fixed": " public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n            if (actual instanceof Class) {\r\n                 return (Class) actual;\r\n            } else if (actual instanceof ParameterizedType) {\r\n                return (Class) ((ParameterizedType) actual).getRawType();\r\n            }\r\n         }\r\n         return Object.class;\r", "observations": "", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Math", "bugId": 83, "problem": " private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n        int start = getNumObjectiveFunctions();\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;", "fixed": " private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;", "observations": "The added \"WrapWith\" uses \"exp?a:b\" format.", "repairActions": ["assignExpChange", "condBranIfElseAdd", "mcRepl"], "repairPatterns": ["wrapsIfElse", "wrongMethodRef"]}
{"project": "Lang", "bugId": 2, "problem": " public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "fixed": " public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n        if (str.contains(\"\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Chart", "bugId": 25, "problem": " protected void drawVerticalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "fixed": " protected void drawVerticalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n        if (meanValue == null) {\r\n            return;\r\n        }\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 36, "problem": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n         return result;\n     }", "fixed": " public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n        if (Double.isNaN(result)) {\n            int shift = Math.max(numerator.bitLength(),\n                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n            result = numerator.shiftRight(shift).floatValue() /\n                denominator.shiftRight(shift).floatValue();\n        }\n         return result;\n     }", "observations": "The change is almost the same in two different places. The only difference between changes is the use of the call \"doubleValue()\" in place of \"floatValue()\" in correspondent methods.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Lang", "bugId": 7, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\nint hexDigits = str.length() - 2;\nif (str.startsWith(\"-\")) {", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\nint hexDigits = str.length() - 2;\nif (str.startsWith(\"-\")) {", "observations": "In one of the chunks, removes a conditional block with return.", "repairActions": ["condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem"], "repairPatterns": ["blockRemove", "condBlockExcAdd", "condBlockRem"]}
{"project": "Math", "bugId": 62, "problem": " public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         for (int i = 0; i < starts; ++i) {\n             try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {", "fixed": " public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         for (int i = 0; i < starts; ++i) {\n             try {\n                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, min, max, s);\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {", "observations": "Changes the way to compute \"optima[i]\", changing params for call to \"optimize\". Removed if-branch is in the form \"exp?a:b\".", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "condBranRem", "mcAdd", "mcParAdd", "mcParValChange", "mcRem", "mcRepl", "retExpChange", "varAdd", "varRem"], "repairPatterns": ["expArithMod", "wrongComp", "wrongMethodRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Map anyMap() {\n      * @return empty Map.\r\n      */\r\n     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\r\n        return reportMatcher(Any.ANY).returnMap();\r\n     }\r\n     /**\r", "fixed": " public static Map anyMap() {\n      * @return empty Map.\r\n      */\r\n     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\r\n        return anyMap();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 57, "problem": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "fixed": " public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);", "observations": "Just changed the declared type of a primitive variable.", "repairActions": ["varTyChange"], "repairPatterns": ["singleLine"]}
{"project": "Mockito", "bugId": 35, "problem": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T eq(T value) {\r\n        return reportMatcher(new Equals(value)).<T>returnNull();\r\n     }  \r\n     /**\r", "fixed": " public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T eq(T value) {\r\n        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());\r\n     }  \r\n     /**\r", "observations": "", "repairActions": ["mcAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Lang", "bugId": 4, "problem": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "fixed": "  */\n public class LookupTranslator extends CharSequenceTranslator {\n    private final HashMap<String, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Mockito", "bugId": 18, "problem": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "fixed": " Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {", "observations": "Returns instantiated ArrayList<Object>", "repairActions": ["condBranIfAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 58, "problem": " public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n     }\n     /**", "fixed": " public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n     }\n     /**", "observations": "Call overloaded method without one parameter.", "repairActions": ["mcParRem", "mcRepl", "objInstRem", "retExpChange"], "repairPatterns": ["singleLine", "wrongMethodRef"]}
{"project": "Closure", "bugId": 37, "problem": " Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n       Node bodyNode = transform(functionNode.getBody());\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;", "fixed": " Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n       Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;", "observations": "Replaces method call by overloaded method with extra parameters.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["condBlockOthersAdd", "wrongMethodRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setMonthOfYear(final int monthOfYear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n             setMillis(getChronology().months().add(getMillis(), months));\n     }", "fixed": " public void setMonthOfYear(final int monthOfYear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n        if (months != 0) {\n             setMillis(getChronology().months().add(getMillis(), months));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 9, "problem": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "fixed": " public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n    filename = filename.replace(\"\\\\\", \"/\");\n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["missComp", "unwrapMethod"]}
{"project": "Math", "bugId": 68, "problem": " public LevenbergMarquardtOptimizer() {\n         setMaxIterations(1000);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);", "fixed": " public LevenbergMarquardtOptimizer() {\n         setMaxIterations(1000);\n        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);", "observations": "New objects were instantiated. Objects instantiated before were removed too (line 419).", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "objInstAdd", "objInstRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrapsIfElse"]}
{"project": "Math", "bugId": 21, "problem": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "fixed": " public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 116, "problem": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }", "observations": "Strange... what is removed in 115 is added again in 116.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Chart", "bugId": 22, "problem": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n        if (row >= 0) {\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n         }\r\n         else {\r\n             return null;\r", "fixed": " public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n        int index = rowData.getIndex(columnKey);\r\n        if (index >= 0) {\r\n            return rowData.getObject(index);\r\n         }\r\n         else {\r\n             return null;\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 2, "problem": " private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {", "fixed": " private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd"], "repairPatterns": ["missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 5, "problem": " public Complex reciprocal() {\n         }\n         if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n         }\n         if (isInfinite) {", "fixed": " public Complex reciprocal() {\n         }\n         if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n         }\n         if (isInfinite) {", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange", "expArithMod", "singleLine"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         }\n         PointValuePair current = null;\n        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n            ++iter;\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }", "fixed": " protected PointValuePair doOptimize() {\n         }\n         PointValuePair current = null;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n            incrementIterationCount();\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                     return current;\n                 }", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 2, "problem": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {", "fixed": " public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Time", "bugId": 13, "problem": " public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                sum = Math.max(sum, 4);\n                 sum++;\n                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&", "fixed": " public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));\n                 sum++;\n                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expArithMod", "wrapsIfElse"]}
{"project": "Time", "bugId": 3, "problem": " public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n             setMillis(getChronology().days().add(getMillis(), days));\n     }", "fixed": " public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n        if (days != 0) {\n             setMillis(getChronology().days().add(getMillis(), days));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Lang", "bugId": 8, "problem": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;", "fixed": " static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;", "observations": "Transformed a class attribute in local var.", "repairActions": ["assignAdd", "assignRem", "mcAdd", "varAdd", "varRem"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {", "fixed": " private void findAliases(NodeTraversal t) {\n          if (isFunctionDecl) {\n            Node existingName = v.getNameNode();", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 81, "problem": " private void computeGershgorinCircles() {\n         lowerSpectra = Math.min(lowerSpectra, lower);\n         final double upper = dCurrent + eCurrent;\n         work[upperStart + m - 1] = upper;\n         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n     }", "fixed": " private void computeGershgorinCircles() {\n         lowerSpectra = Math.min(lowerSpectra, lower);\n         final double upper = dCurrent + eCurrent;\n         work[upperStart + m - 1] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n     }", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Closure", "bugId": 100, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN", "wrongComp"]}
{"project": "Time", "bugId": 2, "problem": " public Partial with(DateTimeFieldType fieldType, int value) {\n                         if (compare > 0) {\n                             break;\n                         } else if (compare == 0) {\n                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                             if (rangeField.compareTo(loopRangeField) > 0) {", "fixed": " public Partial with(DateTimeFieldType fieldType, int value) {\n                         if (compare > 0) {\n                             break;\n                         } else if (compare == 0) {\n                            if (fieldType.getRangeDurationType() == null) {\n                                break;\n                            }\n                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                             if (rangeField.compareTo(loopRangeField) > 0) {", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Math", "bugId": 79, "problem": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "fixed": " public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);", "observations": "", "repairActions": ["varTyChange"], "repairPatterns": ["notClassified"]}
{"project": "Closure", "bugId": 6, "problem": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n       mismatch(t, n, msg, rightType, leftType);\n      }\n       return false;\n     }\n     return true;", "fixed": " boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n       mismatch(t, n, msg, rightType, leftType);\n       return false;\n     }\n     return true;", "observations": "", "repairActions": ["condBranRem", "mcRem"], "repairPatterns": ["copyPaste", "unwrapIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n        return reportMatcher(Any.ANY).returnMap();\r\n     }\r\n     /**\r", "fixed": " public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n        return reportMatcher(new InstanceOf(Map.class)).returnMap();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 37, "problem": " private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n     traverseBranch(body, n);\n     popScope();", "fixed": " private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n     traverseBranch(body, n);\n     popScope();", "observations": "Replaces method call by overloaded method with extra parameters.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParAdd", "mcRepl"], "repairPatterns": ["condBlockOthersAdd", "wrongMethodRef"]}
{"project": "Closure", "bugId": 110, "problem": " private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {", "fixed": " private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "expLogicExpand", "expLogicMod", "initFix", "missNullCheckN", "missNullCheckP", "wrapsIfElse"]}
{"project": "Math", "bugId": 101, "problem": " public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n        if (\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {", "fixed": " public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Math", "bugId": 105, "problem": " public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n     }\n     /**", "fixed": " public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n     }\n     /**", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["singleLine", "wrapsMethod"]}
{"project": "Math", "bugId": 41, "problem": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }", "fixed": " public double evaluate(final double[] values, final double[] weights,\n                 }\n                 double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }", "observations": "The changes were made only inside the for loop.", "repairActions": ["assignExpChange", "loopCondChange", "loopInitChange", "varReplVar"], "repairPatterns": ["initFix", "singleLine", "wrongVarRef"]}
{"project": "Closure", "bugId": 55, "problem": " public Node parseHelperCode(Reducer reducer) {\n   }\n   private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n   }\n   /**", "fixed": " public Node parseHelperCode(Reducer reducer) {\n   }\n   private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n)\n        && !NodeUtil.isGetOrSetKey(n.getParent());\n   }\n   /**", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Lang", "bugId": 10, "problem": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "fixed": " public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n             switch(c) {\n             case '\\'':\n                 if(unquote) {", "observations": "", "repairActions": ["assignRem", "condBranIfAdd", "mcRem", "varRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Lang", "bugId": 47, "problem": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);", "fixed": " public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missNullCheckP"]}
{"project": "Lang", "bugId": 44, "problem": " public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n         if (val.startsWith(\"--\")) {", "fixed": " public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n         if (val.startsWith(\"--\")) {", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Time", "bugId": 14, "problem": " public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {", "fixed": " public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Mockito", "bugId": 17, "problem": " public MockUtil() {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\r\n         Class<?>[] ancillaryTypes;\r\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\r\n         Object spiedInstance = settings.getSpiedInstance();\r", "fixed": " public MockUtil() {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\r\n         Class<?>[] ancillaryTypes;\r\n        if (settings.isSerializable()) {\r\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\r\n        } else {\r\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\r\n        }\r\n         Object spiedInstance = settings.getSpiedInstance();\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Math", "bugId": 84, "problem": " public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n         while (true) {\n             incrementIterationsCounter();", "fixed": " public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n             incrementIterationsCounter();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Closure", "bugId": 41, "problem": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "fixed": " FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp", "missNullCheckN"]}
{"project": "Math", "bugId": 93, "problem": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        long result = Math.round(factorialDouble(n));\n        if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "fixed": " public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }", "observations": "", "repairActions": ["condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varRem"], "repairPatterns": ["condBlockExcAdd", "condBlockRetAdd", "expLogicMod", "missComp", "wrongComp"]}
{"project": "Math", "bugId": 6, "problem": " public PointVectorValuePair doOptimize() {\n             if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;", "fixed": " public PointVectorValuePair doOptimize() {\n             if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 51, "problem": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "fixed": " void addNumber(double x) {\n       add(\" \");\n     }\n    if ((long) x == x && !isNegativeZero(x)) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n         int searchLen = searchChars.length;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                         return i;\n                 }\n             }\n         }", "fixed": " public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return i;\n                        }\n                    } else {\n                         return i;\n                    }\n                 }\n             }\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 6, "problem": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(Any.ANY).returnFalse();\r\n     }\r\n     /**\r", "fixed": "      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 89, "problem": " private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n     Node nameNode = NodeUtil.newName(", "fixed": " private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n    }\n     Node nameNode = NodeUtil.newName(", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missNullCheckN"]}
{"project": "Chart", "bugId": 18, "problem": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n                 rowData.removeValue(columnKey);\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "fixed": " public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n    \tif (columnKey == null) {\r\n    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\r\n    \t}\r\n    \tif (!this.columnKeys.contains(columnKey)) {\r\n    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\r\n    \t}\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n            int index = rowData.getIndex(columnKey);\r\n            if (index >= 0) {\r\n                 rowData.removeValue(columnKey);\r\n            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n     \r", "observations": "Replaces return point by throw exception.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "mcAdd", "mcRem", "objInstAdd", "retRem", "varAdd"], "repairPatterns": ["condBlockExcAdd", "missNullCheckP", "unwrapIfElse", "wrapsIf"]}
{"project": "Chart", "bugId": 26, "problem": " else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n         }\r\n         return state;\r", "fixed": " else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n            if (owner != null) {\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n            }\r\n         }\r\n         return state;\r", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["missNullCheckN", "wrapsIf"]}
{"project": "Math", "bugId": 90, "problem": " public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());", "fixed": " public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());", "observations": "Added a new overloaded method reusing part of the implementation of an existing one. The old method just call the new one.", "repairActions": ["mcAdd", "mdAdd"], "repairPatterns": ["notClassified"]}
{"project": "Time", "bugId": 19, "problem": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);", "fixed": " public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);", "observations": "", "repairActions": ["condExpMod"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Mockito", "bugId": 20, "problem": " public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));", "fixed": " public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n         T mockInstance = null;\n         try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));", "observations": "Instantiates an InstantiatonProvider object", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRepl", "objInstAdd", "varAdd", "varReplVar"], "repairPatterns": ["wrongVarRef"]}
{"project": "Math", "bugId": 16, "problem": " public static double cosh(double x) {\n       if (x > 20) {\n               return 0.5 * exp(x);\n           }\n      if (x < -20) {\n               return 0.5 * exp(-x);\n       }\n       final double hiPrec[] = new double[2];", "fixed": " public static double cosh(double x) {\n       if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n               return 0.5 * exp(x);\n           }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              final double t = exp(-0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n               return 0.5 * exp(-x);\n          }\n       }\n       final double hiPrec[] = new double[2];", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["copyPaste", "wrapsIfElse"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n         }\r\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "fixed": "else if (lclip <= 0.0) {\n         }\r\n        Number n = dataset.getStdDevValue(row, column);\r\n        if (n != null) {\r\n            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Collection anyCollection() {\n      * @return empty Collection.\r\n      */\r\n     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\r\n        return (Collection) reportMatcher(Any.ANY).returnList();\r\n     }    \r\n     /**\r", "fixed": " public static Collection anyCollection() {\n      * @return empty Collection.\r\n      */\r\n     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\r\n        return anyCollection();\r\n     }    \r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n        return (Set) reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n        return anySet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                 }", "fixed": " protected VectorialPointValuePair doOptimize()\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                 }", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static long anyLong() {\n      * @return <code>0</code>.\r\n      */\r\n     public static float anyFloat() {\r\n        return reportMatcher(Any.ANY).returnZero();\r\n     }\r\n     /**\r", "fixed": " public static long anyLong() {\n      * @return <code>0</code>.\r\n      */\r\n     public static float anyFloat() {\r\n        return reportMatcher(new InstanceOf(Float.class)).returnZero();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Lang", "bugId": 38, "problem": " public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }", "fixed": " public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\ncalendar.getTime();\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }", "observations": "", "repairActions": ["mcAdd"], "repairPatterns": ["missComp", "singleLine"]}
{"project": "Lang", "bugId": 46, "problem": " public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n        return escapeJavaStyleString(str, true);\n     }\n     /**", "fixed": " public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n        return escapeJavaStyleString(str, true, true);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Chart", "bugId": 2, "problem": " public static Range iterateRangeBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                     double lvalue = ixyd.getStartYValue(series, item);\r\n                     double uvalue = ixyd.getEndYValue(series, item);\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "fixed": " public static Range iterateRangeBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                    double value = ixyd.getYValue(series, item);\r\n                     double lvalue = ixyd.getStartYValue(series, item);\r\n                     double uvalue = ixyd.getEndYValue(series, item);\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum = Math.min(minimum, value);\r\n                        maximum = Math.max(maximum, value);\r\n                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Closure", "bugId": 95, "problem": " void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n       Scope scopeToDeclareIn = scope;\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {", "fixed": " void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n       Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "missComp"]}
{"project": "Mockito", "bugId": 20, "problem": " public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"", "fixed": " public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"", "observations": "Instantiates an InstantiatonProvider object", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRepl", "objInstAdd", "varAdd", "varReplVar"], "repairPatterns": ["wrongVarRef"]}
{"project": "Closure", "bugId": 49, "problem": " public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n     if (declarationRoot.getType() != Token.FUNCTION) {\n       findDeclaredNames(declarationRoot, null, renamer);", "fixed": " public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() != Token.FUNCTION) {\n       findDeclaredNames(declarationRoot, null, renamer);", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranCaseAdd", "condBranRem", "loopAdd", "loopRem", "mcAdd", "mcRem", "varAdd", "varRem"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Closure", "bugId": 54, "problem": " public void setPrototypeBasedOn(ObjectType baseType) {\n     if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {", "fixed": " public void setPrototypeBasedOn(ObjectType baseType) {\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 17, "problem": " private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();", "fixed": " private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                 return rValue.getJSType();", "observations": "Transform If structure in Wrap-with IfElse.", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN"]}
{"project": "Lang", "bugId": 4, "problem": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "fixed": " public int translate(final CharSequence input, final int index, final Writer out\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n            final CharSequence result = lookupMap.get(subSeq.toString());\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;", "observations": "Type change with adjust in related calls/operations.", "repairActions": ["assignExpChange", "mcAdd", "objInstMod", "varReplMc", "varTyChange"], "repairPatterns": ["initFix", "wrongVarRef"]}
{"project": "Lang", "bugId": 30, "problem": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "fixed": " public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpExpand", "condExpMod", "condExpRed", "mcAdd", "mcRem", "mdParTyChange", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "copyPaste", "expLogicExpand", "expLogicMod", "missComp", "wrapsIf", "wrapsIfElse"]}
{"project": "Math", "bugId": 71, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n                 loop     = false;\n             } else {", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n                interpolator.storeTime(stepStart);\n                System.arraycopy(y, 0, yTmp, 0, y0.length);\n                stepSize = 0;\n                 loop     = false;\n             } else {", "observations": "Three lines equal lines are added in two different places. Just line 302 is different.", "repairActions": ["assignAdd", "mcAdd"], "repairPatterns": ["copyPaste"]}
{"project": "Mockito", "bugId": 9, "problem": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "fixed": "     private static final long serialVersionUID = 9057165148930624087L;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n    \t}\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 102, "problem": " private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }", "fixed": " private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }", "observations": "", "repairActions": ["mcMove"], "repairPatterns": ["codeMove", "singleLine"]}
{"project": "Mockito", "bugId": 19, "problem": "  * </ul>\n  */\n public class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n         if(mocks.size() == 1) {\n             final Object matchingMock = mocks.iterator().next();", "fixed": "  * </ul>\n  */\n public class FinalMockCandidateFilter implements MockCandidateFilter {\n    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {\n         if(mocks.size() == 1) {\n             final Object matchingMock = mocks.iterator().next();", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Math", "bugId": 6, "problem": " protected PointVectorValuePair doOptimize() {\n         lmPar = 0;\n         boolean firstIteration = true;\n        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n            ++iter;\n             final PointVectorValuePair previous = current;", "fixed": " protected PointVectorValuePair doOptimize() {\n         lmPar = 0;\n         boolean firstIteration = true;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n            incrementIterationCount();\n             final PointVectorValuePair previous = current;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 115, "problem": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n       if (fnParam != null) {\n         if (cArg != null) {", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "condBlockRem"]}
{"project": "Time", "bugId": 2, "problem": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n         return 0;\n     }", "fixed": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n         return 0;\n     }", "observations": "", "repairActions": ["condBranIfAdd", "condExpRed", "mcAdd", "mcRem", "retBranchAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "expLogicReduce", "missNullCheckP"]}
{"project": "Math", "bugId": 18, "problem": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n             }\n             return res;\n         }", "fixed": " public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i];\n             }\n             return res;\n         }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condExpMod", "mcAdd", "varAdd"], "repairPatterns": ["expArithMod", "expLogicMod", "wrongComp"]}
{"project": "Closure", "bugId": 45, "problem": " private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;", "fixed": " private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n          boolean maybeEscaped = false;\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condExpExpand", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "initFix", "wrongMethodRef"]}
{"project": "Math", "bugId": 13, "problem": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n     }\n }", "fixed": " protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n        }\n     }\n }", "observations": "Contains the patch of Math-13", "repairActions": ["assignAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "objInstAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["missComp", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 27, "problem": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\r\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "fixed": " public MockUtil() {\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r", "observations": "", "repairActions": ["assignExpChange", "mcAdd", "mcRem", "objInstRem", "varRem"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Math", "bugId": 31, "problem": " public double evaluate(double x, double epsilon, int maxIterations) {\n                 break;\n             }\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n             n++;\n         }", "fixed": " public double evaluate(double x, double epsilon, int maxIterations) {\n                 break;\n             }\n            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN;\n             n++;\n         }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranRem", "exThrowsRem", "loopRem", "mcAdd", "mcRem", "objInstRem", "varAdd", "varRem", "varReplVar"], "repairPatterns": ["blockRemove", "condBlockOthersAdd", "condBlockRem", "expArithMod", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 19, "problem": " public NameBasedCandidateFilter(MockCandidateFilter next) {\n \t}\n \tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, Object fieldInstance) {\n \t\tList<Object> mockNameMatches = new ArrayList<Object>();\n \t\tif (mocks.size() > 1) {\n \t\t\tfor (Object mock : mocks) {", "fixed": " public NameBasedCandidateFilter(MockCandidateFilter next) {\n \t}\n \tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n\t\t\tField field, List<Field> fields, Object fieldInstance) {\n \t\tList<Object> mockNameMatches = new ArrayList<Object>();\n \t\tif (mocks.size() > 1) {\n \t\t\tfor (Object mock : mocks) {", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Time", "bugId": 13, "problem": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }", "fixed": " public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n                        buf.insert(bufLen, '-');\n                    }\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expArithMod", "wrapsIfElse"]}
{"project": "Lang", "bugId": 54, "problem": " public static Locale toLocale(String str) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             char ch3 = str.charAt(3);\n             char ch4 = str.charAt(4);\n             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "fixed": " public static Locale toLocale(String str) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n             char ch4 = str.charAt(4);\n             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missComp"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                 return current;\n             }", "fixed": " protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n            \tupdateResidualsAndCost();\n            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Time", "bugId": 23, "problem": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "fixed": " private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");", "observations": "Changes entries in a key-value map.", "repairActions": ["mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Closure", "bugId": 61, "problem": " static boolean functionCallHasSideEffects(\n       }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "fixed": " static boolean functionCallHasSideEffects(\n       }\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Closure", "bugId": 30, "problem": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n   @Override", "fixed": " public void exitScope(NodeTraversal t) {}\n   @Override\n   public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n   @Override", "observations": "Adds a new class attribute with its initialization.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcParAdd", "mcRem", "mcRepl", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expLogicReduce", "initFix", "missNullCheckP", "wrapsIfElse", "wrongMethodRef"]}
{"project": "Time", "bugId": 26, "problem": " public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }", "fixed": " public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Lang", "bugId": 11, "problem": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n         }\n         char[] buffer = new char[count];", "fixed": " public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n        } else {\n            if (end <= start) {\n                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n            }\n         }\n         char[] buffer = new char[count];", "observations": "", "repairActions": ["condBranElseAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd"]}
{"project": "Math", "bugId": 6, "problem": " protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n        int iter = 0;\n         while (true) {\n            ++iter;\n             double fX = fVal;\n             double fX2 = 0;", "fixed": " protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n         while (true) {\n            incrementIterationCount();\n             double fX = fVal;\n             double fX2 = 0;", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Mockito", "bugId": 6, "problem": " public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n        return reportMatcher(Any.ANY).returnString();\r\n     }\r\n     /**\r", "fixed": " public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n        return reportMatcher(new InstanceOf(String.class)).returnString();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Closure", "bugId": 15, "problem": " public boolean apply(Node n) {\n           return true;\n         }\n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {", "fixed": " public boolean apply(Node n) {\n           return true;\n         }\n        if (n.isDelProp()) {\n          return true;\n        }\n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Math", "bugId": 37, "problem": " public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n        if (isNaN) {\n             return NaN;\n         }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);", "fixed": " public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n             return NaN;\n         }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);", "observations": "The changes are almost the same in two different places... same structure, but with variattions in the parameters/arguments.", "repairActions": ["condBranIfAdd", "condExpExpand", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "expLogicExpand", "missComp"]}
{"project": "Lang", "bugId": 31, "problem": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n \t\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t}", "fixed": " public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n \t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}", "observations": "Partially the same as Lang 30", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "missComp", "wrapsIfElse"]}
{"project": "Mockito", "bugId": 32, "problem": " public void process(Class<?> context, Object testClass) {\n                         Mockito.reset(instance);\r\n                     } else {\r\n                        field.set(testClass, Mockito.spy(instance));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r", "fixed": " public void process(Class<?> context, Object testClass) {\n                         Mockito.reset(instance);\r\n                     } else {\r\n                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\r\n                                .spiedInstance(instance)\r\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\r\n                                .name(field.getName())));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r", "observations": "", "repairActions": ["mcParValChange", "mcRepl"], "repairPatterns": ["missComp", "wrongMethodRef"]}
{"project": "Chart", "bugId": 25, "problem": " protected void drawHorizontalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "fixed": " protected void drawHorizontalItem(Graphics2D g2,\n         Number meanValue = dataset.getMeanValue(row, column);\r\n        if (meanValue == null) {\r\n            return;\r\n        }\r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 45, "problem": "      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);", "fixed": "      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n        long lRow = (long) rowDimension;\n        long lCol = (long) columnDimension;\n        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "objInstAdd", "varAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Lang", "bugId": 14, "problem": " public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n             return cs1.equals(cs2);\n     }\n     /**", "fixed": " public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n        if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Math", "bugId": 24, "problem": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return current;\n             }\n             ++iter;\n         }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["copyPaste", "wrapsMethod"]}
{"project": "Closure", "bugId": 3, "problem": " private Node getDefCfgNode() {\n       return defMetadata.node;\n     }\n    private boolean canInline() {\n       if (getDefCfgNode().isFunction()) {\n         return false;", "fixed": " private Node getDefCfgNode() {\n       return defMetadata.node;\n     }\n    private boolean canInline(final Scope scope) {\n       if (getDefCfgNode().isFunction()) {\n         return false;", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "condExpMod", "mcAdd", "mcParAdd", "mcRepl", "mdParAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Chart", "bugId": 25, "problem": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "fixed": "else if (lclip <= 0.0) {\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n        }\r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "mcAdd", "mcRem", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckN", "missNullCheckP", "wrapsIf", "wrongComp"]}
{"project": "Math", "bugId": 89, "problem": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n             addValue((Comparable<?>) v);            \n     }\n     /**", "fixed": " public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n        } else {\n            throw new IllegalArgumentException(\"Object must implement Comparable\");\n        }\n     }\n     /**", "observations": "", "repairActions": ["condBranIfElseAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Lang", "bugId": 41, "problem": " public static String getPackageName(Class<?> cls) {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n        if (className == null) {\n             return StringUtils.EMPTY;\n         }\n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {", "fixed": " public static String getPackageName(Class<?> cls) {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n        if (className == null || className.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n        while (className.charAt(0) == '[') {\n            className = className.substring(1);\n        }\n        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n            className = className.substring(1);\n        }\n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {", "observations": "Existent condittional expression with null-check is expanded.", "repairActions": ["assignAdd", "condBranIfAdd", "condExpExpand", "loopAdd", "mcAdd", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Math", "bugId": 104, "problem": "     private static final long serialVersionUID = -6587513359895466954L;\n     \n    private static final double DEFAULT_EPSILON = 10e-9;\n     \n     private static double[] lanczos =", "fixed": "     private static final long serialVersionUID = -6587513359895466954L;\n     \n    private static final double DEFAULT_EPSILON = 10e-15;\n     \n     private static double[] lanczos =", "observations": "", "repairActions": ["assignExpChange"], "repairPatterns": ["constChange", "initFix", "singleLine"]}
{"project": "Closure", "bugId": 59, "problem": " public void initOptions(CompilerOptions options) {\n           CheckLevel.OFF);\n     }\n    if (options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);", "fixed": " public void initOptions(CompilerOptions options) {\n           CheckLevel.OFF);\n     }\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Chart", "bugId": 19, "problem": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "fixed": " public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "copyPaste", "missNullCheckP"]}
{"project": "Closure", "bugId": 52, "problem": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0;\n   }\n   static double getSimpleNumber(String s) {", "fixed": " static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n    return len > 0 && s.charAt(0) != '0';\n   }\n   static double getSimpleNumber(String s) {", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 75, "problem": " static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\ncase '\\u000B':\n        return TernaryValue.TRUE;\ncase ' ':\ncase '\\n':\ncase '\\r':", "fixed": " static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\ncase '\\u000B':\nreturn TernaryValue.UNKNOWN;\ncase ' ':\ncase '\\n':\ncase '\\r':", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd", "retExpChange", "varReplVar"], "repairPatterns": ["condBlockRetAdd", "constChange", "wrongVarRef"]}
{"project": "Math", "bugId": 49, "problem": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "fixed": " public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));", "observations": "Changed the target of a iterator access.", "repairActions": ["assignExpChange", "varReplVar"], "repairPatterns": ["copyPaste", "wrongVarRef"]}
{"project": "Math", "bugId": 55, "problem": " public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n   }", "fixed": " public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n   }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "mcParValChange", "objInstMod", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "expArithMod", "initFix", "wrongComp"]}
{"project": "Math", "bugId": 64, "problem": " protected VectorialPointValuePair doOptimize()\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n                 } else {\n                     cost = previousCost;", "fixed": " protected VectorialPointValuePair doOptimize()\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n                    current = new VectorialPointValuePair(point, objective);\n                    if (checker != null) {\n                    \tif (checker.converged(getIterations(), previous, current)) {\n                    \t\treturn current;\n                    \t}\n                    }\n                 } else {\n                     cost = previousCost;", "observations": "Moved instantiation of object of type VectorialPointValuePair to another place (lines ahead).", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranRem", "loopAdd", "mcAdd", "mcMove", "mcParValChange", "mcRem", "objInstAdd", "objInstRem", "retBranchAdd", "retRem", "varAdd", "varReplVar"], "repairPatterns": ["blockRemove", "codeMove", "condBlockOthersAdd", "condBlockRem", "condBlockRetAdd", "expArithMod", "missNullCheckN", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 99, "problem": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n             return false;\n           }\n       }\n     }", "fixed": " public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n        if (NodeUtil.isGet(lhs)) {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n        }\n       }\n     }", "observations": "Changed condition in expression, adds an extra computing in line 131.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "expLogicMod", "wrapsIf"]}
{"project": "Math", "bugId": 81, "problem": " private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             work[i + 2]  = -sigma;", "fixed": " private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             work[i + 2]  = -sigma;", "observations": "Fix/updates assignment to var upperSpectra.", "repairActions": ["assignAdd", "condExpMod", "loopCondChange", "mcAdd"], "repairPatterns": ["constChange", "expArithMod", "expLogicMod", "missComp"]}
{"project": "Chart", "bugId": 2, "problem": " public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "fixed": " public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n                    double value = intervalXYData.getXValue(series, item);\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n                    if (!Double.isNaN(value)) {\r\n                        minimum = Math.min(minimum, value);\r\n                        maximum = Math.max(maximum, value);\r\n                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "mcAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "copyPaste", "missComp"]}
{"project": "Mockito", "bugId": 21, "problem": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withOuterClass(cls);\n     }\n    private <T> T withOuterClass(Class<T> cls) {\n         try {\n            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n            return c.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "fixed": " public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n        return withParams(cls, outerClassInstance);\n     }\n    private static <T> T withParams(Class<T> cls, Object... params) {\n         try {\n            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n                Class<?>[] types = constructor.getParameterTypes();\n                if (paramsMatch(types, params)) {\n                    return (T) constructor.newInstance(params);\n                }\n            }\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n        throw paramsException(cls, null);\n     }\n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {", "observations": "Apply \"static\" modifier to withParams method", "repairActions": ["assignAdd", "condBranIfAdd", "exThrowsAdd", "loopAdd", "mcAdd", "mcRepl", "mdAdd", "mdModChange", "mdParAdd", "mdRen", "retBranchAdd", "retExpChange", "retRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "wrongComp"]}
{"project": "Mockito", "bugId": 11, "problem": " public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n             return method.equals(o);\n     }\n     @Override\n     public int hashCode() {\n        return 1;\n     }\n }\n\\ No newline at end of file", "fixed": " public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o instanceof DelegatingMethod) {\n            DelegatingMethod that = (DelegatingMethod) o;\n            return method.equals(that.method);\n        } else {\n             return method.equals(o);\n        }\n     }\n     @Override\n     public int hashCode() {\n        return method.hashCode();\n     }\n }\n\\ No newline at end of file", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrapsIfElse"]}
{"project": "Lang", "bugId": 50, "problem": " public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti\n             key = new Pair(key, timeZone);\n         }\n        if (locale != null) {\n            key = new Pair(key, locale);\n         }\n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();", "fixed": " public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti\n             key = new Pair(key, timeZone);\n         }\n        if (locale == null) {\n            locale = Locale.getDefault();\n         }\n        key = new Pair(key, locale);\n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();", "observations": "Replaces some existent Null-Chek, inverting postive by negative.", "repairActions": ["assignAdd", "assignRem", "condBranRem", "condExpMod", "mcAdd", "mcRem", "objInstAdd", "objInstRem"], "repairPatterns": ["condBlockRem", "copyPaste", "expLogicMod", "unwrapIfElse", "wrongComp"]}
{"project": "Chart", "bugId": 6, "problem": " public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n        return super.equals(obj);\n     }", "fixed": " public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n        ShapeList that = (ShapeList) obj;\n        int listSize = size();\n        for (int i = 0; i < listSize; i++) {\n           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n               return false;\n           }\n        }\n        return true;\n     }", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "loopAdd", "mcAdd", "mcRem", "retBranchAdd", "retExpChange", "varAdd"], "repairPatterns": ["condBlockRetAdd", "wrongComp"]}
{"project": "Closure", "bugId": 85, "problem": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n     return next;\n   }", "fixed": " private Node tryRemoveUnconditionalBranching(Node n) {\n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n    while (next != null && next.getType() == Token.BLOCK) {\n      if (next.hasChildren()) {\n        next = next.getFirstChild();\n      } else {\n        next = computeFollowing(next);\n      }\n    }\n     return next;\n   }", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "retRem", "varRem"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missNullCheckN", "unwrapMethod"]}
{"project": "Math", "bugId": 28, "problem": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }", "fixed": " private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n            }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd"], "repairPatterns": ["wrapsIf"]}
{"project": "Mockito", "bugId": 6, "problem": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(Any.ANY).returnSet();\r\n     }\r\n     /**\r", "fixed": " public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n        return reportMatcher(new InstanceOf(Set.class)).returnSet();\r\n     }\r\n     /**\r", "observations": "Instantiates specific objects in place of call do Any.ANY", "repairActions": ["mcParValChange", "objInstAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrongMethodRef", "wrongVarRef"]}
{"project": "Time", "bugId": 11, "problem": "     static Chronology cLenientISO;\n    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n    static {\n        cVerbose.set(Boolean.FALSE);\n    }\n     /**\n      * Gets a flag indicating that verbose logging is required.", "fixed": "     static Chronology cLenientISO;\n    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n        protected Boolean initialValue() {\n            return Boolean.FALSE;\n        }\n    };\n     /**\n      * Gets a flag indicating that verbose logging is required.", "observations": "Changed a static initialization for a method inline implementation.", "repairActions": ["mcRem", "mdAdd", "mdOverride", "objInstMod", "retBranchAdd"], "repairPatterns": ["initFix", "notClassified"]}
