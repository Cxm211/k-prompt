{"project": "Math", "bugId": 27, "problem": " public Fraction divide(final int i) {\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n        return multiply(100).doubleValue();\n     }\n     /**", "fixed": " public Fraction divide(final int i) {\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n        return 100 * doubleValue();\n     }\n     /**", "observations": "", "repairActions": ["mcRem", "retExpChange"], "repairPatterns": ["expArithMod", "singleLine", "unwrapMethod"]}
{"project": "Closure", "bugId": 86, "problem": " static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n        return true;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:", "fixed": " static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:", "observations": "", "repairActions": ["retExpChange"], "repairPatterns": ["constChange", "expLogicMod", "singleLine"]}
{"project": "Math", "bugId": 24, "problem": " protected UnivariatePointValuePair doOptimize() {\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return current;\n                     }\n                 }", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                     }\n                 }", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["copyPaste", "wrapsMethod"]}
{"project": "Math", "bugId": 73, "problem": " public double solve(final UnivariateRealFunction f,\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n         return solve(f, min, yMin, max, yMax, initial, yInitial);", "fixed": " public double solve(final UnivariateRealFunction f,\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n         return solve(f, min, yMin, max, yMax, initial, yInitial);", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "mcAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Time", "bugId": 8, "problem": " public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n         int offset = 0;\n         try {\n             int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - minutesOffset;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }", "fixed": " public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n         int offset = 0;\n         try {\n             int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }", "observations": "", "repairActions": ["assignExpChange", "condBranIfAdd", "condExpMod", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "constChange", "expArithMod", "expLogicMod", "wrapsMethod"]}
{"project": "Time", "bugId": 1, "problem": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n        if (durationField.isSupported()) {\n            return 1;\n        }\n         return 0;\n     }", "fixed": " public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n         return 0;\n     }", "observations": "", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "exThrowsAdd", "mcAdd", "objInstAdd", "retRem"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "condBlockRem", "expLogicExpand"]}
{"project": "Closure", "bugId": 45, "problem": " private void interpretAssigns() {\n                 assign.assignNode.getLastChild(), true)) {\n               assignedToUnknownValue = true;\n             }\n           }\n          if (assignedToUnknownValue && hasPropertyAssign) {\n             changes = markReferencedVar(var) || changes;\n             maybeUnreferenced.remove(current);\n             current--;", "fixed": " private void interpretAssigns() {\n                 assign.assignNode.getLastChild(), true)) {\n               assignedToUnknownValue = true;\n             }\n            if (assign.maybeAliased) {\n              maybeEscaped = true;\n            }\n           }\n          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n             changes = markReferencedVar(var) || changes;\n             maybeUnreferenced.remove(current);\n             current--;", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condExpExpand", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "initFix", "wrongMethodRef"]}
{"project": "Time", "bugId": 15, "problem": " public static int safeMultiply(int val1, int val2) {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n                 return -val1;\n             case 0:\n                 return 0L;", "fixed": " public static int safeMultiply(int val1, int val2) {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                 return -val1;\n             case 0:\n                 return 0L;", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd"]}
{"project": "Closure", "bugId": 29, "problem": " private boolean isVarInlineForbidden(Var var) {\n      */\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n       for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();", "fixed": " private boolean isVarInlineForbidden(Var var) {\n      */\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n       for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "mcAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd", "missComp"]}
{"project": "Lang", "bugId": 48, "problem": " public EqualsBuilder append(Object lhs, Object rhs) {\n         }\n         Class lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n                 isEquals = lhs.equals(rhs);\n         } else if (lhs.getClass() != rhs.getClass()) {\n             this.setEquals(false);", "fixed": " public EqualsBuilder append(Object lhs, Object rhs) {\n         }\n         Class lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n            if (lhs instanceof java.math.BigDecimal) {\n                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n            } else {\n                 isEquals = lhs.equals(rhs);\n            }\n         } else if (lhs.getClass() != rhs.getClass()) {\n             this.setEquals(false);", "observations": "", "repairActions": ["assignAdd", "condBranIfElseAdd", "mcAdd"], "repairPatterns": ["wrapsIfElse"]}
{"project": "Closure", "bugId": 132, "problem": " private Node tryMinimizeIf(Node n) {\n              !mayEffectMutableState(lhs)) {\n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();", "fixed": " private Node tryMinimizeIf(Node n) {\n              !mayEffectMutableState(lhs) &&\n              (!mayHaveSideEffects(cond) ||\n                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 5, "problem": " private boolean isInlinableObject(List<Reference> refs) {", "fixed": " private boolean isInlinableObject(List<Reference> refs) {\n          if (gramps.isDelProp()) {\n            return false;\n          }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd"]}
{"project": "Closure", "bugId": 24, "problem": " private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n        if (parent.isVar()) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n           String name = n.getString();\n           Var aliasVar = scope.getVar(name);\n           aliases.put(name, aliasVar);", "fixed": " private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n           String name = n.getString();\n           Var aliasVar = scope.getVar(name);\n           aliases.put(name, aliasVar);", "observations": "Again, a kind of Wrap-with-IfElse where some conditionals were missing.", "repairActions": ["condBranIfElseAdd", "condBranRem", "condExpExpand", "mcAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "missComp"]}
{"project": "Closure", "bugId": 108, "problem": " public void exitScope(NodeTraversal t) {\n       if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n         transformation = null;", "fixed": " public void exitScope(NodeTraversal t) {\n       if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n        injectedDecls.clear();\n         aliases.clear();\n         forbiddenLocals.clear();\n         transformation = null;", "observations": "Added new class attribute and its initialization. An existent conditional expression with Null-Check was expanded with another condition.", "repairActions": ["assignAdd", "condExpExpand", "mcAdd", "varAdd"], "repairPatterns": ["expLogicExpand", "initFix", "missComp"]}
{"project": "Mockito", "bugId": 35, "problem": " public static Collection anyCollection() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T isA(Class<T> clazz) {\r\n        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();\r\n     }\r\n     /**\r", "fixed": " public static Collection anyCollection() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T isA(Class<T> clazz) {\r\n        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\r\n     }\r\n     /**\r", "observations": "", "repairActions": ["mcAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Math", "bugId": 23, "problem": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return\n                             best(current,\n                                  previous,\n                             isMinim);\n             }\n             ++iter;", "fixed": " protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n} else {\n                return best(best,\n                             best(current,\n                                  previous,\n                                 isMinim),\n                             isMinim);\n             }\n             ++iter;", "observations": "Call overloaded method with extra params. New variable is added with its initialization.", "repairActions": ["assignAdd", "mcAdd", "mcRepl", "retExpChange", "varAdd"], "repairPatterns": ["wrapsMethod"]}
{"project": "Lang", "bugId": 46, "problem": " public static String escapeJava(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void escapeJava(Writer out, String str) throws IOException {\n        escapeJavaStyleString(out, str, false);\n     }\n     /**", "fixed": " public static String escapeJava(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void escapeJava(Writer out, String str) throws IOException {\n        escapeJavaStyleString(out, str, false, false);\n     }\n     /**", "observations": "", "repairActions": ["condBranIfAdd", "mcParAdd", "mcRepl", "mdParAdd", "retExpChange"], "repairPatterns": ["wrapsIf"]}
{"project": "Mockito", "bugId": 19, "problem": " private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object\n     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n             Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n             if (injected != null) {\n                 injectionOccurred |= true;\n                 mocks.remove(injected);", "fixed": " private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object\n     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n             Field field = it.next();\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();\n             if (injected != null) {\n                 injectionOccurred |= true;\n                 mocks.remove(injected);", "observations": "Adds new parameter to existent method. Adjust code to reflect this.", "repairActions": ["condBranIfAdd", "condBranIfElseAdd", "loopAdd", "mcAdd", "mcParAdd", "mcRepl", "mdAdd", "mdParAdd", "objInstAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Closure", "bugId": 27, "problem": " public static Node tryFinally(Node tryBody, Node finallyBody) {\n   public static Node tryCatch(Node tryBody, Node catchNode) {\n     Preconditions.checkState(tryBody.isBlock());\n     Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\n     return new Node(Token.TRY, tryBody, catchBody);\n   }", "fixed": " public static Node tryFinally(Node tryBody, Node finallyBody) {\n   public static Node tryCatch(Node tryBody, Node catchNode) {\n     Preconditions.checkState(tryBody.isBlock());\n     Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n     return new Node(Token.TRY, tryBody, catchBody);\n   }", "observations": "A Node object is instantiated in the call. Adds new method and replace calls.", "repairActions": ["assignExpChange", "mcParValChange", "mcRepl", "mdAdd", "objInstAdd", "retBranchAdd"], "repairPatterns": ["copyPaste", "wrongComp", "wrongMethodRef"]}
{"project": "Math", "bugId": 32, "problem": " protected void computeGeometricalProperties() {\n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);", "fixed": " protected void computeGeometricalProperties() {\n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "missNullCheckP", "singleLine"]}
{"project": "Closure", "bugId": 54, "problem": " public boolean setPrototype(PrototypeObjectType prototype) {\n       return false;\n     }\n    boolean replacedPrototype = prototype != null;\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();", "fixed": " public boolean setPrototype(PrototypeObjectType prototype) {\n       return false;\n     }\n    PrototypeObjectType oldPrototype = this.prototype;\n    boolean replacedPrototype = oldPrototype != null;\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n    if (oldPrototype != null) {\n      oldPrototype.setOwnerFunction(null);\n    }\n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();", "observations": "One of the chunks have a kind of Wrap-with-IfElse done with the replacement of existent conditional block.", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condBranIfElseAdd", "condExpRed", "mcAdd", "mcRem", "varAdd", "varReplVar"], "repairPatterns": ["condBlockOthersAdd", "expLogicReduce", "missComp", "missNullCheckN", "wrapsIfElse", "wrongVarRef"]}
{"project": "Math", "bugId": 76, "problem": " public RealMatrix getU()\n             if (m >= n) {\n                 final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n                }\n                         for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];", "fixed": " public RealMatrix getU()\n             if (m >= n) {\n                 final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n                    if (i < n - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n                    } else {\n                         for (int j = 0; j < p; ++j) {\n                            wi[j] = mi * ei0[j] / singularValues[j];\n                         }\n                    }\n                }\n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];", "observations": "The structure of the changes are similar and applied in two different methods.", "repairActions": ["assignAdd", "assignExpChange", "assignRem", "condBranIfElseAdd", "loopCondChange", "mcParValChange", "varReplVar"], "repairPatterns": ["copyPaste", "expArithMod", "expLogicMod", "wrapsIfElse", "wrongVarRef"]}
{"project": "Closure", "bugId": 3, "problem": " public boolean apply(Node input) {\n                   case Token.REGEXP:\n                   case Token.NEW:\n                     return true;\n                 }\n                 return false;\n               }", "fixed": " public boolean apply(Node input) {\n                   case Token.REGEXP:\n                   case Token.NEW:\n                     return true;\n                  case Token.NAME:\n                    Var var = scope.getOwnSlot(input.getString());\n                    if (var != null\n                        && var.getParentNode().isCatch()) {\n                      return true;\n                    }\n                 }\n                 return false;\n               }", "observations": "", "repairActions": ["assignAdd", "condBranCaseAdd", "condBranIfAdd", "condExpMod", "mcAdd", "mcParAdd", "mcRepl", "mdParAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRetAdd"]}
{"project": "Lang", "bugId": 27, "problem": " public static Number createNumber(String str) throws NumberFormatException {\n         if (decPos > -1) {\n             if (expPos > -1) {\n                if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);", "fixed": " public static Number createNumber(String str) throws NumberFormatException {\n         if (decPos > -1) {\n             if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);", "observations": "", "repairActions": ["condExpExpand", "exThrowsAdd", "mcAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "expLogicExpand"]}
{"project": "Math", "bugId": 4, "problem": " public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector2D v2D = line1.intersection(line2);\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));", "fixed": " public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin\n         Vector2D v2D = line1.intersection(line2);\n        if (v2D == null) {\n            return null;\n        }\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));", "observations": "Almost a copy, the only difference is in involved variable.", "repairActions": ["condBranIfAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP"]}
{"project": "Math", "bugId": 20, "problem": " public FitnessFunction() {\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n            return\n                 decode(x);\n         }", "fixed": " public FitnessFunction() {\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n            return boundaries != null && isRepairMode ?\n                decode(repair(x)) :\n                 decode(x);\n         }", "observations": "Adds a new return output alternative through conditional expression of the form \"exp?a:b\". Something to think: \"Is it a change in return expression, a return branch adding or both?\". For now, it is considered as both.", "repairActions": ["condBranIfElseAdd", "mcAdd", "retBranchAdd", "retExpChange"], "repairPatterns": ["missNullCheckN", "singleLine", "wrapsIfElse"]}
{"project": "Closure", "bugId": 36, "problem": " private boolean canInline(\n         }\n       }", "fixed": " private boolean canInline(\n          if (convention.getSingletonGetterClassName(callNode) != null) {\n            return false;\n          }\n         }\n       }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "missNullCheckN"]}
{"project": "Math", "bugId": 35, "problem": " public ElitisticListPopulation(final List<Chromosome> chromosomes,\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n        this.elitismRate = elitismRate;\n     }\n     /**", "fixed": " public ElitisticListPopulation(final List<Chromosome> chromosomes,\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n        setElitismRate(elitismRate);\n     }\n     /**", "observations": "Similar to Math-34", "repairActions": ["assignRem", "mcAdd", "varReplMc"], "repairPatterns": ["copyPaste", "wrapsMethod", "wrongVarRef"]}
{"project": "Closure", "bugId": 34, "problem": " void add(Node n, Context context) {\n         cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n       }\n       return;\n     }", "fixed": " void add(Node n, Context context) {\n         cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n       }\n       return;\n     }", "observations": "", "repairActions": ["condExpExpand", "mcAdd", "mcParAdd", "mcRepl", "varReplVar"], "repairPatterns": ["expLogicExpand", "wrongMethodRef", "wrongVarRef"]}
{"project": "Time", "bugId": 26, "problem": " public long add(long instant, long value) {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }", "fixed": " public long add(long instant, long value) {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Math", "bugId": 6, "problem": " protected PointVectorValuePair doOptimize() {\n                     if (checker != null) {\n                        if (checker.converged(iter, previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }", "fixed": " protected PointVectorValuePair doOptimize() {\n                     if (checker != null) {\n                        if (checker.converged(getIterations(), previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }", "observations": "A parameter value passed through the constructor during object instantiation is changed. A local variable is removed and expressions to increment it are replaced by equivalent method call.", "repairActions": ["assignExpChange", "assignRem", "condExpMod", "mcAdd", "mcParValChange", "objInstMod", "varRem", "varReplMc"], "repairPatterns": ["constChange", "copyPaste", "expLogicMod", "initFix", "wrongComp", "wrongVarRef"]}
{"project": "Closure", "bugId": 126, "problem": " void tryMinimizeExits(Node n, int exitType, String labelName) {\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n     }", "fixed": " void tryMinimizeExits(Node n, int exitType, String labelName) {\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n     }", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem", "varRem"], "repairPatterns": ["condBlockRem"]}
{"project": "Closure", "bugId": 83, "problem": " public BooleanOptionHandler(\n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n        String param = params.getParameter(0);\n         if (param == null) {\n           setter.addValue(true);", "fixed": " public BooleanOptionHandler(\n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n        String param = null;\n        try {\n          param = params.getParameter(0);\n        } catch (CmdLineException e) {}\n         if (param == null) {\n           setter.addValue(true);", "observations": "The existent code was splitted in declaration of var \"param\" out of the wrap and assignment, with Wrap-with-TryCatch.", "repairActions": ["assignAdd", "exTryCatchAdd"], "repairPatterns": ["wrapsTryCatch"]}
{"project": "Time", "bugId": 10, "problem": "     \n     private static final long serialVersionUID = 9386874258972L;\n     \n     \n     private volatile int iPeriod;", "fixed": "     \n     private static final long serialVersionUID = 9386874258972L;\n     \n    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n     \n     private volatile int iPeriod;", "observations": "Adds new variable and its initialization.", "repairActions": ["assignAdd", "mcParValChange", "varAdd"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Time", "bugId": 23, "problem": " private static synchronized String getConvertedId(String id) {\n             map = new HashMap<String, String>();\n             map.put(\"GMT\", \"UTC\");\n             map.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\n             map.put(\"AST\", \"America/Anchorage\");", "fixed": " private static synchronized String getConvertedId(String id) {\n             map = new HashMap<String, String>();\n             map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n             map.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\n             map.put(\"AST\", \"America/Anchorage\");", "observations": "Changes entries in a key-value map.", "repairActions": ["mcAdd", "mcParValChange", "mcRem"], "repairPatterns": ["constChange", "initFix"]}
{"project": "Closure", "bugId": 82, "problem": " public boolean isNoObjectType() {\n   }\n   public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType();\n   }\n   public boolean isNumberObjectType() {", "fixed": " public boolean isNoObjectType() {\n   }\n   public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n   }\n   public boolean isNumberObjectType() {", "observations": "", "repairActions": ["mcAdd", "retExpChange"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Chart", "bugId": 3, "problem": " public TimeSeries createCopy(int start, int end)\n             throw new IllegalArgumentException(\"Requires start <= end.\");\r\n         }\r\n         TimeSeries copy = (TimeSeries) super.clone();\r\n         copy.data = new java.util.ArrayList();\r\n         if (this.data.size() > 0) {\r\n             for (int index = start; index <= end; index++) {\r", "fixed": " public TimeSeries createCopy(int start, int end)\n             throw new IllegalArgumentException(\"Requires start <= end.\");\r\n         }\r\n         TimeSeries copy = (TimeSeries) super.clone();\r\n        copy.minY = Double.NaN;\r\n        copy.maxY = Double.NaN;\r\n         copy.data = new java.util.ArrayList();\r\n         if (this.data.size() > 0) {\r\n             for (int index = start; index <= end; index++) {\r", "observations": "Missing initialization", "repairActions": ["assignAdd"], "repairPatterns": ["initFix", "notClassified"]}
{"project": "Lang", "bugId": 42, "problem": " public String escape(String str) {\n     public void escape(Writer writer, String str) throws IOException {\n         int len = str.length();\n         for (int i = 0; i < len; i++) {\n            char c = str.charAt(i);\n             String entityName = this.entityName(c);\n             if (entityName == null) {\n                if (c > 0x7F) {\nwriter.write(\"&\n                     writer.write(Integer.toString(c, 10));\n                     writer.write(';');", "fixed": " public String escape(String str) {\n     public void escape(Writer writer, String str) throws IOException {\n         int len = str.length();\n         for (int i = 0; i < len; i++) {\n            int c = Character.codePointAt(str, i); \n             String entityName = this.entityName(c);\n             if (entityName == null) {\n                if (c >= 0x010000 && i < len - 1) {\n                    writer.write(\"&\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                    i++;\n                } else if (c > 0x7F) { \nwriter.write(\"&\n                     writer.write(Integer.toString(c, 10));\n                     writer.write(';');", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfElseAdd", "mcAdd", "mcRepl", "varTyChange"], "repairPatterns": ["wrapsIfElse", "wrongComp", "wrongMethodRef"]}
{"project": "Time", "bugId": 3, "problem": " public void setHourOfDay(final int hourOfDay) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addHours(final int hours) {\n             setMillis(getChronology().hours().add(getMillis(), hours));\n     }", "fixed": " public void setHourOfDay(final int hourOfDay) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addHours(final int hours) {\n        if (hours != 0) {\n             setMillis(getChronology().hours().add(getMillis(), hours));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Math", "bugId": 71, "problem": " public double integrate(final FirstOrderDifferentialEquations equations,\n                   loop     = false;\n               } else {", "fixed": " public double integrate(final FirstOrderDifferentialEquations equations,\n                  interpolator.storeTime(stepStart);\n                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n                  hNew     = 0;\n                  stepSize = 0;\n                   loop     = false;\n               } else {", "observations": "Three lines equal lines are added in two different places. Just line 302 is different.", "repairActions": ["assignAdd", "mcAdd"], "repairPatterns": ["copyPaste"]}
{"project": "Lang", "bugId": 3, "problem": " public static Number createNumber(final String str) throws NumberFormatException\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n} catch (final NumberFormatException nfe) {\n         }\n         try {\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n} catch (final NumberFormatException nfe) {\n         }", "fixed": " public static Number createNumber(final String str) throws NumberFormatException\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\nif(numDecimals <= 7){\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n            }\n} catch (final NumberFormatException nfe) {\n         }\n         try {\nif(numDecimals <= 16){\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n            }\n} catch (final NumberFormatException nfe) {\n         }", "observations": "", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Math", "bugId": 56, "problem": " public int getDimension() {\n             indices[i] = idx;\n         }\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\n         return indices;\n     }", "fixed": " public int getDimension() {\n             indices[i] = idx;\n         }\n        indices[last] = index - count;\n         return indices;\n     }", "observations": "Replaces a wrong and more complex calculation by the correct and simpler one.", "repairActions": ["assignExpChange", "assignRem", "loopRem", "varRem"], "repairPatterns": ["blockRemove", "expArithMod", "wrongComp"]}
{"project": "Time", "bugId": 26, "problem": " public long add(long instant, int value) {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }", "fixed": " public long add(long instant, int value) {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n               return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }", "observations": "", "repairActions": ["mcParAdd", "mcRepl", "retExpChange"], "repairPatterns": ["copyPaste", "wrongMethodRef"]}
{"project": "Closure", "bugId": 115, "problem": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n     Node cArg = callNode.getFirstChild().getNext();", "fixed": " private CanInlineResult canInlineReferenceDirectly(\n     Node block = fnNode.getLastChild();\n     Node cArg = callNode.getFirstChild().getNext();", "observations": "", "repairActions": ["assignRem", "condBranRem", "mcRem", "retRem", "varRem"], "repairPatterns": ["blockRemove", "condBlockRem"]}
{"project": "Mockito", "bugId": 23, "problem": "     private static final long serialVersionUID = -7105341425736035847L;\r\n    private MockitoCore mockitoCore = new MockitoCore();\r\n    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\r\n         GenericMetadataSupport returnTypeGenericMetadata =\r\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\r\n         Class<?> rawType = returnTypeGenericMetadata.rawType();\r\n         if (!mockitoCore.isTypeMockable(rawType)) {\r\n             return delegate.returnValueFor(rawType);\r\n         }\r", "fixed": "     private static final long serialVersionUID = -7105341425736035847L;\r\n    private transient MockitoCore mockitoCore;\r\n    private transient ReturnsEmptyValues delegate;\r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\r\n         GenericMetadataSupport returnTypeGenericMetadata =\r\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\r\n         Class<?> rawType = returnTypeGenericMetadata.rawType();\r\n        instantiateMockitoCoreIfNeeded();\r\n        instantiateDelegateIfNeeded();\r\n         if (!mockitoCore.isTypeMockable(rawType)) {\r\n             return delegate.returnValueFor(rawType);\r\n         }\r", "observations": "Instantiates MockitoCore and ReturnsEmptyValues objects. Replaces instantiation of Answer to SerializabelAnswer object.", "repairActions": ["assignAdd", "assignRem", "condBranIfAdd", "mcAdd", "mdAdd", "objInstAdd", "objInstRem", "retExpChange", "tyAdd", "varModChange", "varTyChange"], "repairPatterns": ["condBlockOthersAdd", "missNullCheckP"]}
{"project": "Chart", "bugId": 17, "problem": " public void delete(int start, int end) {\n      *         subclasses may differ.\r\n      */\r\n     public Object clone() throws CloneNotSupportedException {\r\n        Object clone = createCopy(0, getItemCount() - 1);\r\n         return clone;\r\n     }\r", "fixed": " public void delete(int start, int end) {\n      *         subclasses may differ.\r\n      */\r\n     public Object clone() throws CloneNotSupportedException {\r\n        TimeSeries clone = (TimeSeries) super.clone();\r\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\r\n         return clone;\r\n     }\r", "observations": "Type change + computing change.", "repairActions": ["assignAdd", "assignExpChange", "mcAdd", "mcRem", "varTyChange"], "repairPatterns": ["notClassified", "wrongComp"]}
{"project": "Time", "bugId": 7, "problem": " public int parseInto(ReadWritableInstant instant, String text, int position) {\n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);", "fixed": " public int parseInto(ReadWritableInstant instant, String text, int position) {\n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);", "observations": "Move assignment of var and changed assignment expression.", "repairActions": ["assignExpChange", "mcParValChange", "mcRem", "mcRepl"], "repairPatterns": ["initFix", "notClassified", "wrongComp"]}
{"project": "Mockito", "bugId": 4, "problem": " public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation()\n         ));\n     }", "fixed": " public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                 undesired.getLocation()\n         ));\n     }", "observations": "", "repairActions": ["condBranIfAdd", "mcAdd", "retBranchAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missNullCheckP", "wrapsMethod"]}
{"project": "Closure", "bugId": 131, "problem": " public static boolean isJSIdentifier(String s) {\n       int length = s.length();\n       if (length == 0 ||\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n       for (int i = 1; i < length; i++) {\n        if (\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }", "fixed": " public static boolean isJSIdentifier(String s) {\n       int length = s.length();\n       if (length == 0 ||\n          Character.isIdentifierIgnorable(s.charAt(0)) ||\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n       for (int i = 1; i < length; i++) {\n        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }", "observations": "", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["copyPaste", "expLogicExpand"]}
{"project": "Closure", "bugId": 125, "problem": " private void visitNew(NodeTraversal t, Node n) {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {", "fixed": " private void visitNew(NodeTraversal t, Node n) {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {", "observations": "Again, conditional expression with Null-Check was expanded with new condition.", "repairActions": ["condExpExpand", "mcAdd"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Closure", "bugId": 34, "problem": " private void unrollBinaryOperator(\n     Node current = firstNonOperator;\n     do {\n       current = current.getParent();\n      cc.listSeparator();\n       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n     } while (current != n);\n   }", "fixed": " private void unrollBinaryOperator(\n     Node current = firstNonOperator;\n     do {\n       current = current.getParent();\n      cc.addOp(opStr, true);\n       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n     } while (current != n);\n   }", "observations": "", "repairActions": ["condExpExpand", "mcAdd", "mcParAdd", "mcRepl", "varReplVar"], "repairPatterns": ["expLogicExpand", "wrongMethodRef", "wrongVarRef"]}
{"project": "Chart", "bugId": 19, "problem": " public void setRangeAxes(ValueAxis[] axes) {\n      * @since 1.0.7\r\n      */\r\n     public int getRangeAxisIndex(ValueAxis axis) {\r\n         int result = this.rangeAxes.indexOf(axis);\r\nif (result < 0) {\n             Plot parent = getParent();\r", "fixed": " public void setRangeAxes(ValueAxis[] axes) {\n      * @since 1.0.7\r\n      */\r\n     public int getRangeAxisIndex(ValueAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n         int result = this.rangeAxes.indexOf(axis);\r\nif (result < 0) {\n             Plot parent = getParent();\r", "observations": "", "repairActions": ["condBranIfAdd", "exThrowsAdd", "objInstAdd"], "repairPatterns": ["condBlockExcAdd", "copyPaste", "missNullCheckP"]}
{"project": "Chart", "bugId": 22, "problem": " public void removeRow(int rowIndex) {\n      */\r\n     public void removeRow(Comparable rowKey) {\r\n         int index = getRowIndex(rowKey);\r\n         removeRow(index);\r\n     }\r", "fixed": " public void removeRow(int rowIndex) {\n      */\r\n     public void removeRow(Comparable rowKey) {\r\n         int index = getRowIndex(rowKey);\r\n        if (index < 0) {\r\n            throw new UnknownKeyException(\"Row key (\" + rowKey \r\n                    + \") not recognised.\");\r\n        }\r\n         removeRow(index);\r\n     }\r", "observations": "Implicit null check after loop throught a vector and using a flag variable.", "repairActions": ["assignAdd", "condBranIfAdd", "condBranRem", "exThrowsAdd", "loopAdd", "mcAdd", "mcParValChange", "objInstAdd", "retExpChange", "varAdd", "varReplVar"], "repairPatterns": ["condBlockExcAdd", "condBlockOthersAdd", "missComp", "unwrapIfElse", "wrongVarRef"]}
{"project": "Math", "bugId": 63, "problem": " public static double cosh(double x) {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n     }\n     /**", "fixed": " public static double cosh(double x) {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n     }\n     /**", "observations": "", "repairActions": ["mcAdd", "mcRem", "retExpChange"], "repairPatterns": ["expLogicMod", "singleLine"]}
{"project": "Time", "bugId": 3, "problem": " public void setMinuteOfHour(final int minuteOfHour) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMinutes(final int minutes) {\n             setMillis(getChronology().minutes().add(getMillis(), minutes));\n     }", "fixed": " public void setMinuteOfHour(final int minuteOfHour) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMinutes(final int minutes) {\n        if (minutes != 0) {\n             setMillis(getChronology().minutes().add(getMillis(), minutes));\n        }\n     }", "observations": "The patches makes a type of \"bypass\" null check, where the logic is applyed only if the value is different of null.", "repairActions": ["condBranIfAdd"], "repairPatterns": ["copyPaste", "wrapsIf"]}
{"project": "Closure", "bugId": 32, "problem": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n     do {\n       switch (token) {\n         case STAR:\n           if (ignoreStar) {\n           } else {\n             if (builder.length() > 0) {", "fixed": " private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n    int lineStartChar = -1;\n     do {\n       switch (token) {\n         case STAR:\n           if (ignoreStar) {\n            lineStartChar = stream.getCharno() + 1;\n           } else {\n             if (builder.length() > 0) {", "observations": "", "repairActions": ["assignAdd", "condBranIfAdd", "condBranIfElseAdd", "condBranRem", "loopAdd", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "condBlockRem", "missComp"]}
{"project": "Mockito", "bugId": 17, "problem": " public MockSettings defaultAnswer(Answer defaultAnswer) {\n     }\r\n     public boolean isSerializable() {\r\n        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\r\n     }\r\n     public void initiateMockName(Class classToMock) {\r", "fixed": " public MockSettings defaultAnswer(Answer defaultAnswer) {\n     }\r\n     public boolean isSerializable() {\r\n        return serializable;\r\n     }\r\n     public void initiateMockName(Class classToMock) {\r", "observations": "", "repairActions": ["assignAdd", "mcAdd", "mcRem", "objInstAdd", "retExpChange", "varAdd"], "repairPatterns": ["expLogicMod", "wrapsIfElse"]}
{"project": "Closure", "bugId": 45, "problem": " void apply() {\n       this.nameNode = nameNode;\n       this.isPropertyAssign = isPropertyAssign;\n      this.maybeAliased = !assignNode.getParent().isExprResult();\n       this.mayHaveSecondarySideEffects =\n           maybeAliased ||\n           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||", "fixed": " void apply() {\n       this.nameNode = nameNode;\n       this.isPropertyAssign = isPropertyAssign;\n      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n       this.mayHaveSecondarySideEffects =\n           maybeAliased ||\n           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranIfAdd", "condExpExpand", "condExpMod", "mcAdd", "mcRem", "varAdd"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand", "initFix", "wrongMethodRef"]}
{"project": "Closure", "bugId": 74, "problem": " private Node tryFoldComparison(Node n, Node left, Node right) {\n           && right.getString().equals(\"undefined\"))\n           || (Token.VOID == right.getType()\n               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = left.getType();\n    int rhType = right.getType();\n     switch (lhType) {\n       case Token.VOID:\n         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {", "fixed": " private Node tryFoldComparison(Node n, Node left, Node right) {\n           && right.getString().equals(\"undefined\"))\n           || (Token.VOID == right.getType()\n               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = getNormalizedNodeType(left);\n    int rhType = getNormalizedNodeType(right);\n     switch (lhType) {\n       case Token.VOID:\n         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {", "observations": "", "repairActions": ["assignAdd", "assignExpChange", "condBranCaseAdd", "condBranIfAdd", "mcAdd", "mcRepl", "mdAdd", "retBranchAdd", "varAdd"], "repairPatterns": ["condBlockRetAdd", "copyPaste", "missComp", "wrongMethodRef"]}
{"project": "Closure", "bugId": 130, "problem": " private void inlineAliases(GlobalNamespace namespace) {\n         continue;\n       }\n      if (name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {", "fixed": " private void inlineAliases(GlobalNamespace namespace) {\n         continue;\n       }\n      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {", "observations": "", "repairActions": ["condExpExpand"], "repairPatterns": ["expLogicExpand", "singleLine"]}
{"project": "Lang", "bugId": 15, "problem": " private static boolean isAssignable(Type type, ParameterizedType toParameterized\n                 toClass, typeVarAssigns);\n        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());", "fixed": " private static boolean isAssignable(Type type, ParameterizedType toParameterized\n                 toClass, typeVarAssigns);\n        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);", "observations": "Change local var type.", "repairActions": ["assignExpChange", "condExpRed", "loopCondChange", "mcAdd"], "repairPatterns": ["expLogicReduce", "wrongMethodRef"]}
{"project": "Lang", "bugId": 35, "problem": " public static boolean isEmpty(boolean[] array) {\n         } else if (element != null) {\n             type = element.getClass();\n         } else {\n            type = Object.class;\n         }\n@SuppressWarnings(\"unchecked\")\n         T[] newArray = (T[]) copyArrayGrow1(array, type);", "fixed": " public static boolean isEmpty(boolean[] array) {\n         } else if (element != null) {\n             type = element.getClass();\n         } else {\n            throw new IllegalArgumentException(\"Arguments cannot both be null\");            \n         }\n@SuppressWarnings(\"unchecked\")\n         T[] newArray = (T[]) copyArrayGrow1(array, type);", "observations": "Changes return of a null object to throw an Exception. The only statement of an existent \"else block\" is replaced by an exception throw.", "repairActions": ["assignRem", "exThrowsAdd", "objInstAdd", "retRem"], "repairPatterns": ["notClassified"]}
{"project": "Chart", "bugId": 16, "problem": " public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n             }\r\n             else {\r\n                this.seriesKeys = null;\r\n                this.categoryKeys = null;\r\n             }\r\n         }\r", "fixed": " public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n             }\r\n             else {\r\n                this.seriesKeys = new Comparable[0];\r\n                this.categoryKeys = new Comparable[0];\r\n             }\r\n         }\r", "observations": "Variable initialization in constructor + conditional expression change.", "repairActions": ["assignExpChange", "condExpMod", "mcAdd", "objInstAdd", "varReplMc"], "repairPatterns": ["expLogicMod", "initFix", "wrongVarRef"]}
{"project": "Closure", "bugId": 48, "problem": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n       }\n       if (!inferred) {", "fixed": " void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          inferred = false;\n        } else if (!scope.isDeclared(qName, false) &&\n                   n.isUnscopedQualifiedName()) {\n          inferred = false;\n        }\n       }\n       if (!inferred) {", "observations": "", "repairActions": ["assignAdd", "assignRem", "condBranIfElseAdd", "condExpExpand", "mcAdd", "mcRem"], "repairPatterns": ["condBlockOthersAdd", "expLogicExpand"]}
