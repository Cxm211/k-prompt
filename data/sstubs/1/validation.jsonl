{"fixCommitSHA1": "8afc77b3acd1616a19c58863c71febaf702cf7bf", "projectName": "yusuke.twitter4j", "bugType": "Change Identifier Used", "problem": "* @see <a href=\"http:\n      */\n     public Trends getTrends() throws TwitterException {\n        return Trends.constructTrends(get(getSearchBaseURL() + \"trends.json\", false));\n     }\n     /**", "fixed": "* @see <a href=\"http:\n      */\n     public Trends getTrends() throws TwitterException {\n        return Trends.createTrends(get(getSearchBaseURL() + \"trends.json\", false));\n     }\n     /**", "sourceBeforeFix": "Status.constructStatuses(get(getBaseURL() + \"favorites/\" + id+ \".json\",\"page\",String.valueOf(page),true))", "sourceAfterFix": "Status.createStatuseList(get(getBaseURL() + \"favorites/\" + id+ \".json\",\"page\",String.valueOf(page),true))"}
{"fixCommitSHA1": "80b65af84df3d54ebb4e4a4abe52c6b1fdc32b64", "projectName": "Alluxio.alluxio", "bugType": "Change Identifier Used", "problem": "     JournalFactory factory =\n         new MutableJournal.Factory(new URI(mTestFolder.newFolder().getAbsolutePath()));\n     mFileSystemMaster = Mockito.mock(DefaultFileSystemMaster.class);\n    registry.add(DefaultFileSystemMaster.class, mFileSystemMaster);\n     ThreadFactory threadPool = ThreadFactoryUtils.build(\"LineageMasterTest-%d\", true);\n     mExecutorService = Executors.newFixedThreadPool(2, threadPool);\n     mLineageMaster = new LineageMaster(registry, factory,", "fixed": "     JournalFactory factory =\n         new MutableJournal.Factory(new URI(mTestFolder.newFolder().getAbsolutePath()));\n     mFileSystemMaster = Mockito.mock(DefaultFileSystemMaster.class);\n    registry.add(FileSystemMaster.class, mFileSystemMaster);\n     ThreadFactory threadPool = ThreadFactoryUtils.build(\"LineageMasterTest-%d\", true);\n     mExecutorService = Executors.newFixedThreadPool(2, threadPool);\n     mLineageMaster = new LineageMaster(registry, factory,", "sourceBeforeFix": "DefaultFileSystemMaster.class", "sourceAfterFix": "FileSystemMaster.class"}
{"fixCommitSHA1": "930d814a14d2221a9b745802ea946f44e1b32588", "projectName": "apache.camel", "bugType": "Change Modifier", "problem": "     \n    public static interface Sjms2EndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedSjms2EndpointProducerBuilder advanced() {", "fixed": "     \n    public interface Sjms2EndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedSjms2EndpointProducerBuilder advanced() {", "sourceBeforeFix": "9", "sourceAfterFix": "1"}
{"fixCommitSHA1": "3ae514dcbcea3287baaf498f28cce0267a2d50bb", "projectName": "wildfly.wildfly", "bugType": "Change Numeric Literal", "problem": "      *\n      * @return an {@link IllegalArgumentException} for the error.\n      */\n    @Message(id = 15873, value = \"Repository does not contain any deployment with hash %s\")\n     IllegalStateException deploymentHashNotFoundInRepository(String hash);\n     /**", "fixed": "      *\n      * @return an {@link IllegalArgumentException} for the error.\n      */\n    @Message(id = 10873, value = \"Repository does not contain any deployment with hash %s\")\n     IllegalStateException deploymentHashNotFoundInRepository(String hash);\n     /**", "sourceBeforeFix": "id=15874", "sourceAfterFix": "id=10874"}
{"fixCommitSHA1": "5b13fe70c25812157a1e4432135eb9639e72bc6a", "projectName": "apache.flink", "bugType": "Wrong Function Name", "problem": " \t\tfinal Sink normalizedPersons = new Sink(\"normalizedPersons.json\").withInputs(replace);\n \t\texpectedPlan.setSinks(normalizedPersons);\n\t\tassertEquals(expectedPlan, actualPlan);\n \t}\n }", "fixed": " \t\tfinal Sink normalizedPersons = new Sink(\"normalizedPersons.json\").withInputs(replace);\n \t\texpectedPlan.setSinks(normalizedPersons);\n\t\tassertPlanEquals(expectedPlan, actualPlan);\n \t}\n }", "sourceBeforeFix": "assertEquals(expectedPlan,actualPlan)", "sourceAfterFix": "assertPlanEquals(expectedPlan,actualPlan)"}
{"fixCommitSHA1": "5c387443a641305b64f25932de36de766d1f541f", "projectName": "hazelcast.hazelcast", "bugType": "Change Identifier Used", "problem": "     public void pickAddress() throws Exception {\n         try {\n             bindAddress = memberAddressProvider.getBindAddress();\n            logger.info(\"Using bind address: \" + publicAddress);\n             publicAddress = memberAddressProvider.getPublicAddress();\n             validatePublicAddress(publicAddress);", "fixed": "     public void pickAddress() throws Exception {\n         try {\n             bindAddress = memberAddressProvider.getBindAddress();\n            logger.info(\"Using bind address: \" + bindAddress);\n             publicAddress = memberAddressProvider.getPublicAddress();\n             validatePublicAddress(publicAddress);", "sourceBeforeFix": "\"Using bind address: \" + publicAddress", "sourceAfterFix": "\"Using bind address: \" + bindAddress"}
{"fixCommitSHA1": "038ea1803bae1cf3be279b36395b4de4e0ff39b5", "projectName": "openhab.openhab", "bugType": "Wrong Function Name", "problem": " \t\tif (pollFuture != null && !pollFuture.isCancelled())\n \t\t\tpollFuture.cancel(false);\n\t\tlogger.debug(\"rapidRefreshFuture scheduleing for {} millis\", millis);\n \t\tpollFuture = pollService.scheduleAtFixedRate(new Runnable() {\n \t\t\t@Override", "fixed": " \t\tif (pollFuture != null && !pollFuture.isCancelled())\n \t\t\tpollFuture.cancel(false);\n\t\tlogger.trace(\"rapidRefreshFuture scheduleing for {} millis\", millis);\n \t\tpollFuture = pollService.scheduleAtFixedRate(new Runnable() {\n \t\t\t@Override", "sourceBeforeFix": "logger.debug(\"rapidRefreshFutureEnd stopping\")", "sourceAfterFix": "logger.trace(\"rapidRefreshFutureEnd stopping\")"}
{"fixCommitSHA1": "930d814a14d2221a9b745802ea946f44e1b32588", "projectName": "apache.camel", "bugType": "Change Modifier", "problem": "     \n    public static interface KafkaEndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedKafkaEndpointProducerBuilder advanced() {", "fixed": "     \n    public interface KafkaEndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedKafkaEndpointProducerBuilder advanced() {", "sourceBeforeFix": "9", "sourceAfterFix": "1"}
{"fixCommitSHA1": "1d5647b92215f0ceabced59275225ad829061663", "projectName": "spring-projects.spring-boot", "bugType": "Change Modifier", "problem": " \tprivate int port = Integer.valueOf(System.getProperty(\"port\"));\n \t@Test\n\tpublic void testHome() throws Exception {\nString url = \"http:\n \t\tResponseEntity<String> entity = new TestRestTemplate().getForEntity(url, String.class);\n \t\tassertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);", "fixed": " \tprivate int port = Integer.valueOf(System.getProperty(\"port\"));\n \t@Test\n\tvoid testHome() throws Exception {\nString url = \"http:\n \t\tResponseEntity<String> entity = new TestRestTemplate().getForEntity(url, String.class);\n \t\tassertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);", "sourceBeforeFix": "1", "sourceAfterFix": "0"}
{"fixCommitSHA1": "c87eb7a0cf6692600405dc01ed1479cb21ce7dea", "projectName": "dropwizard.metrics", "bugType": "Change Binary Operator", "problem": " \t\tfinal double priority = weight(timestamp - startTime) / random;\n \t\tfinal long newCount = count.incrementAndGet();\n\t\tif (newCount < reservoirSize) {\n \t\t\tvalues.put(new Value(newCount, value, priority));\n \t\t} else {\n \t\t\tif (values.peek().priority < priority) {", "fixed": " \t\tfinal double priority = weight(timestamp - startTime) / random;\n \t\tfinal long newCount = count.incrementAndGet();\n\t\tif (newCount <= reservoirSize) {\n \t\t\tvalues.put(new Value(newCount, value, priority));\n \t\t} else {\n \t\t\tif (values.peek().priority < priority) {", "sourceBeforeFix": "newCount < reservoirSize", "sourceAfterFix": "newCount <= reservoirSize"}
{"fixCommitSHA1": "55ed50c4975cf694828d46ee9ca32ce72a9ef913", "projectName": "clojure.clojure", "bugType": "Change Identifier Used", "problem": " \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, args.rest());\r\n \t\tcase 13:\r\n\t\t\treturn invoke(args.first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r", "fixed": " \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, args.rest());\r\n \t\tcase 13:\r\n\t\t\treturn doInvoke(args.first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r", "sourceBeforeFix": "invoke(args.first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),args.rest())", "sourceAfterFix": "doInvoke(args.first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),args.rest())"}
{"fixCommitSHA1": "6b48897359d596d38fc59be7ffc70e63bb07c5fd", "projectName": "apache.camel", "bugType": "Change Identifier Used", "problem": "             timeout = localParameters.remove(\"dataTimeout\");\n             if (timeout != null) {\n                dataTimeout = getCamelContext().getTypeConverter().convertTo(int.class, dataTimeout);\n             }\n             setProperties(client, localParameters);\n         }", "fixed": "             timeout = localParameters.remove(\"dataTimeout\");\n             if (timeout != null) {\n                dataTimeout = getCamelContext().getTypeConverter().convertTo(int.class, timeout);\n             }\n             setProperties(client, localParameters);\n         }", "sourceBeforeFix": "getCamelContext().getTypeConverter().convertTo(int.class,dataTimeout)", "sourceAfterFix": "getCamelContext().getTypeConverter().convertTo(int.class,timeout)"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory replaceStrings =\n       new PassFactory(\"replaceStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory replaceStrings =\n       new PassFactory(\"replaceStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "a63faf44e1b103a49d25a15c720fc5940ae9fc07", "projectName": "square.retrofit", "bugType": "Change Identifier Used", "problem": "     assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())\n         .isEqualTo(String.class);\n     Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();\n    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())\n         .isEqualTo(String.class);\n     Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();\n    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())\n         .isEqualTo(String.class);\n     Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();", "fixed": "     assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())\n         .isEqualTo(String.class);\n     Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();\n    assertThat(factory.get(mResponseClass, NO_ANNOTATIONS, retrofit).responseType())\n         .isEqualTo(String.class);\n     Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();\n    assertThat(factory.get(fResponseClass, NO_ANNOTATIONS, retrofit).responseType())\n         .isEqualTo(String.class);\n     Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();", "sourceBeforeFix": "factory.get(sResponseClass,NO_ANNOTATIONS,retrofit)", "sourceAfterFix": "factory.get(fResponseClass,NO_ANNOTATIONS,retrofit)"}
{"fixCommitSHA1": "7d5e825abd68a4ffcb86865149b917edf76a47b6", "projectName": "checkstyle.checkstyle", "bugType": "Change Identifier Used", "problem": "     public static DetailAST getAnnotationHolder(DetailAST ast)\n     {\n         if (ast == null) {\n            throw new NullPointerException(\"the ast is null\");\n         }\n         final DetailAST annotationHolder;", "fixed": "     public static DetailAST getAnnotationHolder(DetailAST ast)\n     {\n         if (ast == null) {\n            throw new IllegalArgumentException(\"the ast is null\");\n         }\n         final DetailAST annotationHolder;", "sourceBeforeFix": "new NullPointerException(\"the ast is null\")", "sourceAfterFix": "new IllegalArgumentException(\"the ast is null\")"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory ignoreCajaProperties =\n       new PassFactory(\"ignoreCajaProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory ignoreCajaProperties =\n       new PassFactory(\"ignoreCajaProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "48ea8f3eaa9a3047893d0acd5304035912ebb681", "projectName": "facebook.presto", "bugType": "Wrong Function Name", "problem": "         requireNonNull(systemMemoryContext, \"systemMemoryContext is null\");\n         this.bufferMemoryUsage = systemMemoryContext.newLocalMemoryContext();\n         this.fixedMemoryUsage = systemMemoryContext.newLocalMemoryContext();\n        this.fixedMemoryUsage.setBytes(sliceInput.length());\n         if (!decompressor.isPresent()) {\n             this.current = sliceInput;", "fixed": "         requireNonNull(systemMemoryContext, \"systemMemoryContext is null\");\n         this.bufferMemoryUsage = systemMemoryContext.newLocalMemoryContext();\n         this.fixedMemoryUsage = systemMemoryContext.newLocalMemoryContext();\n        this.fixedMemoryUsage.setBytes(sliceInput.getRetainedSize());\n         if (!decompressor.isPresent()) {\n             this.current = sliceInput;", "sourceBeforeFix": "sliceInput.length()", "sourceAfterFix": "sliceInput.getRetainedSize()"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory inlineSimpleMethods =\n       new PassFactory(\"inlineSimpleMethods\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory inlineSimpleMethods =\n       new PassFactory(\"inlineSimpleMethods\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "8264af051e753ff408e860607575178a2d892b7d", "projectName": "AsyncHttpClient.async-http-client", "bugType": "More Specific If", "problem": "                     int length = lengthWrapper[0];\n                     nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));\n                     nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));\n                } else if (request.getParams() != null) {\n                     StringBuilder sb = new StringBuilder();\n                     for (final Entry<String, List<String>> paramEntry : request.getParams()) {\n                         final String key = paramEntry.getKey();", "fixed": "                     int length = lengthWrapper[0];\n                     nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));\n                     nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));\n                } else if (request.getParams() != null && !request.getParams().isEmpty()) {\n                     StringBuilder sb = new StringBuilder();\n                     for (final Entry<String, List<String>> paramEntry : request.getParams()) {\n                         final String key = paramEntry.getKey();", "sourceBeforeFix": "request.getParams() != null", "sourceAfterFix": "request.getParams() != null && !request.getParams().isEmpty()"}
{"fixCommitSHA1": "930d814a14d2221a9b745802ea946f44e1b32588", "projectName": "apache.camel", "bugType": "Change Modifier", "problem": "     \n    public static interface ServerEndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedServerEndpointProducerBuilder advanced() {", "fixed": "     \n    public interface ServerEndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedServerEndpointProducerBuilder advanced() {", "sourceBeforeFix": "9", "sourceAfterFix": "1"}
{"fixCommitSHA1": "55ed50c4975cf694828d46ee9ca32ce72a9ef913", "projectName": "clojure.clojure", "bugType": "Change Identifier Used", "problem": " \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, args.rest());\r\n \t\tcase 20:\r\n\t\t\treturn invoke(args.first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r", "fixed": " \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, args.rest());\r\n \t\tcase 20:\r\n\t\t\treturn doInvoke(args.first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r\n \t\t\t\t\t, (args = args.rest()).first()\r", "sourceBeforeFix": "invoke(args.first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),args.rest())", "sourceAfterFix": "doInvoke(args.first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),(args=args.rest()).first(),args.rest())"}
{"fixCommitSHA1": "609361434c29e231a2d296dcd39e10de8dc50de6", "projectName": "alibaba.fastjson", "bugType": "Same Function More Args", "problem": "     public void test_cn_3() throws Exception {\n         Entity vo = JSON.parseObject(\"{\\\"date\\\":\\\"2016\u5e7405\u67086\u65e5\\\"}\", Entity.class);\n        Calendar calendar = Calendar.getInstance(JSON.defaultLocale);\n         calendar.setTime(vo.date);\n         Assert.assertEquals(2016, calendar.get(Calendar.YEAR));\n         Assert.assertEquals(4, calendar.get(Calendar.MONTH));", "fixed": "     public void test_cn_3() throws Exception {\n         Entity vo = JSON.parseObject(\"{\\\"date\\\":\\\"2016\u5e7405\u67086\u65e5\\\"}\", Entity.class);\n        Calendar calendar = Calendar.getInstance(JSON.defaultTimeZone, JSON.defaultLocale);\n         calendar.setTime(vo.date);\n         Assert.assertEquals(2016, calendar.get(Calendar.YEAR));\n         Assert.assertEquals(4, calendar.get(Calendar.MONTH));", "sourceBeforeFix": "Calendar.getInstance(JSON.defaultLocale)", "sourceAfterFix": "Calendar.getInstance(JSON.defaultTimeZone,JSON.defaultLocale)"}
{"fixCommitSHA1": "74d1fbf11bad03768e3b9a8b257e4c18ed05416f", "projectName": "libgdx.libgdx", "bugType": "Wrong Function Name", "problem": " \t}\r\n \tpublic void glUniform1fv (int location, int count, FloatBuffer v) {\r\n\t\tGL20.glUniform1(location, v);\r\n \t}\r\n \tpublic void glUniform1fv (int location, int count, float[] v, int offset) {\r\n\t\tGL20.glUniform1(location, toFloatBuffer(v, offset, count));\r\n \t}\r\n \tpublic void glUniform1i (int location, int x) {\r", "fixed": " \t}\r\n \tpublic void glUniform1fv (int location, int count, FloatBuffer v) {\r\n\t\tGL20.glUniform1fv(location, v);\r\n \t}\r\n \tpublic void glUniform1fv (int location, int count, float[] v, int offset) {\r\n\t\tGL20.glUniform1fv(location, toFloatBuffer(v, offset, count));\r\n \t}\r\n \tpublic void glUniform1i (int location, int x) {\r", "sourceBeforeFix": "GL11.glGetTexParameter(target,pname,params)", "sourceAfterFix": "GL11.glGetTexParameterfv(target,pname,params)"}
{"fixCommitSHA1": "1adccc7a5bdc515f01ae6bd644097ab85336bd84", "projectName": "hazelcast.hazelcast", "bugType": "Same Function More Args", "problem": "         populateNearCache(clientMap, 1000);\n        HazelcastInstance member = hazelcastFactory.newHazelcastInstance();\n         final ClearEventCounterEventHandler handler = new ClearEventCounterEventHandler();", "fixed": "         populateNearCache(clientMap, 1000);\n        HazelcastInstance member = hazelcastFactory.newHazelcastInstance(newConfig());\n         final ClearEventCounterEventHandler handler = new ClearEventCounterEventHandler();", "sourceBeforeFix": "hazelcastFactory.newHazelcastClient()", "sourceAfterFix": "hazelcastFactory.newHazelcastClient(newClientConfig())"}
{"fixCommitSHA1": "aa82999d9d18f5c818216aac842929c02ab86be9", "projectName": "hazelcast.hazelcast", "bugType": "Less Specific If", "problem": "             Throwable error = null;\n             for (int i = 0; i < 100; i++) {\n                 /**\n                 * Instead of reusing the ServerSocket/ServerSocketChannel, we are going to close replace them on\n                  * every attempt to find a free port. The reason to do this is because in some cases, when concurrent\n                  * threads/processes try to acquire the same port, the ServerSocket gets corrupted and isn't able to find\n                  * any free port at all (no matter if there are more than enough free ports available). We have seen this", "fixed": "             Throwable error = null;\n             for (int i = 0; i < 100; i++) {\n                 /**\n                 * Instead of reusing the ServerSocket/ServerSocketChannel, we are going to close and replace them on\n                  * every attempt to find a free port. The reason to do this is because in some cases, when concurrent\n                  * threads/processes try to acquire the same port, the ServerSocket gets corrupted and isn't able to find\n                  * any free port at all (no matter if there are more than enough free ports available). We have seen this", "sourceBeforeFix": "serverSocket == null", "sourceAfterFix": "serverSocket == null || !serverSocket.isBound()"}
{"fixCommitSHA1": "930d814a14d2221a9b745802ea946f44e1b32588", "projectName": "apache.camel", "bugType": "Change Modifier", "problem": "     \n    public static interface HazelcastQueueEndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedHazelcastQueueEndpointProducerBuilder advanced() {", "fixed": "     \n    public interface HazelcastQueueEndpointProducerBuilder\n             extends\n                 EndpointProducerBuilder {\n         default AdvancedHazelcastQueueEndpointProducerBuilder advanced() {", "sourceBeforeFix": "9", "sourceAfterFix": "1"}
{"fixCommitSHA1": "8abfa48f2eb5edaf3f5a2cc2350e4e3c232f4152", "projectName": "checkstyle.checkstyle", "bugType": "Change Modifier", "problem": "     \n    public ListToTreeSelectionModelWrapper(JTreeTable jTreeTable) {\n         treeTable = jTreeTable;\n         getListSelectionModel().addListSelectionListener(createListSelectionListener());\n     }", "fixed": "     \n    ListToTreeSelectionModelWrapper(JTreeTable jTreeTable) {\n         treeTable = jTreeTable;\n         getListSelectionModel().addListSelectionListener(createListSelectionListener());\n     }", "sourceBeforeFix": "1", "sourceAfterFix": "0"}
{"fixCommitSHA1": "73248ac2e39d5f905aeab743fc8410c6943474ba", "projectName": "antlr.antlr4", "bugType": "Change Numeric Literal", "problem": " \t@Test\n \tpublic void testMultipleAlternativesWithCommonLabel_3() throws Exception {\n \t\tmkdir(tmpdir);\n\t\tStringBuilder grammarBuilder = new StringBuilder(639);\n \t\tgrammarBuilder.append(\"grammar T;\\n\");\n \t\tgrammarBuilder.append(\"s : e {console.log($e.v);};\\n\");\n \t\tgrammarBuilder.append(\"e returns [int v]\\n\");", "fixed": " \t@Test\n \tpublic void testMultipleAlternativesWithCommonLabel_3() throws Exception {\n \t\tmkdir(tmpdir);\n\t\tStringBuilder grammarBuilder = new StringBuilder(638);\n \t\tgrammarBuilder.append(\"grammar T;\\n\");\n \t\tgrammarBuilder.append(\"s : e {console.log($e.v);};\\n\");\n \t\tgrammarBuilder.append(\"e returns [int v]\\n\");", "sourceBeforeFix": "new StringBuilder(246)", "sourceAfterFix": "new StringBuilder(245)"}
{"fixCommitSHA1": "8afc77b3acd1616a19c58863c71febaf702cf7bf", "projectName": "yusuke.twitter4j", "bugType": "Wrong Function Name", "problem": "* @see <a href=\"http:\n      */\n     public ResponseList<Status> getRetweetedByMe() throws TwitterException {\n        return Status.constructStatuses(get(getBaseURL() + \"statuses/retweeted_by_me.json\",\n                 null, true));\n     }", "fixed": "* @see <a href=\"http:\n      */\n     public ResponseList<Status> getRetweetedByMe() throws TwitterException {\n        return Status.createStatuseList(get(getBaseURL() + \"statuses/retweeted_by_me.json\",\n                 null, true));\n     }", "sourceBeforeFix": "Status.constructStatuses(get(getBaseURL() + \"statuses/retweeted_by_me.json\",null,paging.asPostParameterList(),true))", "sourceAfterFix": "Status.createStatuseList(get(getBaseURL() + \"statuses/retweeted_by_me.json\",null,paging.asPostParameterList(),true))"}
{"fixCommitSHA1": "5f5f02b1272ceba5e72ac8bb29e3d260d66bd493", "projectName": "apache.flink", "bugType": "Same Function More Args", "problem": " \t\tif (serializerString == null) {\n \t\t\tfinal DataOutputSerializer outputSerializer = new DataOutputSerializer(128);\n \t\t\ttry {\n\t\t\t\tserializer.snapshotConfiguration().writeSnapshot(outputSerializer);\n \t\t\t\tserializerString = EncodingUtils.encodeBytesToBase64(outputSerializer.getCopyOfBuffer());\n \t\t\t\treturn serializerString;\n \t\t\t} catch (Exception e) {", "fixed": " \t\tif (serializerString == null) {\n \t\t\tfinal DataOutputSerializer outputSerializer = new DataOutputSerializer(128);\n \t\t\ttry {\n\t\t\t\tTypeSerializerSnapshot.writeVersionedSnapshot(outputSerializer, serializer.snapshotConfiguration());\n \t\t\t\tserializerString = EncodingUtils.encodeBytesToBase64(outputSerializer.getCopyOfBuffer());\n \t\t\t\treturn serializerString;\n \t\t\t} catch (Exception e) {", "sourceBeforeFix": "new TableException(String.format(\"Unable to generate a string representation of the serializer snapshot of '%s' \" + \"describing the class '%s' for the ANY type.\",serializer.getClass().getName(),clazz.toString()))", "sourceAfterFix": "new TableException(String.format(\"Unable to generate a string representation of the serializer snapshot of '%s' \" + \"describing the class '%s' for the ANY type.\",serializer.getClass().getName(),clazz.toString()),e)"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "   };\n   \n  private final PassFactory deadAssignmentsElimination =\n       new PassFactory(\"deadAssignmentsElimination\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "   };\n   \n  final PassFactory deadAssignmentsElimination =\n       new PassFactory(\"deadAssignmentsElimination\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
{"fixCommitSHA1": "042b972a5853424d39be1cb76f2710d4bc3380e0", "projectName": "google.closure-compiler", "bugType": "Change Modifier", "problem": "    * Renames properties so that the two properties that never appear on\n    * the same object get the same name.\n    */\n  private final PassFactory ambiguateProperties =\n       new PassFactory(\"ambiguateProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "fixed": "    * Renames properties so that the two properties that never appear on\n    * the same object get the same name.\n    */\n  final PassFactory ambiguateProperties =\n       new PassFactory(\"ambiguateProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {", "sourceBeforeFix": "18", "sourceAfterFix": "16"}
