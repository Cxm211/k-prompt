{"name": "flatten.py", "problem": "def flatten(arr):\n    for x in arr:\n        if isinstance(x, list):\n            for y in flatten(x):\n                yield y\n        else:\n            yield flatten(x)", "fixed": "def flatten(arr):\n    for x in arr:\n        if isinstance(x, list):\n            for y in flatten(x):\n                yield y\n        else:\n            yield x", "hint": "Flatten\nFlattens a nested list data structure into a single list.\nInput:", "input": [["moe", "curly", "larry"]], "output": ["moe", "curly", "larry"]}
{"name": "reverse_linked_list.py", "problem": "def reverse_linked_list(node):\n    prevnode = None\n    while node:\n        nextnode = node.successor\n        node.successor = prevnode\n        node = nextnode\n    return prevnode", "fixed": "def reverse_linked_list(node):\n    prevnode = None\n    while node:\n        nextnode = node.successor\n        node.successor = prevnode\n        prevnode = node\n        node = nextnode\n    return prevnode\n", "hint": "Reverse Linked List\nReverses a linked list and returns the new head.\nInput:", "input": "", "output": ""}
{"name": "shortest_path_lengths.py", "problem": "from collections import defaultdict\ndef shortest_path_lengths(n, length_by_edge):\n    length_by_path = defaultdict(lambda: float('inf'))\n    length_by_path.update({(i, i): 0 for i in range(n)})\n    length_by_path.update(length_by_edge)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                length_by_path[i, j] = min(\n                    length_by_path[i, j],\n                    length_by_path[i, k] + length_by_path[j, k]\n                )\n    return length_by_path", "fixed": "from collections import defaultdict\ndef shortest_path_lengths(n, length_by_edge):\n    length_by_path = defaultdict(lambda: float('inf'))\n    length_by_path.update({(i, i): 0 for i in range(n)})\n    length_by_path.update(length_by_edge)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                length_by_path[i, j] = min(\n                    length_by_path[i, j],\n                    length_by_path[i, k] + length_by_path[k, j]\n                )\n    return length_by_path", "hint": "All Shortest Paths\nfloyd-warshall\nFloyd-Warshall algorithm implementation.", "input": "", "output": ""}
{"name": "possible_change.py", "problem": "def possible_change(coins, total):\n    if total == 0:\n        return 1\n    if total < 0:\n        return 0\n    first, *rest = coins\n    return possible_change(coins, total - first) + possible_change(rest, total)", "fixed": "def possible_change(coins, total):\n    if total == 0:\n        return 1\n    if total < 0 or not coins:\n        return 0\n    first, *rest = coins\n    return possible_change(coins, total - first) + possible_change(rest, total)\n", "hint": "Making Change\nchange\nInput:", "input": [[1, 4, 2], -7], "output":0}
